{
  "version": 3,
  "sources": ["../node_modules/kaboom/src/math.ts", "../node_modules/kaboom/src/utils.ts", "../node_modules/kaboom/src/gamepad.json", "../node_modules/kaboom/src/app.ts", "../node_modules/kaboom/src/easings.ts", "../node_modules/kaboom/src/timer.ts", "../node_modules/kaboom/src/kaboom.ts", "../node_modules/planck/node_modules/tslib/tslib.es6.js", "../node_modules/planck/src/util/options.ts", "../node_modules/planck/src/common/Math.ts", "../node_modules/planck/src/common/Vec2.ts", "../node_modules/planck/src/collision/AABB.ts", "../node_modules/planck/src/Settings.ts", "../node_modules/planck/src/util/Pool.ts", "../node_modules/planck/src/collision/DynamicTree.ts", "../node_modules/planck/src/collision/BroadPhase.ts", "../node_modules/planck/src/common/Matrix.ts", "../node_modules/planck/src/common/Rot.ts", "../node_modules/planck/src/common/Sweep.ts", "../node_modules/planck/src/common/Transform.ts", "../node_modules/planck/src/dynamics/Velocity.ts", "../node_modules/planck/src/dynamics/Position.ts", "../node_modules/planck/src/collision/Shape.ts", "../node_modules/planck/src/dynamics/Fixture.ts", "../node_modules/planck/src/dynamics/Body.ts", "../node_modules/planck/src/dynamics/Joint.ts", "../node_modules/planck/src/util/stats.ts", "../node_modules/planck/src/util/Timer.ts", "../node_modules/planck/src/collision/Distance.ts", "../node_modules/planck/src/collision/TimeOfImpact.ts", "../node_modules/planck/src/dynamics/Solver.ts", "../node_modules/planck/src/common/Mat22.ts", "../node_modules/planck/src/collision/Manifold.ts", "../node_modules/planck/src/dynamics/Contact.ts", "../node_modules/planck/src/dynamics/World.ts", "../node_modules/planck/src/common/Vec3.ts", "../node_modules/planck/src/collision/shape/EdgeShape.ts", "../node_modules/planck/src/collision/shape/ChainShape.ts", "../node_modules/planck/src/collision/shape/PolygonShape.ts", "../node_modules/planck/src/collision/shape/BoxShape.ts", "../node_modules/planck/src/collision/shape/CircleShape.ts", "../node_modules/planck/src/dynamics/joint/DistanceJoint.ts", "../node_modules/planck/src/dynamics/joint/FrictionJoint.ts", "../node_modules/planck/src/common/Mat33.ts", "../node_modules/planck/src/dynamics/joint/RevoluteJoint.ts", "../node_modules/planck/src/dynamics/joint/PrismaticJoint.ts", "../node_modules/planck/src/dynamics/joint/GearJoint.ts", "../node_modules/planck/src/dynamics/joint/MotorJoint.ts", "../node_modules/planck/src/dynamics/joint/MouseJoint.ts", "../node_modules/planck/src/dynamics/joint/PulleyJoint.ts", "../node_modules/planck/src/dynamics/joint/RopeJoint.ts", "../node_modules/planck/src/dynamics/joint/WeldJoint.ts", "../node_modules/planck/src/dynamics/joint/WheelJoint.ts", "../node_modules/planck/src/serializer/index.ts", "../node_modules/planck/src/util/Testbed.ts", "../node_modules/planck/src/collision/shape/CollideCircle.ts", "../node_modules/planck/src/collision/shape/CollideEdgeCircle.ts", "../node_modules/planck/src/collision/shape/CollidePolygon.ts", "../node_modules/planck/src/collision/shape/CollideCirclePolygon.ts", "../node_modules/planck/src/collision/shape/CollideEdgePolygon.ts", "../node_modules/planck/src/internal.ts", "../code/collider.ts", "../code/world.ts", "../code/joint.ts", "../code/effectors.ts", "../code/rigid_body.ts", "../code/main.ts"],
  "sourcesContent": ["import {\n\tPoint,\n\tRNGValue,\n\tLerpValue,\n\tVec2Args,\n} from \"./types\"\n\nexport function deg2rad(deg: number): number {\n\treturn deg * Math.PI / 180\n}\n\nexport function rad2deg(rad: number): number {\n\treturn rad * 180 / Math.PI\n}\n\nexport function clamp(\n\tval: number,\n\tmin: number,\n\tmax: number,\n): number {\n\tif (min > max) {\n\t\treturn clamp(val, max, min)\n\t}\n\treturn Math.min(Math.max(val, min), max)\n}\n\nexport function lerp<V extends LerpValue>(\n\ta: V,\n\tb: V,\n\tt: number,\n): V {\n\tif (typeof a === \"number\" && typeof b === \"number\") {\n\t\treturn a + (b - a) * t as V\n\t} else if (a instanceof Vec2 && b instanceof Vec2) {\n\t\treturn a.lerp(b, t) as V\n\t} else if (a instanceof Color && b instanceof Color) {\n\t\treturn a.lerp(b, t) as V\n\t}\n\tthrow new Error(`Bad value for lerp(): ${a}, ${b}. Only number, Vec2 and Color is supported.`)\n}\n\nexport function map(\n\tv: number,\n\tl1: number,\n\th1: number,\n\tl2: number,\n\th2: number,\n): number {\n\treturn l2 + (v - l1) / (h1 - l1) * (h2 - l2)\n}\n\nexport function mapc(\n\tv: number,\n\tl1: number,\n\th1: number,\n\tl2: number,\n\th2: number,\n): number {\n\treturn clamp(map(v, l1, h1, l2, h2), l2, h2)\n}\n\nexport class Vec2 {\n\tx: number = 0\n\ty: number = 0\n\tconstructor(x: number = 0, y: number = x) {\n\t\tthis.x = x\n\t\tthis.y = y\n\t}\n\tstatic fromAngle(deg: number) {\n\t\tconst angle = deg2rad(deg)\n\t\treturn new Vec2(Math.cos(angle), Math.sin(angle))\n\t}\n\tstatic LEFT = new Vec2(-1, 0)\n\tstatic RIGHT = new Vec2(1, 0)\n\tstatic UP = new Vec2(0, -1)\n\tstatic DOWN = new Vec2(0, 1)\n\tclone(): Vec2 {\n\t\treturn new Vec2(this.x, this.y)\n\t}\n\tadd(...args: Vec2Args): Vec2 {\n\t\tconst p2 = vec2(...args)\n\t\treturn new Vec2(this.x + p2.x, this.y + p2.y)\n\t}\n\tsub(...args: Vec2Args): Vec2 {\n\t\tconst p2 = vec2(...args)\n\t\treturn new Vec2(this.x - p2.x, this.y - p2.y)\n\t}\n\tscale(...args: Vec2Args): Vec2 {\n\t\tconst s = vec2(...args)\n\t\treturn new Vec2(this.x * s.x, this.y * s.y)\n\t}\n\tdist(...args: Vec2Args): number {\n\t\tconst p2 = vec2(...args)\n\t\treturn this.sub(p2).len()\n\t}\n\tsdist(...args: Vec2Args): number {\n\t\tconst p2 = vec2(...args)\n\t\treturn this.sub(p2).slen()\n\t}\n\tlen(): number {\n\t\treturn Math.sqrt(this.dot(this))\n\t}\n\tslen(): number {\n\t\treturn this.dot(this)\n\t}\n\tunit(): Vec2 {\n\t\tconst len = this.len()\n\t\treturn len === 0 ? new Vec2(0) : this.scale(1 / len)\n\t}\n\tnormal(): Vec2 {\n\t\treturn new Vec2(this.y, -this.x)\n\t}\n\treflect(normal: Vec2) {\n\t\treturn this.sub(normal.scale(2 * this.dot(normal)))\n\t}\n\tproject(on: Vec2) {\n\t\treturn on.scale(on.dot(this) / on.len())\n\t}\n\treject(on: Vec2) {\n\t\treturn this.sub(this.project(on))\n\t}\n\tdot(p2: Vec2): number {\n\t\treturn this.x * p2.x + this.y * p2.y\n\t}\n\tcross(p2: Vec2): number {\n\t\treturn this.x * p2.y - this.y * p2.x\n\t}\n\tangle(...args: Vec2Args): number {\n\t\tconst p2 = vec2(...args)\n\t\treturn rad2deg(Math.atan2(this.y - p2.y, this.x - p2.x))\n\t}\n\tangleBetween(...args: Vec2Args): number {\n\t\tconst p2 = vec2(...args)\n\t\treturn rad2deg(Math.atan2(this.cross(p2), this.dot(p2)))\n\t}\n\tlerp(dest: Vec2, t: number): Vec2 {\n\t\treturn new Vec2(lerp(this.x, dest.x, t), lerp(this.y, dest.y, t))\n\t}\n\tslerp(dest: Vec2, t: number): Vec2 {\n\t\tconst cos = this.dot(dest)\n\t\tconst sin = this.cross(dest)\n\t\tconst angle = Math.atan2(sin, cos)\n\t\treturn this\n\t\t\t.scale(Math.sin((1 - t) * angle))\n\t\t\t.add(dest.scale(Math.sin(t * angle)))\n\t\t\t.scale(1 / sin)\n\t}\n\tisZero(): boolean {\n\t\treturn this.x === 0 && this.y === 0\n\t}\n\ttoFixed(n: number): Vec2 {\n\t\treturn new Vec2(Number(this.x.toFixed(n)), Number(this.y.toFixed(n)))\n\t}\n\ttransform(m: Mat4): Vec2 {\n\t\treturn m.multVec2(this)\n\t}\n\teq(other: Vec2): boolean {\n\t\treturn this.x === other.x && this.y === other.y\n\t}\n\tbbox(): Rect {\n\t\treturn new Rect(this, 0, 0)\n\t}\n\ttoString(): string {\n\t\treturn `vec2(${this.x.toFixed(2)}, ${this.y.toFixed(2)})`\n\t}\n}\n\nexport function vec2(...args: Vec2Args): Vec2 {\n\tif (args.length === 1) {\n\t\tif (args[0] instanceof Vec2) {\n\t\t\treturn new Vec2(args[0].x, args[0].y)\n\t\t} else if (Array.isArray(args[0]) && args[0].length === 2) {\n\t\t\treturn new Vec2(...args[0])\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn new Vec2(...args)\n}\n\nexport class Color {\n\n\tr: number = 255\n\tg: number = 255\n\tb: number = 255\n\n\tconstructor(r: number, g: number, b: number) {\n\t\tthis.r = clamp(r, 0, 255)\n\t\tthis.g = clamp(g, 0, 255)\n\t\tthis.b = clamp(b, 0, 255)\n\t}\n\n\tstatic fromArray(arr: number[]) {\n\t\treturn new Color(arr[0], arr[1], arr[2])\n\t}\n\n\tstatic fromHex(hex: string | number) {\n\t\tif (typeof hex === \"number\") {\n\t\t\treturn new Color(\n\t\t\t\t(hex >> 16) & 0xff,\n\t\t\t\t(hex >> 8) & 0xff,\n\t\t\t\t(hex >> 0) & 0xff,\n\t\t\t)\n\t\t} else if (typeof hex === \"string\") {\n\t\t\tconst result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex)\n\t\t\treturn new Color(\n\t\t\t\tparseInt(result[1], 16),\n\t\t\t\tparseInt(result[2], 16),\n\t\t\t\tparseInt(result[3], 16),\n\t\t\t)\n\t\t} else {\n\t\t\tthrow new Error(\"Invalid hex color format\")\n\t\t}\n\t}\n\n\t// TODO: use range of [0, 360] [0, 100] [0, 100]?\n\tstatic fromHSL(h: number, s: number, l: number) {\n\n\t\tif (s == 0){\n\t\t\treturn new Color(255 * l, 255 * l, 255 * l)\n\t\t}\n\n\t\tconst hue2rgb = (p, q, t) => {\n\t\t\tif (t < 0) t += 1\n\t\t\tif (t > 1) t -= 1\n\t\t\tif (t < 1 / 6) return p + (q - p) * 6 * t\n\t\t\tif (t < 1 / 2) return q\n\t\t\tif (t < 2 / 3) return p + (q - p) * (2/3 - t) * 6\n\t\t\treturn p\n\t\t}\n\n\t\tconst q = l < 0.5 ? l * (1 + s) : l + s - l * s\n\t\tconst p = 2 * l - q\n\t\tconst r = hue2rgb(p, q, h + 1 / 3)\n\t\tconst g = hue2rgb(p, q, h)\n\t\tconst b = hue2rgb(p, q, h - 1 / 3)\n\n\t\treturn new Color(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255))\n\n\t}\n\n\tstatic RED = new Color(255, 0, 0)\n\tstatic GREEN = new Color(0, 255, 0)\n\tstatic BLUE = new Color(0, 0, 255)\n\tstatic YELLOW = new Color(255, 255, 0)\n\tstatic MAGENTA = new Color(255, 0, 255)\n\tstatic CYAN = new Color(0, 255, 255)\n\tstatic WHITE = new Color(255, 255, 255)\n\tstatic BLACK = new Color(0, 0, 0)\n\n\tclone(): Color {\n\t\treturn new Color(this.r, this.g, this.b)\n\t}\n\n\tlighten(a: number): Color {\n\t\treturn new Color(this.r + a, this.g + a, this.b + a)\n\t}\n\n\tdarken(a: number): Color {\n\t\treturn this.lighten(-a)\n\t}\n\n\tinvert(): Color {\n\t\treturn new Color(255 - this.r, 255 - this.g, 255 - this.b)\n\t}\n\n\tmult(other: Color): Color {\n\t\treturn new Color(\n\t\t\tthis.r * other.r / 255,\n\t\t\tthis.g * other.g / 255,\n\t\t\tthis.b * other.b / 255,\n\t\t)\n\t}\n\n\tlerp(dest: Color, t: number): Color {\n\t\treturn new Color(\n\t\t\tlerp(this.r, dest.r, t),\n\t\t\tlerp(this.g, dest.g, t),\n\t\t\tlerp(this.b, dest.b, t),\n\t\t)\n\t}\n\n\ttoHSL(): [number, number, number] {\n\t\tconst r = this.r / 255\n\t\tconst g = this.g / 255\n\t\tconst b = this.b / 255\n\t\tconst max = Math.max(r, g, b), min = Math.min(r, g, b)\n\t\tlet h = (max + min) / 2\n\t\tlet s = h\n\t\tconst l = h\n\t\tif (max == min) {\n\t\t\th = s = 0\n\t\t} else {\n\t\t\tconst d = max - min\n\t\t\ts = l > 0.5 ? d / (2 - max - min) : d / (max + min)\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break\n\t\t\t\tcase g: h = (b - r) / d + 2; break\n\t\t\t\tcase b: h = (r - g) / d + 4; break\n\t\t\t}\n\t\t\th /= 6\n\t\t}\n\t\treturn [ h, s, l ]\n\t}\n\n\teq(other: Color): boolean {\n\t\treturn this.r === other.r\n\t\t\t&& this.g === other.g\n\t\t\t&& this.b === other.b\n\n\t}\n\n\ttoString(): string {\n\t\treturn `rgb(${this.r}, ${this.g}, ${this.b})`\n\t}\n\n\ttoHex(): string {\n\t\treturn \"#\" + ((1 << 24) + (this.r << 16) + (this.g << 8) + this.b).toString(16).slice(1)\n\t}\n\n}\n\nexport function rgb(...args): Color {\n\tif (args.length === 0) {\n\t\treturn new Color(255, 255, 255)\n\t} else if (args.length === 1) {\n\t\tif (args[0] instanceof Color) {\n\t\t\treturn args[0].clone()\n\t\t} else if (typeof args[0] === \"string\") {\n\t\t\treturn Color.fromHex(args[0])\n\t\t} else if (Array.isArray(args[0]) && args[0].length === 3) {\n\t\t\treturn Color.fromArray(args[0])\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn new Color(...args)\n}\n\nexport const hsl2rgb = (h, s, l) => Color.fromHSL(h, s, l)\n\nexport class Quad {\n\tx: number = 0\n\ty: number = 0\n\tw: number = 1\n\th: number = 1\n\tconstructor(x: number, y: number, w: number, h: number) {\n\t\tthis.x = x\n\t\tthis.y = y\n\t\tthis.w = w\n\t\tthis.h = h\n\t}\n\tscale(other: Quad): Quad {\n\t\treturn new Quad(\n\t\t\tthis.x + this.w * other.x,\n\t\t\tthis.y + this.h * other.y,\n\t\t\tthis.w * other.w,\n\t\t\tthis.h * other.h,\n\t\t)\n\t}\n\tpos() {\n\t\treturn new Vec2(this.x, this.y)\n\t}\n\tclone(): Quad {\n\t\treturn new Quad(this.x, this.y, this.w, this.h)\n\t}\n\teq(other: Quad): boolean {\n\t\treturn this.x === other.x\n\t\t\t&& this.y === other.y\n\t\t\t&& this.w === other.w\n\t\t\t&& this.h === other.h\n\t}\n\ttoString(): string {\n\t\treturn `quad(${this.x}, ${this.y}, ${this.w}, ${this.h})`\n\t}\n}\n\nexport function quad(x: number, y: number, w: number, h: number): Quad {\n\treturn new Quad(x, y, w, h)\n}\n\nexport class Mat4 {\n\n\tm: number[] = [\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1,\n\t]\n\n\tconstructor(m?: number[]) {\n\t\tif (m) {\n\t\t\tthis.m = m\n\t\t}\n\t}\n\n\tstatic translate(p: Vec2): Mat4 {\n\t\treturn new Mat4([\n\t\t\t1, 0, 0, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\tp.x, p.y, 0, 1,\n\t\t])\n\t}\n\n\tstatic scale(s: Vec2): Mat4 {\n\t\treturn new Mat4([\n\t\t\ts.x, 0, 0, 0,\n\t\t\t0, s.y, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1,\n\t\t])\n\t}\n\n\tstatic rotateX(a: number): Mat4 {\n\t\ta = deg2rad(-a)\n\t\tconst c = Math.cos(a)\n\t\tconst s = Math.sin(a)\n\t\treturn new Mat4([\n\t\t\t1, 0, 0, 0,\n\t\t\t0, c, -s, 0,\n\t\t\t0, s, c, 0,\n\t\t\t0, 0, 0, 1,\n\t\t])\n\t}\n\n\tstatic rotateY(a: number): Mat4 {\n\t\ta = deg2rad(-a)\n\t\tconst c = Math.cos(a)\n\t\tconst s = Math.sin(a)\n\t\treturn new Mat4([\n\t\t\tc, 0, s, 0,\n\t\t\t0, 1, 0, 0,\n\t\t\t-s, 0, c, 0,\n\t\t\t0, 0, 0, 1,\n\t\t])\n\t}\n\n\tstatic rotateZ(a: number): Mat4 {\n\t\ta = deg2rad(-a)\n\t\tconst c = Math.cos(a)\n\t\tconst s = Math.sin(a)\n\t\treturn new Mat4([\n\t\t\tc, -s, 0, 0,\n\t\t\ts, c, 0, 0,\n\t\t\t0, 0, 1, 0,\n\t\t\t0, 0, 0, 1,\n\t\t])\n\t}\n\n\ttranslate(p: Vec2) {\n\t\tthis.m[12] += this.m[0] * p.x + this.m[4] * p.y\n\t\tthis.m[13] += this.m[1] * p.x + this.m[5] * p.y\n\t\tthis.m[14] += this.m[2] * p.x + this.m[6] * p.y\n\t\tthis.m[15] += this.m[3] * p.x + this.m[7] * p.y\n\t\treturn this\n\t}\n\n\tscale(p: Vec2) {\n\t\tthis.m[0] *= p.x\n\t\tthis.m[4] *= p.y\n\t\tthis.m[1] *= p.x\n\t\tthis.m[5] *= p.y\n\t\tthis.m[2] *= p.x\n\t\tthis.m[6] *= p.y\n\t\tthis.m[3] *= p.x\n\t\tthis.m[7] *= p.y\n\t\treturn this\n\t}\n\n\trotate(a: number): Mat4 {\n\t\ta = deg2rad(-a)\n\t\tconst c = Math.cos(a)\n\t\tconst s = Math.sin(a)\n\t\tconst m0 = this.m[0]\n\t\tconst m1 = this.m[1]\n\t\tconst m4 = this.m[4]\n\t\tconst m5 = this.m[5]\n\t\tthis.m[0] = m0 * c + m1 * s\n\t\tthis.m[1] = -m0 * s + m1 * c\n\t\tthis.m[4] = m4 * c + m5 * s\n\t\tthis.m[5] = -m4 * s + m5 * c\n\t\treturn this\n\t}\n\n\t// TODO: in-place variant\n\tmult(other: Mat4): Mat4 {\n\t\tconst out = []\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tfor (let j = 0; j < 4; j++) {\n\t\t\t\tout[i * 4 + j] =\n\t\t\t\t\tthis.m[0 * 4 + j] * other.m[i * 4 + 0] +\n\t\t\t\t\tthis.m[1 * 4 + j] * other.m[i * 4 + 1] +\n\t\t\t\t\tthis.m[2 * 4 + j] * other.m[i * 4 + 2] +\n\t\t\t\t\tthis.m[3 * 4 + j] * other.m[i * 4 + 3]\n\t\t\t}\n\t\t}\n\t\treturn new Mat4(out)\n\t}\n\n\tmultVec2(p: Vec2): Vec2 {\n\t\treturn new Vec2(\n\t\t\tp.x * this.m[0] + p.y * this.m[4] + this.m[12],\n\t\t\tp.x * this.m[1] + p.y * this.m[5] + this.m[13],\n\t\t)\n\t}\n\n\tgetTranslation() {\n\t\treturn new Vec2(this.m[12], this.m[13])\n\t}\n\n\tgetScale() {\n\t\tif (this.m[0] != 0 || this.m[1] != 0) {\n\t\t\tconst det = this.m[0] * this.m[5] - this.m[1] * this.m[4]\n\t\t\tconst r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1])\n\t\t\treturn new Vec2(r, det / r)\n\t\t} else if (this.m[4] != 0 || this.m[5] != 0) {\n\t\t\tconst det = this.m[0] * this.m[5] - this.m[1] * this.m[4]\n\t\t\tconst s = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5])\n\t\t\treturn new Vec2(det / s, s)\n\t\t} else {\n\t\t\treturn new Vec2(0, 0)\n\t\t}\n\t}\n\n\tgetRotation() {\n\t\tif (this.m[0] != 0 || this.m[1] != 0) {\n\t\t\tconst r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1])\n\t\t\treturn rad2deg(this.m[1] > 0 ? Math.acos(this.m[0] / r) : -Math.acos(this.m[0] / r))\n\t\t} else if (this.m[4] != 0 || this.m[5] != 0) {\n\t\t\tconst s = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5])\n\t\t\treturn rad2deg(Math.PI / 2 - (this.m[5] > 0 ? Math.acos(-this.m[4] / s) : -Math.acos(this.m[4] / s)))\n\t\t} else {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\tgetSkew() {\n\t\tif (this.m[0] != 0 || this.m[1] != 0) {\n\t\t\tconst r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1])\n\t\t\treturn new Vec2(Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (r * r), 0)\n\t\t}\n\t\telse if (this.m[4] != 0 || this.m[5] != 0) {\n\t\t\tconst s = Math.sqrt(this.m[4] * this.m[4] + this.m[5] * this.m[5])\n\t\t\treturn new Vec2(0, Math.atan(this.m[0] * this.m[4] + this.m[1] * this.m[5]) / (s * s))\n\t\t}\n\t\telse {\n\t\t\treturn new Vec2(0, 0)\n\t\t}\n\t}\n\n\tinvert(): Mat4 {\n\n\t\tconst out = []\n\n\t\tconst f00 = this.m[10] * this.m[15] - this.m[14] * this.m[11]\n\t\tconst f01 = this.m[9] * this.m[15] - this.m[13] * this.m[11]\n\t\tconst f02 = this.m[9] * this.m[14] - this.m[13] * this.m[10]\n\t\tconst f03 = this.m[8] * this.m[15] - this.m[12] * this.m[11]\n\t\tconst f04 = this.m[8] * this.m[14] - this.m[12] * this.m[10]\n\t\tconst f05 = this.m[8] * this.m[13] - this.m[12] * this.m[9]\n\t\tconst f06 = this.m[6] * this.m[15] - this.m[14] * this.m[7]\n\t\tconst f07 = this.m[5] * this.m[15] - this.m[13] * this.m[7]\n\t\tconst f08 = this.m[5] * this.m[14] - this.m[13] * this.m[6]\n\t\tconst f09 = this.m[4] * this.m[15] - this.m[12] * this.m[7]\n\t\tconst f10 = this.m[4] * this.m[14] - this.m[12] * this.m[6]\n\t\tconst f11 = this.m[5] * this.m[15] - this.m[13] * this.m[7]\n\t\tconst f12 = this.m[4] * this.m[13] - this.m[12] * this.m[5]\n\t\tconst f13 = this.m[6] * this.m[11] - this.m[10] * this.m[7]\n\t\tconst f14 = this.m[5] * this.m[11] - this.m[9] * this.m[7]\n\t\tconst f15 = this.m[5] * this.m[10] - this.m[9] * this.m[6]\n\t\tconst f16 = this.m[4] * this.m[11] - this.m[8] * this.m[7]\n\t\tconst f17 = this.m[4] * this.m[10] - this.m[8] * this.m[6]\n\t\tconst f18 = this.m[4] * this.m[9] - this.m[8] * this.m[5]\n\n\t\tout[0] = this.m[5] * f00 - this.m[6] * f01 + this.m[7] * f02\n\t\tout[4] = -(this.m[4] * f00 - this.m[6] * f03 + this.m[7] * f04)\n\t\tout[8] = this.m[4] * f01 - this.m[5] * f03 + this.m[7] * f05\n\t\tout[12] = -(this.m[4] * f02 - this.m[5] * f04 + this.m[6] * f05)\n\n\t\tout[1] = -(this.m[1] * f00 - this.m[2] * f01 + this.m[3] * f02)\n\t\tout[5] = this.m[0] * f00 - this.m[2] * f03 + this.m[3] * f04\n\t\tout[9] = -(this.m[0] * f01 - this.m[1] * f03 + this.m[3] * f05)\n\t\tout[13] = this.m[0] * f02 - this.m[1] * f04 + this.m[2] * f05\n\n\t\tout[2] = this.m[1] * f06 - this.m[2] * f07 + this.m[3] * f08\n\t\tout[6] = -(this.m[0] * f06 - this.m[2] * f09 + this.m[3] * f10)\n\t\tout[10] = this.m[0] * f11 - this.m[1] * f09 + this.m[3] * f12\n\t\tout[14] = -(this.m[0] * f08 - this.m[1] * f10 + this.m[2] * f12)\n\n\t\tout[3] = -(this.m[1] * f13 - this.m[2] * f14 + this.m[3] * f15)\n\t\tout[7] = this.m[0] * f13 - this.m[2] * f16 + this.m[3] * f17\n\t\tout[11] = -(this.m[0] * f14 - this.m[1] * f16 + this.m[3] * f18)\n\t\tout[15] = this.m[0] * f15 - this.m[1] * f17 + this.m[2] * f18\n\n\t\tconst det =\n\t\t\tthis.m[0] * out[0] +\n\t\t\tthis.m[1] * out[4] +\n\t\t\tthis.m[2] * out[8] +\n\t\t\tthis.m[3] * out[12]\n\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tfor (let j = 0; j < 4; j++) {\n\t\t\t\tout[i * 4 + j] *= (1.0 / det)\n\t\t\t}\n\t\t}\n\n\t\treturn new Mat4(out)\n\n\t}\n\n\tclone(): Mat4 {\n\t\treturn new Mat4([...this.m])\n\t}\n\n\ttoString(): string {\n\t\treturn this.m.toString()\n\t}\n\n}\n\nexport function wave(lo: number, hi: number, t: number, f = (t) => -Math.cos(t)): number {\n\treturn lo + (f(t) + 1) / 2 * (hi - lo)\n}\n\n// basic ANSI C LCG\nconst A = 1103515245\nconst C = 12345\nconst M = 2147483648\n\nexport class RNG {\n\tseed: number\n\tconstructor(seed: number) {\n\t\tthis.seed = seed\n\t}\n\tgen(): number {\n\t\tthis.seed = (A * this.seed + C) % M\n\t\treturn this.seed / M\n\t}\n\tgenNumber(a: number, b: number): number {\n\t\treturn a + this.gen() * (b - a)\n\t}\n\tgenVec2(a: Vec2, b?: Vec2): Vec2 {\n\t\treturn new Vec2(\n\t\t\tthis.genNumber(a.x, b.x),\n\t\t\tthis.genNumber(a.y, b.y),\n\t\t)\n\t}\n\tgenColor(a: Color, b: Color): Color {\n\t\treturn new Color(\n\t\t\tthis.genNumber(a.r, b.r),\n\t\t\tthis.genNumber(a.g, b.g),\n\t\t\tthis.genNumber(a.b, b.b),\n\t\t)\n\t}\n\tgenAny<T = RNGValue>(...args: T[]): T {\n\t\tif (args.length === 0) {\n\t\t\treturn this.gen() as T\n\t\t} else if (args.length === 1) {\n\t\t\tif (typeof args[0] === \"number\") {\n\t\t\t\treturn this.genNumber(0, args[0]) as T\n\t\t\t} else if (args[0] instanceof Vec2) {\n\t\t\t\treturn this.genVec2(vec2(0, 0), args[0]) as T\n\t\t\t} else if (args[0] instanceof Color) {\n\t\t\t\treturn this.genColor(rgb(0, 0, 0), args[0]) as T\n\t\t\t}\n\t\t} else if (args.length === 2) {\n\t\t\tif (typeof args[0] === \"number\" && typeof args[1] === \"number\") {\n\t\t\t\treturn this.genNumber(args[0], args[1]) as T\n\t\t\t} else if (args[0] instanceof Vec2 && args[1] instanceof Vec2) {\n\t\t\t\treturn this.genVec2(args[0], args[1]) as T\n\t\t\t} else if (args[0] instanceof Color && args[1] instanceof Color) {\n\t\t\t\treturn this.genColor(args[0], args[1]) as T\n\t\t\t}\n\t\t}\n\t}\n}\n\n// TODO: let user pass seed\nconst defRNG = new RNG(Date.now())\n\nexport function randSeed(seed?: number): number {\n\tif (seed != null) {\n\t\tdefRNG.seed = seed\n\t}\n\treturn defRNG.seed\n}\n\nexport function rand(...args) {\n\t// @ts-ignore\n\treturn defRNG.genAny(...args)\n}\n\n// TODO: randi() to return 0 / 1?\nexport function randi(...args: number[]) {\n\treturn Math.floor(rand(...args))\n}\n\nexport function chance(p: number): boolean {\n\treturn rand() <= p\n}\n\nexport function choose<T>(list: T[]): T {\n\treturn list[randi(list.length)]\n}\n\n// TODO: better name\nexport function testRectRect2(r1: Rect, r2: Rect): boolean {\n\treturn r1.pos.x + r1.width >= r2.pos.x\n\t\t&& r1.pos.x <= r2.pos.x + r2.width\n\t\t&& r1.pos.y + r1.height >= r2.pos.y\n\t\t&& r1.pos.y <= r2.pos.y + r2.height\n}\n\nexport function testRectRect(r1: Rect, r2: Rect): boolean {\n\treturn r1.pos.x + r1.width > r2.pos.x\n\t\t&& r1.pos.x < r2.pos.x + r2.width\n\t\t&& r1.pos.y + r1.height > r2.pos.y\n\t\t&& r1.pos.y < r2.pos.y + r2.height\n}\n\n// TODO: better name\nexport function testLineLineT(l1: Line, l2: Line): number | null {\n\n\tif ((l1.p1.x === l1.p2.x && l1.p1.y === l1.p2.y) || (l2.p1.x === l2.p2.x && l2.p1.y === l2.p2.y)) {\n\t\treturn null\n\t}\n\n\tconst denom = ((l2.p2.y - l2.p1.y) * (l1.p2.x - l1.p1.x) - (l2.p2.x - l2.p1.x) * (l1.p2.y - l1.p1.y))\n\n\t// parallel\n\tif (denom === 0) {\n\t\treturn null\n\t}\n\n\tconst ua = ((l2.p2.x - l2.p1.x) * (l1.p1.y - l2.p1.y) - (l2.p2.y - l2.p1.y) * (l1.p1.x - l2.p1.x)) / denom\n\tconst ub = ((l1.p2.x - l1.p1.x) * (l1.p1.y - l2.p1.y) - (l1.p2.y - l1.p1.y) * (l1.p1.x - l2.p1.x)) / denom\n\n\t// is the intersection on the segments\n\tif (ua < 0 || ua > 1 || ub < 0 || ub > 1) {\n\t\treturn null\n\t}\n\n\treturn ua\n\n}\n\nexport function testLineLine(l1: Line, l2: Line): Vec2 | null {\n\tconst t = testLineLineT(l1, l2)\n\tif (!t) return null\n\treturn vec2(\n\t\tl1.p1.x + t * (l1.p2.x - l1.p1.x),\n\t\tl1.p1.y + t * (l1.p2.y - l1.p1.y),\n\t)\n}\n\nexport function testRectLine(r: Rect, l: Line): boolean {\n\tif (testRectPoint(r, l.p1) || testRectPoint(r, l.p2)) {\n\t\treturn true\n\t}\n\tconst pts = r.points()\n\treturn !!testLineLine(l, new Line(pts[0], pts[1]))\n\t\t|| !!testLineLine(l, new Line(pts[1], pts[2]))\n\t\t|| !!testLineLine(l, new Line(pts[2], pts[3]))\n\t\t|| !!testLineLine(l, new Line(pts[3], pts[0]))\n}\n\nexport function testRectPoint2(r: Rect, pt: Point): boolean {\n\treturn pt.x >= r.pos.x\n\t\t&& pt.x <= r.pos.x + r.width\n\t\t&& pt.y >= r.pos.y\n\t\t&& pt.y <= r.pos.y + r.height\n}\n\nexport function testRectPoint(r: Rect, pt: Point): boolean {\n\treturn pt.x > r.pos.x\n\t\t&& pt.x < r.pos.x + r.width\n\t\t&& pt.y > r.pos.y\n\t\t&& pt.y < r.pos.y + r.height\n}\n\nexport function testRectCircle(r: Rect, c: Circle): boolean {\n\tconst nx = Math.max(r.pos.x, Math.min(c.center.x, r.pos.x + r.width))\n\tconst ny = Math.max(r.pos.y, Math.min(c.center.y, r.pos.y + r.height))\n\tconst nearestPoint = vec2(nx, ny)\n\treturn nearestPoint.sdist(c.center) <= c.radius * c.radius\n}\n\nexport function testRectPolygon(r: Rect, p: Polygon): boolean {\n\treturn testPolygonPolygon(p, new Polygon(r.points()))\n}\n\nexport function testLinePoint(l: Line, pt: Vec2): boolean {\n\tconst v1 = pt.sub(l.p1)\n\tconst v2 = l.p2.sub(l.p1)\n\n\t// Check if sine is 0, in that case lines are parallel.\n\t// If not parallel, the point cannot lie on the line.\n\tif (Math.abs(v1.cross(v2)) > Number.EPSILON) {\n\t\treturn false\n\t}\n\n\t// Scalar projection of v1 on v2\n\tconst t = v1.dot(v2) / v2.dot(v2)\n\t// Since t is percentual distance of pt from line.p1 on the line,\n\t// it should be between 0% and 100%\n\treturn t >= 0 && t <= 1\n}\n\nexport function testLineCircle(l: Line, circle: Circle): boolean {\n\tconst v = l.p2.sub(l.p1)\n\tconst a = v.dot(v)\n\tconst centerToOrigin = l.p1.sub(circle.center)\n\tconst b = 2 * v.dot(centerToOrigin)\n\tconst c = centerToOrigin.dot(centerToOrigin) - circle.radius * circle.radius\n\t// Calculate the discriminant of ax^2 + bx + c\n\tconst dis = b * b - 4 * a * c\n\n\t// No root\n\tif ((a <= Number.EPSILON) || (dis < 0)) {\n\t\treturn false\n\t}\n\t// One possible root\n\telse if (dis == 0) {\n\t\tconst t = -b / (2 * a)\n\t\tif (t >= 0 && t <= 1) {\n\t\t\treturn true\n\t\t}\n\t}\n\t// Two possible roots\n\telse {\n\t\tconst t1 = (-b + Math.sqrt(dis)) / (2 * a)\n\t\tconst t2 = (-b - Math.sqrt(dis)) / (2 * a)\n\t\tif ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1)) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\t// Check if line is completely within the circle\n\t// We only need to check one point, since the line didn't cross the circle\n\treturn testCirclePoint(circle, l.p1)\n}\n\nexport function testLinePolygon(l: Line, p: Polygon): boolean {\n\n\t// test if line is inside\n\tif (testPolygonPoint(p, l.p1) || testPolygonPoint(p, l.p2)) {\n\t\treturn true\n\t}\n\n\t// test each line\n\tfor (let i = 0; i < p.pts.length; i++) {\n\t\tconst p1 = p.pts[i]\n\t\tconst p2 = p.pts[(i + 1) % p.pts.length]\n\t\tif (testLineLine(l, new Line(p1, p2))) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n\n}\n\nexport function testCirclePoint(c: Circle, p: Point): boolean {\n\treturn c.center.sdist(p) < c.radius * c.radius\n}\n\nexport function testCircleCircle(c1: Circle, c2: Circle): boolean {\n\treturn c1.center.sdist(c2.center) < (c1.radius + c2.radius) * (c1.radius + c2.radius)\n}\n\nexport function testCirclePolygon(c: Circle, p: Polygon): boolean {\n\t// For each edge check for intersection\n\tlet prev = p.pts[p.pts.length - 1]\n\tfor (const cur of p.pts) {\n\t\tif (testLineCircle(new Line(prev, cur), c)) {\n\t\t\treturn true\n\t\t}\n\t\tprev = cur\n\t}\n\n\t// Check if the polygon is completely within the circle\n\t// We only need to check one point, since the polygon didn't cross the circle\n\tif (testCirclePoint(c, p.pts[0])) {\n\t\treturn true\n\t}\n\n\t// Check if the circle is completely within the polygon\n\treturn testPolygonPoint(p, c.center)\n}\n\nexport function testPolygonPolygon(p1: Polygon, p2: Polygon): boolean {\n\tfor (let i = 0; i < p1.pts.length; i++) {\n\t\tif (testLinePolygon(new Line(p1.pts[i], p1.pts[(i + 1) % p1.pts.length]), p2)) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html\nexport function testPolygonPoint(poly: Polygon, pt: Point): boolean {\n\n\tlet c = false\n\tconst p = poly.pts\n\n\tfor (let i = 0, j = p.length - 1; i < p.length; j = i++) {\n\t\tif (\n\t\t\t((p[i].y > pt.y) != (p[j].y > pt.y))\n\t\t\t&& (pt.x < (p[j].x - p[i].x) * (pt.y - p[i].y) / (p[j].y - p[i].y) + p[i].x)\n\t\t) {\n\t\t\tc = !c\n\t\t}\n\t}\n\n\treturn c\n\n}\n\nexport function testPointPoint(p1: Point, p2: Point): boolean {\n\treturn p1.x === p2.x && p1.y === p2.y\n}\n\nexport class Line {\n\tp1: Vec2\n\tp2: Vec2\n\tconstructor(p1: Vec2, p2: Vec2) {\n\t\tthis.p1 = p1.clone()\n\t\tthis.p2 = p2.clone()\n\t}\n\ttransform(m: Mat4): Line {\n\t\treturn new Line(m.multVec2(this.p1), m.multVec2(this.p2))\n\t}\n\tbbox(): Rect {\n\t\treturn Rect.fromPoints(this.p1, this.p2)\n\t}\n\tarea(): number {\n\t\treturn this.p1.dist(this.p2)\n\t}\n\tclone(): Line {\n\t\treturn new Line(this.p1, this.p2)\n\t}\n}\n\n// TODO: use x: number y: number (x, y, width, height)\nexport class Rect {\n\tpos: Vec2\n\twidth: number\n\theight: number\n\tconstructor(pos: Vec2, width: number, height: number) {\n\t\tthis.pos = pos.clone()\n\t\tthis.width = width\n\t\tthis.height = height\n\t}\n\tstatic fromPoints(p1: Vec2, p2: Vec2): Rect {\n\t\treturn new Rect(p1.clone(), p2.x - p1.x, p2.y - p1.y)\n\t}\n\tcenter(): Vec2 {\n\t\treturn new Vec2(this.pos.x + this.width / 2, this.pos.y + this.height / 2)\n\t}\n\tpoints(): [Vec2, Vec2, Vec2, Vec2] {\n\t\treturn [\n\t\t\tthis.pos,\n\t\t\tthis.pos.add(this.width, 0),\n\t\t\tthis.pos.add(this.width, this.height),\n\t\t\tthis.pos.add(0, this.height),\n\t\t]\n\t}\n\ttransform(m: Mat4): Polygon {\n\t\treturn new Polygon(this.points().map((pt) => m.multVec2(pt)))\n\t}\n\tbbox(): Rect {\n\t\treturn this.clone()\n\t}\n\tarea(): number {\n\t\treturn this.width * this.height\n\t}\n\tclone(): Rect {\n\t\treturn new Rect(this.pos.clone(), this.width, this.height)\n\t}\n\tdistToPoint(p: Vec2): number {\n\t\treturn Math.sqrt(this.sdistToPoint(p))\n\t}\n\tsdistToPoint(p: Vec2): number {\n\t\tconst min = this.pos\n\t\tconst max = this.pos.add(this.width, this.height)\n\t\tconst dx = Math.max(min.x - p.x, 0, p.x - max.x)\n\t\tconst dy = Math.max(min.y - p.y, 0, p.y - max.y)\n\t\treturn dx * dx + dy * dy\n\t}\n}\n\nexport class Circle {\n\tcenter: Vec2\n\tradius: number\n\tconstructor(center: Vec2, radius: number) {\n\t\tthis.center = center.clone()\n\t\tthis.radius = radius\n\t}\n\ttransform(tr: Mat4): Ellipse {\n\t\treturn new Ellipse(this.center, this.radius, this.radius).transform(tr)\n\t}\n\tbbox(): Rect {\n\t\treturn Rect.fromPoints(\n\t\t\tthis.center.sub(vec2(this.radius)),\n\t\t\tthis.center.add(vec2(this.radius)),\n\t\t)\n\t}\n\tarea(): number {\n\t\treturn this.radius * this.radius * Math.PI\n\t}\n\tclone(): Circle {\n\t\treturn new Circle(this.center, this.radius)\n\t}\n}\n\nexport class Ellipse {\n\tcenter: Vec2\n\tradiusX: number\n\tradiusY: number\n\tconstructor(center: Vec2, rx: number, ry: number) {\n\t\tthis.center = center.clone()\n\t\tthis.radiusX = rx\n\t\tthis.radiusY = ry\n\t}\n\ttransform(tr: Mat4): Ellipse {\n\t\treturn new Ellipse(\n\t\t\ttr.multVec2(this.center),\n\t\t\ttr.m[0] * this.radiusX,\n\t\t\ttr.m[5] * this.radiusY,\n\t\t)\n\t}\n\tbbox(): Rect {\n\t\treturn Rect.fromPoints(\n\t\t\tthis.center.sub(vec2(this.radiusX, this.radiusY)),\n\t\t\tthis.center.add(vec2(this.radiusX, this.radiusY)),\n\t\t)\n\t}\n\tarea(): number {\n\t\treturn this.radiusX * this.radiusY * Math.PI\n\t}\n\tclone(): Ellipse {\n\t\treturn new Ellipse(this.center, this.radiusX, this.radiusY)\n\t}\n}\n\nexport class Polygon {\n\tpts: Vec2[]\n\tconstructor(pts: Vec2[]) {\n\t\tif (pts.length < 3) {\n\t\t\tthrow new Error(\"Polygons should have at least 3 vertices\")\n\t\t}\n\t\tthis.pts = pts\n\t}\n\ttransform(m: Mat4): Polygon {\n\t\treturn new Polygon(this.pts.map((pt) => m.multVec2(pt)))\n\t}\n\tbbox(): Rect {\n\t\tconst p1 = vec2(Number.MAX_VALUE)\n\t\tconst p2 = vec2(-Number.MAX_VALUE)\n\t\tfor (const pt of this.pts) {\n\t\t\tp1.x = Math.min(p1.x, pt.x)\n\t\t\tp2.x = Math.max(p2.x, pt.x)\n\t\t\tp1.y = Math.min(p1.y, pt.y)\n\t\t\tp2.y = Math.max(p2.y, pt.y)\n\t\t}\n\t\treturn Rect.fromPoints(p1, p2)\n\t}\n\tarea(): number {\n\t\tlet total = 0\n\t\tconst l = this.pts.length\n\t\tfor (let i = 0; i < l; i++) {\n\t\t\tconst p1 = this.pts[i]\n\t\t\tconst p2 = this.pts[(i + 1) % l]\n\t\t\ttotal += (p1.x * p2.y * 0.5)\n\t\t\ttotal -= (p2.x * p1.y * 0.5)\n\t\t}\n\t\treturn Math.abs(total)\n\t}\n\tclone(): Polygon {\n\t\treturn new Polygon(this.pts.map((pt) => pt.clone()))\n\t}\n}\n\nexport function sat(p1: Polygon, p2: Polygon): Vec2 | null {\n\tlet overlap = Number.MAX_VALUE\n\tlet displacement = vec2(0)\n\tfor (const poly of [p1, p2]) {\n\t\tfor (let i = 0; i < poly.pts.length; i++) {\n\t\t\tconst a = poly.pts[i]\n\t\t\tconst b = poly.pts[(i + 1) % poly.pts.length]\n\t\t\tconst axisProj = b.sub(a).normal().unit()\n\t\t\tlet min1 = Number.MAX_VALUE\n\t\t\tlet max1 = -Number.MAX_VALUE\n\t\t\tfor (let j = 0; j < p1.pts.length; j++) {\n\t\t\t\tconst q = p1.pts[j].dot(axisProj)\n\t\t\t\tmin1 = Math.min(min1, q)\n\t\t\t\tmax1 = Math.max(max1, q)\n\t\t\t}\n\t\t\tlet min2 = Number.MAX_VALUE\n\t\t\tlet max2 = -Number.MAX_VALUE\n\t\t\tfor (let j = 0; j < p2.pts.length; j++) {\n\t\t\t\tconst q = p2.pts[j].dot(axisProj)\n\t\t\t\tmin2 = Math.min(min2, q)\n\t\t\t\tmax2 = Math.max(max2, q)\n\t\t\t}\n\t\t\tconst o = Math.min(max1, max2) - Math.max(min1, min2)\n\t\t\tif (o < 0) {\n\t\t\t\treturn null\n\t\t\t}\n\t\t\tif (o < Math.abs(overlap)) {\n\t\t\t\tconst o1 = max2 - min1\n\t\t\t\tconst o2 = min2 - max1\n\t\t\t\toverlap = Math.abs(o1) < Math.abs(o2) ? o1 : o2\n\t\t\t\tdisplacement = axisProj.scale(overlap)\n\t\t\t}\n\t\t}\n\t}\n\treturn displacement\n}\n", "export class IDList<T> extends Map<number, T> {\n\tprivate lastID: number\n\tconstructor(...args) {\n\t\tsuper(...args)\n\t\tthis.lastID = 0\n\t}\n\tpush(v: T): number {\n\t\tconst id = this.lastID\n\t\tthis.set(id, v)\n\t\tthis.lastID++\n\t\treturn id\n\t}\n\tpushd(v: T): () => void {\n\t\tconst id = this.push(v)\n\t\treturn () => this.delete(id)\n\t}\n}\n\nexport class EventController {\n\tpaused: boolean = false\n\treadonly cancel: () => void\n\tconstructor(cancel: () => void) {\n\t\tthis.cancel = cancel\n\t}\n\tstatic join(events: EventController[]): EventController {\n\t\tconst ev = new EventController(() => events.forEach((e) => e.cancel()))\n\t\tObject.defineProperty(ev, \"paused\", {\n\t\t\tget: () => events[0].paused,\n\t\t\tset: (p: boolean) => events.forEach((e) => e.paused = p),\n\t\t})\n\t\tev.paused = false\n\t\treturn ev\n\t}\n}\n\nexport class Event<Args extends any[] = any[]> {\n\tprivate handlers: IDList<(...args: Args) => void> = new IDList()\n\tadd(action: (...args: Args) => void): EventController {\n\t\tconst cancel = this.handlers.pushd((...args: Args) => {\n\t\t\tif (ev.paused) return\n\t\t\taction(...args)\n\t\t})\n\t\tconst ev = new EventController(cancel)\n\t\treturn ev\n\t}\n\taddOnce(action: (...args) => void): EventController {\n\t\tconst ev = this.add((...args) => {\n\t\t\tev.cancel()\n\t\t\taction(...args)\n\t\t})\n\t\treturn ev\n\t}\n\tnext(): Promise<Args> {\n\t\treturn new Promise((res) => this.addOnce(res))\n\t}\n\ttrigger(...args: Args) {\n\t\tthis.handlers.forEach((action) => action(...args))\n\t}\n\tnumListeners(): number {\n\t\treturn this.handlers.size\n\t}\n\tclear() {\n\t\tthis.handlers.clear()\n\t}\n}\n\n// TODO: only accept one argument?\nexport class EventHandler<EventMap extends Record<string, any[]>> {\n\tprivate handlers: Partial<{\n\t\t[Name in keyof EventMap]: Event<EventMap[Name]>\n\t}> = {}\n\ton<Name extends keyof EventMap>(\n\t\tname: Name,\n\t\taction: (...args: EventMap[Name]) => void,\n\t): EventController {\n\t\tif (!this.handlers[name]) {\n\t\t\tthis.handlers[name] = new Event<EventMap[Name]>()\n\t\t}\n\t\treturn this.handlers[name].add(action)\n\t}\n\tonOnce<Name extends keyof EventMap>(\n\t\tname: Name,\n\t\taction: (...args: EventMap[Name]) => void,\n\t): EventController {\n\t\tconst ev = this.on(name, (...args) => {\n\t\t\tev.cancel()\n\t\t\taction(...args)\n\t\t})\n\t\treturn ev\n\t}\n\tnext<Name extends keyof EventMap>(name: Name): Promise<unknown> {\n\t\treturn new Promise((res) => {\n\t\t\t// TODO: can only pass 1 val to resolve()\n\t\t\tthis.onOnce(name, (...args: EventMap[Name]) => res(args[0]))\n\t\t})\n\t}\n\ttrigger<Name extends keyof EventMap>(name: Name, ...args: EventMap[Name]) {\n\t\tif (this.handlers[name]) {\n\t\t\tthis.handlers[name].trigger(...args)\n\t\t}\n\t}\n\tremove<Name extends keyof EventMap>(name: Name) {\n\t\tdelete this.handlers[name]\n\t}\n\tclear() {\n\t\tthis.handlers = {}\n\t}\n\tnumListeners<Name extends keyof EventMap>(name: Name): number {\n\t\treturn this.handlers[name]?.numListeners() ?? 0\n\t}\n}\n\nexport function deepEq(o1: any, o2: any): boolean {\n\tconst t1 = typeof o1\n\tconst t2 = typeof o2\n\tif (t1 !== t2) {\n\t\treturn false\n\t}\n\tif (t1 === \"object\" && t2 === \"object\" && o1 !== null && o2 !== null) {\n\t\tconst k1 = Object.keys(o1)\n\t\tconst k2 = Object.keys(o2)\n\t\tif (k1.length !== k2.length) {\n\t\t\treturn false\n\t\t}\n\t\tfor (const k of k1) {\n\t\t\tconst v1 = o1[k]\n\t\t\tconst v2 = o2[k]\n\t\t\tif (!(typeof v1 === \"function\" && typeof v2 === \"function\")) {\n\t\t\t\tif (!deepEq(v1, v2)) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\treturn o1 === o2\n}\n\nexport function base64ToArrayBuffer(base64: string): ArrayBuffer {\n\tconst binstr = window.atob(base64)\n\tconst len = binstr.length\n\tconst bytes = new Uint8Array(len)\n\tfor (let i = 0; i < len; i++) {\n\t\tbytes[i] = binstr.charCodeAt(i)\n\t}\n\treturn bytes.buffer\n}\n\nexport function dataURLToArrayBuffer(url: string): ArrayBuffer {\n\treturn base64ToArrayBuffer(url.split(\",\")[1])\n}\n\nexport function download(filename: string, url: string) {\n\tconst a = document.createElement(\"a\")\n\ta.href = url\n\ta.download = filename\n\ta.click()\n}\n\nexport function downloadText(filename: string, text: string) {\n\tdownload(filename, \"data:text/plain;charset=utf-8,\" + text)\n}\n\nexport function downloadJSON(filename: string, data: any) {\n\tdownloadText(filename, JSON.stringify(data))\n}\n\nexport function downloadBlob(filename: string, blob: Blob) {\n\tconst url = URL.createObjectURL(blob)\n\tdownload(filename, url)\n\tURL.revokeObjectURL(url)\n}\n\nexport const isDataURL = (str: string) => str.match(/^data:\\w+\\/\\w+;base64,.+/)\nexport const getExt = (p: string) => p.split(\".\").pop()\n\nexport const uid = (() => {\n\tlet id = 0\n\treturn () => id++\n})()\n\nconst warned = new Set()\n\nexport function warn(msg: string) {\n\tif (!warned.has(msg)) {\n\t\twarned.add(msg)\n\t\tconsole.warn(msg)\n\t}\n}\n\nexport function deprecateMsg(oldName: string, newName: string) {\n\twarn(`${oldName} is deprecated. Use ${newName} instead.`)\n}\n\nexport function deprecate(oldName: string, newName: string, newFunc: (...args) => any) {\n\treturn (...args) => {\n\t\tdeprecateMsg(oldName, newName)\n\t\treturn newFunc(...args)\n\t}\n}\n\nexport function benchmark(task: () => void, times: number = 1) {\n\tconst t1 = performance.now()\n\tfor (let i = 0; i < times; i++) {\n\t\ttask()\n\t}\n\tconst t2 = performance.now()\n\treturn t2 - t1\n}\n\nexport function comparePerf(t1: () => void, t2: () => void, times: number = 1) {\n\treturn benchmark(t2, times) / benchmark(t1, times)\n}\n\nexport class BinaryHeap<T> {\n\t_items: T[]\n\t_compareFn: (a: T, b: T) => boolean\n\n\t/**\n\t * Creates a binary heap with the given compare function\n\t * Not passing a compare function will give a min heap\n\t */\n\tconstructor(compareFn = (a: T, b: T) => a < b) {\n\t\tthis._compareFn = compareFn\n\t\tthis._items = []\n\t}\n\n\t/**\n\t * Insert an item into the binary heap\n\t */\n\tinsert(item: T) {\n\t\tthis._items.push(item)\n\t\tthis.moveUp(this._items.length - 1)\n\t}\n\n\t/**\n\t * Remove the smallest item from the binary heap in case of a min heap\n\t * or the greatest item from the binary heap in case of a max heap\n\t */\n\tremove() {\n\t\tif (this._items.length === 0)\n\t\t\treturn null\n\t\tconst item = this._items[0]\n\t\tconst lastItem = this._items.pop()\n\t\tif (this._items.length !== 0) {\n\t\t\tthis._items[0] = lastItem as T\n\t\t\tthis.moveDown(0)\n\t\t}\n\t\treturn item\n\t}\n\n\t/**\n\t * Remove all items\n\t */\n\tclear() {\n\t\tthis._items.splice(0, this._items.length)\n\t}\n\n\tmoveUp(pos: number) {\n\t\twhile (pos > 0) {\n\t\t\tconst parent = Math.floor((pos - 1) / 2)\n\t\t\tif (!this._compareFn(this._items[pos], this._items[parent]))\n\t\t\t\tif (this._items[pos] >= this._items[parent])\n\t\t\t\t\tbreak\n\t\t\tthis.swap(pos, parent)\n\t\t\tpos = parent\n\t\t}\n\t}\n\n\tmoveDown(pos: number) {\n\t\twhile (pos < Math.floor(this._items.length / 2)) {\n\t\t\tlet child = 2 * pos + 1\n\t\t\tif (child < this._items.length - 1 && !this._compareFn(this._items[child], this._items[child + 1]))\n\t\t\t\t++child\n\t\t\tif (this._compareFn(this._items[pos], this._items[child]))\n\t\t\t\tbreak\n\t\t\tthis.swap(pos, child)\n\t\t\tpos = child\n\t\t}\n\t}\n\n\tswap(index1: number, index2: number) {\n\t\t[this._items[index1], this._items[index2]] = [this._items[index2], this._items[index1]]\n\t}\n\n\t/**\n\t * Returns the amount of items\n\t */\n\tget length() {\n\t\treturn this._items.length\n\t}\n}\n", "{\n\t\"Joy-Con L+R (STANDARD GAMEPAD Vendor: 057e Product: 200e)\": {\n\t\t\"buttons\": {\n\t\t\t\"0\": \"south\",\n\t\t\t\"1\": \"east\",\n\t\t\t\"2\": \"west\",\n\t\t\t\"3\": \"north\",\n\t\t\t\"4\": \"lshoulder\",\n\t\t\t\"5\": \"rshoulder\",\n\t\t\t\"6\": \"ltrigger\",\n\t\t\t\"7\": \"rtrigger\",\n\t\t\t\"8\": \"select\",\n\t\t\t\"9\": \"start\",\n\t\t\t\"10\": \"lstick\",\n\t\t\t\"11\": \"rstick\",\n\t\t\t\"12\": \"dpad-up\",\n\t\t\t\"13\": \"dpad-down\",\n\t\t\t\"14\": \"dpad-left\",\n\t\t\t\"15\": \"dpad-right\",\n\t\t\t\"16\": \"home\",\n\t\t\t\"17\": \"capture\"\n\t\t},\n\t\t\"sticks\": {\n\t\t\t\"left\": { \"x\": 0, \"y\": 1 },\n\t\t\t\"right\": { \"x\": 2, \"y\": 3 }\n\t\t}\n\t},\n\t\"Joy-Con (L) (STANDARD GAMEPAD Vendor: 057e Product: 2006)\": {\n\t\t\"buttons\": {\n\t\t\t\"0\": \"south\",\n\t\t\t\"1\": \"east\",\n\t\t\t\"2\": \"west\",\n\t\t\t\"3\": \"north\",\n\t\t\t\"4\": \"lshoulder\",\n\t\t\t\"5\": \"rshoulder\",\n\t\t\t\"9\": \"select\",\n\t\t\t\"10\": \"lstick\",\n\t\t\t\"16\": \"start\"\n\t\t},\n\t\t\"sticks\": {\n\t\t\t\"left\": { \"x\": 0, \"y\": 1 }\n\t\t}\n\t},\n\t\"Joy-Con (R) (STANDARD GAMEPAD Vendor: 057e Product: 2007)\": {\n\t\t\"buttons\": {\n\t\t\t\"0\": \"south\",\n\t\t\t\"1\": \"east\",\n\t\t\t\"2\": \"west\",\n\t\t\t\"3\": \"north\",\n\t\t\t\"4\": \"lshoulder\",\n\t\t\t\"5\": \"rshoulder\",\n\t\t\t\"9\": \"start\",\n\t\t\t\"10\": \"lstick\",\n\t\t\t\"16\": \"select\"\n\t\t},\n\t\t\"sticks\": {\n\t\t\t\"left\": { \"x\": 0, \"y\": 1 }\n\t\t}\n\t},\n\t\"Pro Controller (STANDARD GAMEPAD Vendor: 057e Product: 2009)\": {\n\t\t\"buttons\": {\n\t\t\t\"0\": \"south\",\n\t\t\t\"1\": \"east\",\n\t\t\t\"2\": \"west\",\n\t\t\t\"3\": \"north\",\n\t\t\t\"4\": \"lshoulder\",\n\t\t\t\"5\": \"rshoulder\",\n\t\t\t\"6\": \"ltrigger\",\n\t\t\t\"7\": \"rtrigger\",\n\t\t\t\"8\": \"select\",\n\t\t\t\"9\": \"start\",\n\t\t\t\"10\": \"lstick\",\n\t\t\t\"11\": \"rstick\",\n\t\t\t\"12\": \"dpad-up\",\n\t\t\t\"13\": \"dpad-down\",\n\t\t\t\"14\": \"dpad-left\",\n\t\t\t\"15\": \"dpad-right\",\n\t\t\t\"16\": \"home\",\n\t\t\t\"17\": \"capture\"\n\t\t},\n\t\t\"sticks\": {\n\t\t\t\"left\": { \"x\": 0, \"y\": 1 },\n\t\t\t\"right\": { \"x\": 2, \"y\": 3 }\n\t\t}\n\t},\n\t\"default\": {\n\t\t\"buttons\": {\n\t\t\t\"0\": \"south\",\n\t\t\t\"1\": \"east\",\n\t\t\t\"2\": \"west\",\n\t\t\t\"3\": \"north\",\n\t\t\t\"4\": \"lshoulder\",\n\t\t\t\"5\": \"rshoulder\",\n\t\t\t\"6\": \"ltrigger\",\n\t\t\t\"7\": \"rtrigger\",\n\t\t\t\"8\": \"select\",\n\t\t\t\"9\": \"start\",\n\t\t\t\"10\": \"lstick\",\n\t\t\t\"11\": \"rstick\",\n\t\t\t\"12\": \"dpad-up\",\n\t\t\t\"13\": \"dpad-down\",\n\t\t\t\"14\": \"dpad-left\",\n\t\t\t\"15\": \"dpad-right\",\n\t\t\t\"16\": \"home\"\n\t\t},\n\t\t\"sticks\": {\n\t\t\t\"left\": { \"x\": 0, \"y\": 1 },\n\t\t\t\"right\": { \"x\": 2, \"y\": 3 }\n\t\t}\n\t}\n}\n", "// everything related to canvas, game loop and input\n\nimport type {\n\tKaboomCtx,\n\tCursor,\n\tKey,\n\tMouseButton,\n\tGamepadButton,\n\tGamepadStick,\n\tGamepadDef,\n\tKGamePad,\n} from \"./types\"\n\nimport {\n\tVec2,\n\tmap,\n} from \"./math\"\n\nimport {\n\tEventHandler,\n\tEventController,\n} from \"./utils\"\n\nimport GAMEPAD_MAP from \"./gamepad.json\"\n\nexport class ButtonState<T = string> {\n\tpressed: Set<T> = new Set([])\n\tpressedRepeat: Set<T> = new Set([])\n\treleased: Set<T> = new Set([])\n\tdown: Set<T> = new Set([])\n\tupdate() {\n\t\tthis.pressed.clear()\n\t\tthis.released.clear()\n\t\tthis.pressedRepeat.clear()\n\t}\n\tpress(btn: T) {\n\t\tthis.pressed.add(btn)\n\t\tthis.pressedRepeat.add(btn)\n\t\tthis.down.add(btn)\n\t}\n\tpressRepeat(btn: T) {\n\t\tthis.pressedRepeat.add(btn)\n\t}\n\trelease(btn: T) {\n\t\tthis.down.delete(btn)\n\t\tthis.pressed.delete(btn)\n\t\tthis.released.add(btn)\n\t}\n}\n\nclass GamepadState {\n\tbuttonState: ButtonState<GamepadButton> = new ButtonState()\n\tstickState: Map<GamepadStick, Vec2> = new Map()\n}\n\nclass FPSCounter {\n\tprivate dts: number[] = []\n\tprivate timer: number = 0\n\tfps: number = 0\n\ttick(dt: number) {\n\t\tthis.dts.push(dt)\n\t\tthis.timer += dt\n\t\tif (this.timer >= 1) {\n\t\t\tthis.timer = 0\n\t\t\tthis.fps = Math.round(1 / (this.dts.reduce((a, b) => a + b) / this.dts.length))\n\t\t\tthis.dts = []\n\t\t}\n\t}\n}\n\nexport default (opt: {\n\tcanvas: HTMLCanvasElement,\n\ttouchToMouse?: boolean,\n\tgamepads?: Record<string, GamepadDef>,\n\tpixelDensity?: number,\n\tmaxFPS?: number,\n}) => {\n\n\tif (!opt.canvas) {\n\t\tthrow new Error(\"Please provide a canvas\")\n\t}\n\n\tconst state = {\n\t\tcanvas: opt.canvas,\n\t\tloopID: null as null | number,\n\t\tstopped: false,\n\t\tdt: 0,\n\t\ttime: 0,\n\t\trealTime: 0,\n\t\tfpsCounter: new FPSCounter(),\n\t\ttimeScale: 1,\n\t\tskipTime: false,\n\t\tnumFrames: 0,\n\t\tmousePos: new Vec2(0),\n\t\tmouseDeltaPos: new Vec2(0),\n\t\tkeyState: new ButtonState<Key>(),\n\t\tmouseState: new ButtonState<MouseButton>(),\n\t\tmergedGamepadState: new GamepadState(),\n\t\tgamepadStates: new Map<number, GamepadState>(),\n\t\tgamepads: [] as KGamePad[],\n\t\tcharInputted: [],\n\t\tisMouseMoved: false,\n\t\tlastWidth: opt.canvas.offsetWidth,\n\t\tlastHeight: opt.canvas.offsetHeight,\n\t\tevents: new EventHandler<{\n\t\t\tmouseMove: [],\n\t\t\tmouseDown: [MouseButton],\n\t\t\tmousePress: [MouseButton],\n\t\t\tmouseRelease: [MouseButton],\n\t\t\tcharInput: [string],\n\t\t\tkeyPress: [Key],\n\t\t\tkeyDown: [Key],\n\t\t\tkeyPressRepeat: [Key],\n\t\t\tkeyRelease: [Key],\n\t\t\ttouchStart: [Vec2, Touch],\n\t\t\ttouchMove: [Vec2, Touch],\n\t\t\ttouchEnd: [Vec2, Touch],\n\t\t\tgamepadButtonDown: [string],\n\t\t\tgamepadButtonPress: [string],\n\t\t\tgamepadButtonRelease: [string],\n\t\t\tgamepadStick: [string, Vec2],\n\t\t\tgamepadConnect: [KGamePad],\n\t\t\tgamepadDisconnect: [KGamePad],\n\t\t\tscroll: [Vec2],\n\t\t\thide: [],\n\t\t\tshow: [],\n\t\t\tresize: [],\n\t\t\tinput: [],\n\t\t}>(),\n\t}\n\n\tfunction canvas() {\n\t\treturn state.canvas\n\t}\n\n\tfunction dt() {\n\t\treturn state.dt * state.timeScale\n\t}\n\n\tfunction time() {\n\t\treturn state.time\n\t}\n\n\tfunction fps() {\n\t\treturn state.fpsCounter.fps\n\t}\n\n\tfunction numFrames() {\n\t\treturn state.numFrames\n\t}\n\n\tfunction screenshot(): string {\n\t\treturn state.canvas.toDataURL()\n\t}\n\n\tfunction setCursor(c: Cursor): void {\n\t\tstate.canvas.style.cursor = c\n\t}\n\n\tfunction getCursor(): Cursor {\n\t\treturn state.canvas.style.cursor\n\t}\n\n\tfunction setCursorLocked(b: boolean): void {\n\t\tif (b) {\n\t\t\ttry {\n\t\t\t\tconst res = state.canvas.requestPointerLock() as unknown as Promise<void>\n\t\t\t\tif (res.catch) {\n\t\t\t\t\tres.catch((e) => console.error(e))\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(e)\n\t\t\t}\n\t\t} else {\n\t\t\tdocument.exitPointerLock()\n\t\t}\n\t}\n\n\tfunction isCursorLocked(): boolean {\n\t\treturn !!document.pointerLockElement\n\t}\n\n\t// wrappers around full screen functions to work across browsers\n\tfunction enterFullscreen(el: HTMLElement) {\n\t\tif (el.requestFullscreen) el.requestFullscreen()\n\t\t// @ts-ignore\n\t\telse if (el.webkitRequestFullscreen) el.webkitRequestFullscreen()\n\t}\n\n\tfunction exitFullscreen() {\n\t\tif (document.exitFullscreen) document.exitFullscreen()\n\t\t// @ts-ignore\n\t\telse if (document.webkitExitFullScreen) document.webkitExitFullScreen()\n\t}\n\n\tfunction getFullscreenElement(): Element | void {\n\t\treturn document.fullscreenElement\n\t\t\t// @ts-ignore\n\t\t\t|| document.webkitFullscreenElement\n\t}\n\n\tfunction setFullscreen(f: boolean = true) {\n\t\tif (f) {\n\t\t\tenterFullscreen(state.canvas)\n\t\t} else {\n\t\t\texitFullscreen()\n\t\t}\n\t}\n\n\tfunction isFullscreen(): boolean {\n\t\treturn Boolean(getFullscreenElement())\n\t}\n\n\tfunction quit() {\n\t\tstate.stopped = true\n\t\tfor (const name in canvasEvents) {\n\t\t\tstate.canvas.removeEventListener(name, canvasEvents[name])\n\t\t}\n\t\tfor (const name in docEvents) {\n\t\t\tdocument.removeEventListener(name, docEvents[name])\n\t\t}\n\t\tfor (const name in winEvents) {\n\t\t\twindow.removeEventListener(name, winEvents[name])\n\t\t}\n\t\tresizeObserver.disconnect()\n\t}\n\n\tfunction run(action: () => void) {\n\n\t\tif (state.loopID !== null) {\n\t\t\tcancelAnimationFrame(state.loopID)\n\t\t}\n\n\t\tlet accumulatedDt = 0\n\n\t\tconst frame = (t: number) => {\n\n\t\t\tif (state.stopped) return\n\n\t\t\t// TODO: allow background actions?\n\t\t\tif (document.visibilityState !== \"visible\") {\n\t\t\t\tstate.loopID = requestAnimationFrame(frame)\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tconst loopTime = t / 1000\n\t\t\tconst realDt = loopTime - state.realTime\n\t\t\tconst desiredDt = opt.maxFPS ? 1 / opt.maxFPS : 0\n\n\t\t\tstate.realTime = loopTime\n\t\t\taccumulatedDt += realDt\n\n\t\t\tif (accumulatedDt > desiredDt) {\n\t\t\t\tif (!state.skipTime) {\n\t\t\t\t\tstate.dt = accumulatedDt\n\t\t\t\t\tstate.time += dt()\n\t\t\t\t\tstate.fpsCounter.tick(state.dt)\n\t\t\t\t}\n\t\t\t\taccumulatedDt = 0\n\t\t\t\tstate.skipTime = false\n\t\t\t\tstate.numFrames++\n\t\t\t\tprocessInput()\n\t\t\t\taction()\n\t\t\t\tresetInput()\n\t\t\t}\n\n\t\t\tstate.loopID = requestAnimationFrame(frame)\n\n\t\t}\n\n\t\tframe(0)\n\n\t}\n\n\tfunction isTouchscreen() {\n\t\treturn (\"ontouchstart\" in window) || navigator.maxTouchPoints > 0\n\t}\n\n\tfunction mousePos(): Vec2 {\n\t\treturn state.mousePos.clone()\n\t}\n\n\tfunction mouseDeltaPos(): Vec2 {\n\t\treturn state.mouseDeltaPos.clone()\n\t}\n\n\tfunction isMousePressed(m: MouseButton = \"left\"): boolean {\n\t\treturn state.mouseState.pressed.has(m)\n\t}\n\n\tfunction isMouseDown(m: MouseButton = \"left\"): boolean {\n\t\treturn state.mouseState.down.has(m)\n\t}\n\n\tfunction isMouseReleased(m: MouseButton = \"left\"): boolean {\n\t\treturn state.mouseState.released.has(m)\n\t}\n\n\tfunction isMouseMoved(): boolean {\n\t\treturn state.isMouseMoved\n\t}\n\n\tfunction isKeyPressed(k?: Key): boolean {\n\t\treturn k === undefined\n\t\t\t? state.keyState.pressed.size > 0\n\t\t\t: state.keyState.pressed.has(k)\n\t}\n\n\tfunction isKeyPressedRepeat(k?: Key): boolean {\n\t\treturn k === undefined\n\t\t\t? state.keyState.pressedRepeat.size > 0\n\t\t\t: state.keyState.pressedRepeat.has(k)\n\t}\n\n\tfunction isKeyDown(k?: Key): boolean {\n\t\treturn k === undefined\n\t\t\t? state.keyState.down.size > 0\n\t\t\t: state.keyState.down.has(k)\n\t}\n\n\tfunction isKeyReleased(k?: Key): boolean {\n\t\treturn k === undefined\n\t\t\t? state.keyState.released.size > 0\n\t\t\t: state.keyState.released.has(k)\n\t}\n\n\tfunction isGamepadButtonPressed(btn?: GamepadButton): boolean {\n\t\treturn btn === undefined\n\t\t\t? state.mergedGamepadState.buttonState.pressed.size > 0\n\t\t\t: state.mergedGamepadState.buttonState.pressed.has(btn)\n\t}\n\n\tfunction isGamepadButtonDown(btn?: GamepadButton): boolean {\n\t\treturn btn === undefined\n\t\t\t? state.mergedGamepadState.buttonState.down.size > 0\n\t\t\t: state.mergedGamepadState.buttonState.down.has(btn)\n\t}\n\n\tfunction isGamepadButtonReleased(btn?: GamepadButton): boolean {\n\t\treturn btn === undefined\n\t\t\t? state.mergedGamepadState.buttonState.released.size > 0\n\t\t\t: state.mergedGamepadState.buttonState.released.has(btn)\n\t}\n\n\tfunction onResize(action: () => void): EventController {\n\t\treturn state.events.on(\"resize\", action)\n\t}\n\n\t// input callbacks\n\tconst onKeyDown = ((key, action) => {\n\t\tif (typeof key === \"function\") {\n\t\t\treturn state.events.on(\"keyDown\", key)\n\t\t} else if (typeof key === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"keyDown\", (k) => k === key && action(key))\n\t\t}\n\t}) as KaboomCtx[\"onKeyDown\"]\n\n\tconst onKeyPress = ((key, action) => {\n\t\tif (typeof key === \"function\") {\n\t\t\treturn state.events.on(\"keyPress\", key)\n\t\t} else if (typeof key === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"keyPress\", (k) => k === key && action(key))\n\t\t}\n\t}) as KaboomCtx[\"onKeyPress\"]\n\n\tconst onKeyPressRepeat = ((key, action) => {\n\t\tif (typeof key === \"function\") {\n\t\t\treturn state.events.on(\"keyPressRepeat\", key)\n\t\t} else if (typeof key === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"keyPressRepeat\", (k) => k === key && action(key))\n\t\t}\n\t}) as KaboomCtx[\"onKeyPressRepeat\"]\n\n\tconst onKeyRelease = ((key, action) => {\n\t\tif (typeof key === \"function\") {\n\t\t\treturn state.events.on(\"keyRelease\", key)\n\t\t} else if (typeof key === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"keyRelease\", (k) => k === key && action(key))\n\t\t}\n\t}) as KaboomCtx[\"onKeyRelease\"]\n\n\tfunction onMouseDown(\n\t\tmouse: MouseButton | ((m: MouseButton) => void),\n\t\taction?: (m: MouseButton) => void,\n\t): EventController {\n\t\tif (typeof mouse === \"function\") {\n\t\t\treturn state.events.on(\"mouseDown\", (m) => mouse(m))\n\t\t} else {\n\t\t\treturn state.events.on(\"mouseDown\", (m) => m === mouse && action(m))\n\t\t}\n\t}\n\n\tfunction onMousePress(\n\t\tmouse: MouseButton | ((m: MouseButton) => void),\n\t\taction?: (m: MouseButton) => void,\n\t): EventController {\n\t\tif (typeof mouse === \"function\") {\n\t\t\treturn state.events.on(\"mousePress\", (m) => mouse(m))\n\t\t} else {\n\t\t\treturn state.events.on(\"mousePress\", (m) => m === mouse && action(m))\n\t\t}\n\t}\n\n\tfunction onMouseRelease(\n\t\tmouse: MouseButton | ((m: MouseButton) => void),\n\t\taction?: (m: MouseButton) => void,\n\t): EventController {\n\t\tif (typeof mouse === \"function\") {\n\t\t\treturn state.events.on(\"mouseRelease\", (m) => mouse(m))\n\t\t} else {\n\t\t\treturn state.events.on(\"mouseRelease\", (m) => m === mouse && action(m))\n\t\t}\n\t}\n\n\tfunction onMouseMove(f: (pos: Vec2, dpos: Vec2) => void): EventController {\n\t\treturn state.events.on(\"mouseMove\", () => f(mousePos(), mouseDeltaPos()))\n\t}\n\n\tfunction onCharInput(action: (ch: string) => void): EventController {\n\t\treturn state.events.on(\"charInput\", action)\n\t}\n\n\tfunction onTouchStart(f: (pos: Vec2, t: Touch) => void): EventController {\n\t\treturn state.events.on(\"touchStart\", f)\n\t}\n\n\tfunction onTouchMove(f: (pos: Vec2, t: Touch) => void): EventController {\n\t\treturn state.events.on(\"touchMove\", f)\n\t}\n\n\tfunction onTouchEnd(f: (pos: Vec2, t: Touch) => void): EventController {\n\t\treturn state.events.on(\"touchEnd\", f)\n\t}\n\n\tfunction onScroll(action: (delta: Vec2) => void): EventController {\n\t\treturn state.events.on(\"scroll\", action)\n\t}\n\n\tfunction onHide(action: () => void): EventController {\n\t\treturn state.events.on(\"hide\", action)\n\t}\n\n\tfunction onShow(action: () => void): EventController {\n\t\treturn state.events.on(\"show\", action)\n\t}\n\n\tfunction onGamepadButtonDown(btn: GamepadButton | ((btn: GamepadButton) => void), action?: (btn: GamepadButton) => void): EventController {\n\t\tif (typeof btn === \"function\") {\n\t\t\treturn state.events.on(\"gamepadButtonDown\", btn)\n\t\t} else if (typeof btn === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"gamepadButtonDown\", (b) => b === btn && action(btn))\n\t\t}\n\t}\n\n\tfunction onGamepadButtonPress(btn: GamepadButton | ((btn: GamepadButton) => void), action?: (btn: GamepadButton) => void): EventController {\n\t\tif (typeof btn === \"function\") {\n\t\t\treturn state.events.on(\"gamepadButtonPress\", btn)\n\t\t} else if (typeof btn === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"gamepadButtonPress\", (b) => b === btn && action(btn))\n\t\t}\n\t}\n\n\tfunction onGamepadButtonRelease(btn: GamepadButton | ((btn: GamepadButton) => void), action?: (btn: GamepadButton) => void): EventController {\n\t\tif (typeof btn === \"function\") {\n\t\t\treturn state.events.on(\"gamepadButtonRelease\", btn)\n\t\t} else if (typeof btn === \"string\" && typeof action === \"function\") {\n\t\t\treturn state.events.on(\"gamepadButtonRelease\", (b) => b === btn && action(btn))\n\t\t}\n\t}\n\n\tfunction onGamepadStick(stick: GamepadStick, action: (value: Vec2) => void): EventController {\n\t\treturn state.events.on(\"gamepadStick\", ((a: string, v: Vec2) => a === stick && action(v)))\n\t}\n\n\tfunction onGamepadConnect(action: (gamepad: KGamePad) => void) {\n\t\tstate.events.on(\"gamepadConnect\", action)\n\t}\n\n\tfunction onGamepadDisconnect(action: (gamepad: KGamePad) => void) {\n\t\tstate.events.on(\"gamepadDisconnect\", action)\n\t}\n\n\tfunction getGamepadStick(stick: GamepadStick): Vec2 {\n\t\treturn state.mergedGamepadState.stickState.get(stick) || new Vec2(0)\n\t}\n\n\tfunction charInputted(): string[] {\n\t\treturn [...state.charInputted]\n\t}\n\n\tfunction getGamepads(): KGamePad[] {\n\t\treturn [...state.gamepads]\n\t}\n\n\tfunction processInput() {\n\t\tstate.events.trigger(\"input\")\n\t\tstate.keyState.down.forEach((k) => state.events.trigger(\"keyDown\", k))\n\t\tstate.mouseState.down.forEach((k) => state.events.trigger(\"mouseDown\", k))\n\t\tprocessGamepad()\n\t}\n\n\tfunction resetInput() {\n\t\tstate.keyState.update()\n\t\tstate.mouseState.update()\n\t\tstate.mergedGamepadState.buttonState.update()\n\t\tstate.mergedGamepadState.stickState.forEach((v, k) => {\n\t\t\tstate.mergedGamepadState.stickState.set(k, new Vec2(0))\n\t\t})\n\t\tstate.charInputted = []\n\t\tstate.isMouseMoved = false\n\n\t\tstate.gamepadStates.forEach((s) => {\n\t\t\ts.buttonState.update()\n\t\t\ts.stickState.forEach((v, k) => {\n\t\t\t\ts.stickState.set(k, new Vec2(0))\n\t\t\t})\n\t\t})\n\t}\n\n\tfunction registerGamepad(browserGamepad: Gamepad) {\n\n\t\tconst gamepad = {\n\t\t\tindex: browserGamepad.index,\n\t\t\tisPressed: (btn: GamepadButton) => {\n\t\t\t\treturn state.gamepadStates.get(browserGamepad.index).buttonState.pressed.has(btn)\n\t\t\t},\n\t\t\tisDown: (btn: GamepadButton) => {\n\t\t\t\treturn state.gamepadStates.get(browserGamepad.index).buttonState.down.has(btn)\n\t\t\t},\n\t\t\tisReleased: (btn: GamepadButton) => {\n\t\t\t\treturn state.gamepadStates.get(browserGamepad.index).buttonState.released.has(btn)\n\t\t\t},\n\t\t\tgetStick: (stick: GamepadStick) => {\n\t\t\t\treturn state.gamepadStates.get(browserGamepad.index).stickState.get(stick)\n\t\t\t},\n\t\t}\n\n\t\tstate.gamepads.push(gamepad)\n\n\t\tstate.gamepadStates.set(browserGamepad.index, {\n\t\t\tbuttonState: new ButtonState(),\n\t\t\tstickState: new Map([\n\t\t\t\t[\"left\", new Vec2(0)],\n\t\t\t\t[\"right\", new Vec2(0)],\n\t\t\t]),\n\t\t})\n\n\t\treturn gamepad\n\n\t}\n\n\tfunction removeGamepad(gamepad: Gamepad) {\n\t\tstate.gamepads = state.gamepads.filter((g) => g.index !== gamepad.index)\n\t\tstate.gamepadStates.delete(gamepad.index)\n\t}\n\n\tfunction processGamepad() {\n\n\t\tfor (const browserGamepad of navigator.getGamepads()) {\n\t\t\tif (browserGamepad && !state.gamepadStates.has(browserGamepad.index)) {\n\t\t\t\tregisterGamepad(browserGamepad)\n\t\t\t}\n\t\t}\n\n\t\tfor (const gamepad of state.gamepads) {\n\n\t\t\tconst browserGamepad = navigator.getGamepads()[gamepad.index]\n\t\t\tconst customMap = opt.gamepads ?? {}\n\t\t\tconst map = customMap[browserGamepad.id] ?? GAMEPAD_MAP[browserGamepad.id] ?? GAMEPAD_MAP[\"default\"]\n\t\t\tconst gamepadState = state.gamepadStates.get(gamepad.index)\n\n\t\t\tfor (let i = 0; i < browserGamepad.buttons.length; i++) {\n\t\t\t\tif (browserGamepad.buttons[i].pressed) {\n\t\t\t\t\tif (!gamepadState.buttonState.down.has(map.buttons[i])) {\n\t\t\t\t\t\tstate.mergedGamepadState.buttonState.press(map.buttons[i])\n\t\t\t\t\t\tgamepadState.buttonState.press(map.buttons[i])\n\t\t\t\t\t\tstate.events.trigger(\"gamepadButtonPress\", map.buttons[i])\n\t\t\t\t\t}\n\t\t\t\t\tstate.events.trigger(\"gamepadButtonDown\", map.buttons[i])\n\t\t\t\t} else {\n\t\t\t\t\tif (gamepadState.buttonState.down.has(map.buttons[i])) {\n\t\t\t\t\t\tstate.mergedGamepadState.buttonState.release(map.buttons[i])\n\t\t\t\t\t\tgamepadState.buttonState.release(map.buttons[i])\n\t\t\t\t\t\tstate.events.trigger(\"gamepadButtonRelease\", map.buttons[i])\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const stickName in map.sticks) {\n\t\t\t\tconst stick = map.sticks[stickName]\n\t\t\t\tconst value = new Vec2(\n\t\t\t\t\tbrowserGamepad.axes[stick.x],\n\t\t\t\t\tbrowserGamepad.axes[stick.y],\n\t\t\t\t)\n\t\t\t\tgamepadState.stickState.set(stickName as GamepadStick, value)\n\t\t\t\tstate.mergedGamepadState.stickState.set(stickName as GamepadStick, value)\n\t\t\t\tstate.events.trigger(\"gamepadStick\", stickName, value)\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttype EventList<M> = {\n\t\t[event in keyof M]?: (event: M[event]) => void\n\t}\n\n\tconst canvasEvents: EventList<HTMLElementEventMap> = {}\n\tconst docEvents: EventList<DocumentEventMap> = {}\n\tconst winEvents: EventList<WindowEventMap> = {}\n\n\tconst pd = opt.pixelDensity || window.devicePixelRatio || 1\n\n\tcanvasEvents.mousemove = (e) => {\n\t\tconst mousePos = new Vec2(e.offsetX, e.offsetY)\n\t\tconst mouseDeltaPos = new Vec2(e.movementX, e.movementY)\n\t\tif (isFullscreen()) {\n\t\t\tconst cw = state.canvas.width / pd\n\t\t\tconst ch = state.canvas.height / pd\n\t\t\tconst ww = window.innerWidth\n\t\t\tconst wh = window.innerHeight\n\t\t\tconst rw = ww / wh\n\t\t\tconst rc = cw / ch\n\t\t\tif (rw > rc) {\n\t\t\t\tconst ratio = wh / ch\n\t\t\t\tconst offset = (ww - (cw * ratio)) / 2\n\t\t\t\tmousePos.x = map(e.offsetX - offset, 0, cw * ratio, 0, cw)\n\t\t\t\tmousePos.y = map(e.offsetY, 0, ch * ratio, 0, ch)\n\t\t\t} else {\n\t\t\t\tconst ratio = ww / cw\n\t\t\t\tconst offset = (wh - (ch * ratio)) / 2\n\t\t\t\tmousePos.x = map(e.offsetX , 0, cw * ratio, 0, cw)\n\t\t\t\tmousePos.y = map(e.offsetY - offset, 0, ch * ratio, 0, ch)\n\t\t\t}\n\t\t}\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tstate.isMouseMoved = true\n\t\t\tstate.mousePos = mousePos\n\t\t\tstate.mouseDeltaPos = mouseDeltaPos\n\t\t\tstate.events.trigger(\"mouseMove\")\n\t\t})\n\t}\n\n\tconst MOUSE_BUTTONS: MouseButton[] = [\n\t\t\"left\",\n\t\t\"middle\",\n\t\t\"right\",\n\t\t\"back\",\n\t\t\"forward\",\n\t]\n\n\tcanvasEvents.mousedown = (e) => {\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst m = MOUSE_BUTTONS[e.button]\n\t\t\tif (!m) return\n\t\t\tstate.mouseState.press(m)\n\t\t\tstate.events.trigger(\"mousePress\", m)\n\t\t})\n\t}\n\n\tcanvasEvents.mouseup = (e) => {\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst m = MOUSE_BUTTONS[e.button]\n\t\t\tif (!m) return\n\t\t\tstate.mouseState.release(m)\n\t\t\tstate.events.trigger(\"mouseRelease\", m)\n\t\t})\n\t}\n\n\tconst PREVENT_DEFAULT_KEYS = new Set([\n\t\t\" \",\n\t\t\"ArrowLeft\",\n\t\t\"ArrowRight\",\n\t\t\"ArrowUp\",\n\t\t\"ArrowDown\",\n\t\t\"Tab\",\n\t])\n\n\t// translate these key names to a simpler version\n\tconst KEY_ALIAS = {\n\t\t\"ArrowLeft\": \"left\",\n\t\t\"ArrowRight\": \"right\",\n\t\t\"ArrowUp\": \"up\",\n\t\t\"ArrowDown\": \"down\",\n\t\t\" \": \"space\",\n\t}\n\n\tcanvasEvents.keydown = (e) => {\n\t\tif (PREVENT_DEFAULT_KEYS.has(e.key)) {\n\t\t\te.preventDefault()\n\t\t}\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst k = KEY_ALIAS[e.key] || e.key.toLowerCase()\n\t\t\tif (k.length === 1) {\n\t\t\t\tstate.events.trigger(\"charInput\", k)\n\t\t\t\tstate.charInputted.push(k)\n\t\t\t} else if (k === \"space\") {\n\t\t\t\tstate.events.trigger(\"charInput\", \" \")\n\t\t\t\tstate.charInputted.push(\" \")\n\t\t\t}\n\t\t\tif (e.repeat) {\n\t\t\t\tstate.keyState.pressRepeat(k)\n\t\t\t\tstate.events.trigger(\"keyPressRepeat\", k)\n\t\t\t} else {\n\t\t\t\tstate.keyState.press(k)\n\t\t\t\tstate.events.trigger(\"keyPressRepeat\", k)\n\t\t\t\tstate.events.trigger(\"keyPress\", k)\n\t\t\t}\n\t\t})\n\t}\n\n\tcanvasEvents.keyup = (e) => {\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst k = KEY_ALIAS[e.key] || e.key.toLowerCase()\n\t\t\tstate.keyState.release(k)\n\t\t\tstate.events.trigger(\"keyRelease\", k)\n\t\t})\n\t}\n\n\tcanvasEvents.touchstart = (e) => {\n\t\t// disable long tap context menu\n\t\te.preventDefault()\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst touches = [...e.changedTouches]\n\t\t\tconst box = state.canvas.getBoundingClientRect()\n\t\t\tif (opt.touchToMouse !== false) {\n\t\t\t\tstate.mousePos = new Vec2(\n\t\t\t\t\ttouches[0].clientX - box.x,\n\t\t\t\t\ttouches[0].clientY - box.y,\n\t\t\t\t)\n\t\t\t\tstate.mouseState.press(\"left\")\n\t\t\t\tstate.events.trigger(\"mousePress\", \"left\")\n\t\t\t}\n\t\t\ttouches.forEach((t) => {\n\t\t\t\tstate.events.trigger(\n\t\t\t\t\t\"touchStart\",\n\t\t\t\t\tnew Vec2(t.clientX - box.x, t.clientY - box.y),\n\t\t\t\t\tt,\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n\n\tcanvasEvents.touchmove = (e) => {\n\t\t// disable scrolling\n\t\te.preventDefault()\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst touches = [...e.changedTouches]\n\t\t\tconst box = state.canvas.getBoundingClientRect()\n\t\t\tif (opt.touchToMouse !== false) {\n\t\t\t\tstate.mousePos = new Vec2(\n\t\t\t\t\ttouches[0].clientX - box.x,\n\t\t\t\t\ttouches[0].clientY - box.y,\n\t\t\t\t)\n\t\t\t\tstate.events.trigger(\"mouseMove\")\n\t\t\t}\n\t\t\ttouches.forEach((t) => {\n\t\t\t\tstate.events.trigger(\n\t\t\t\t\t\"touchMove\",\n\t\t\t\t\tnew Vec2(t.clientX - box.x, t.clientY - box.y),\n\t\t\t\t\tt,\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n\n\tcanvasEvents.touchend = (e) => {\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst touches = [...e.changedTouches]\n\t\t\tconst box = state.canvas.getBoundingClientRect()\n\t\t\tif (opt.touchToMouse !== false) {\n\t\t\t\tstate.mousePos = new Vec2(\n\t\t\t\t\ttouches[0].clientX - box.x,\n\t\t\t\t\ttouches[0].clientY - box.y,\n\t\t\t\t)\n\t\t\t\tstate.mouseState.release(\"left\")\n\t\t\t\tstate.events.trigger(\"mouseRelease\", \"left\")\n\t\t\t}\n\t\t\ttouches.forEach((t) => {\n\t\t\t\tstate.events.trigger(\n\t\t\t\t\t\"touchEnd\",\n\t\t\t\t\tnew Vec2(t.clientX - box.x, t.clientY - box.y),\n\t\t\t\t\tt,\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n\n\tcanvasEvents.touchcancel = (e) => {\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tconst touches = [...e.changedTouches]\n\t\t\tconst box = state.canvas.getBoundingClientRect()\n\t\t\tif (opt.touchToMouse !== false) {\n\t\t\t\tstate.mousePos = new Vec2(\n\t\t\t\t\ttouches[0].clientX - box.x,\n\t\t\t\t\ttouches[0].clientY - box.y,\n\t\t\t\t)\n\t\t\t\tstate.mouseState.release(\"left\")\n\t\t\t\tstate.events.trigger(\"mouseRelease\", \"left\")\n\t\t\t}\n\t\t\ttouches.forEach((t) => {\n\t\t\t\tstate.events.trigger(\n\t\t\t\t\t\"touchEnd\",\n\t\t\t\t\tnew Vec2(t.clientX - box.x, t.clientY - box.y),\n\t\t\t\t\tt,\n\t\t\t\t)\n\t\t\t})\n\t\t})\n\t}\n\n\t// TODO: option to not prevent default?\n\tcanvasEvents.wheel = (e) => {\n\t\te.preventDefault()\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tstate.events.trigger(\"scroll\", new Vec2(e.deltaX, e.deltaY))\n\t\t})\n\t}\n\n\tcanvasEvents.contextmenu = (e) => e.preventDefault()\n\n\tdocEvents.visibilitychange = () => {\n\t\tif (document.visibilityState === \"visible\") {\n\t\t\t// prevent a surge of dt when switch back after the tab being hidden for a while\n\t\t\tstate.skipTime = true\n\t\t\tstate.events.trigger(\"show\")\n\t\t} else {\n\t\t\tstate.events.trigger(\"hide\")\n\t\t}\n\t}\n\n\twinEvents.gamepadconnected = (e) => {\n\t\tconst kbGamepad = registerGamepad(e.gamepad)\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tstate.events.trigger(\"gamepadConnect\", kbGamepad)\n\t\t})\n\t}\n\n\twinEvents.gamepaddisconnected = (e) => {\n\t\tconst kbGamepad = getGamepads().filter((g) => g.index === e.gamepad.index)[0]\n\t\tremoveGamepad(e.gamepad)\n\t\tstate.events.onOnce(\"input\", () => {\n\t\t\tstate.events.trigger(\"gamepadDisconnect\", kbGamepad)\n\t\t})\n\t}\n\n\tfor (const name in canvasEvents) {\n\t\tstate.canvas.addEventListener(name, canvasEvents[name])\n\t}\n\n\tfor (const name in docEvents) {\n\t\tdocument.addEventListener(name, docEvents[name])\n\t}\n\n\tfor (const name in winEvents) {\n\t\twindow.addEventListener(name, winEvents[name])\n\t}\n\n\tconst resizeObserver = new ResizeObserver((entries) => {\n\t\tfor (const entry of entries) {\n\t\t\tif (entry.target !== state.canvas) continue\n\t\t\tif (\n\t\t\t\tstate.lastWidth === state.canvas.offsetWidth\n\t\t\t\t&& state.lastHeight === state.canvas.offsetHeight\n\t\t\t) return\n\t\t\tstate.lastWidth = state.canvas.offsetWidth\n\t\t\tstate.lastHeight = state.canvas.offsetHeight\n\t\t\tstate.events.onOnce(\"input\", () => {\n\t\t\t\tstate.events.trigger(\"resize\")\n\t\t\t})\n\t\t}\n\t})\n\n\tresizeObserver.observe(state.canvas)\n\n\treturn {\n\t\tdt,\n\t\ttime,\n\t\trun,\n\t\tcanvas,\n\t\tfps,\n\t\tnumFrames,\n\t\tquit,\n\t\tsetFullscreen,\n\t\tisFullscreen,\n\t\tsetCursor,\n\t\tscreenshot,\n\t\tgetGamepads,\n\t\tgetCursor,\n\t\tsetCursorLocked,\n\t\tisCursorLocked,\n\t\tisTouchscreen,\n\t\tmousePos,\n\t\tmouseDeltaPos,\n\t\tisKeyDown,\n\t\tisKeyPressed,\n\t\tisKeyPressedRepeat,\n\t\tisKeyReleased,\n\t\tisMouseDown,\n\t\tisMousePressed,\n\t\tisMouseReleased,\n\t\tisMouseMoved,\n\t\tisGamepadButtonPressed,\n\t\tisGamepadButtonDown,\n\t\tisGamepadButtonReleased,\n\t\tgetGamepadStick,\n\t\tcharInputted,\n\t\tonResize,\n\t\tonKeyDown,\n\t\tonKeyPress,\n\t\tonKeyPressRepeat,\n\t\tonKeyRelease,\n\t\tonMouseDown,\n\t\tonMousePress,\n\t\tonMouseRelease,\n\t\tonMouseMove,\n\t\tonCharInput,\n\t\tonTouchStart,\n\t\tonTouchMove,\n\t\tonTouchEnd,\n\t\tonScroll,\n\t\tonHide,\n\t\tonShow,\n\t\tonGamepadButtonDown,\n\t\tonGamepadButtonPress,\n\t\tonGamepadButtonRelease,\n\t\tonGamepadStick,\n\t\tonGamepadConnect,\n\t\tonGamepadDisconnect,\n\t\tevents: state.events,\n\t}\n\n}\n", "// https://easings.net/\nconst c1 = 1.70158\nconst c2 = c1 * 1.525\nconst c3 = c1 + 1\nconst c4 = (2 * Math.PI) / 3\nconst c5 = (2 * Math.PI) / 4.5\n\nconst easings = {\n\tlinear: (x) => x,\n\teaseInSine: (x) => 1 - Math.cos((x * Math.PI) / 2),\n\teaseOutSine: (x) => Math.sin((x * Math.PI) / 2),\n\teaseInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,\n\teaseInQuad: (x) => x * x,\n\teaseOutQuad: (x) => 1 - (1 - x) * (1 - x),\n\teaseInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,\n\teaseInCubic: (x) => x * x * x,\n\teaseOutCubic: (x) => 1 - Math.pow(1 - x, 3),\n\teaseInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,\n\teaseInQuart: (x) => x * x * x * x,\n\teaseOutQuart: (x) => 1 - Math.pow(1 - x, 4),\n\teaseInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,\n\teaseInQuint: (x) => x * x * x * x * x,\n\teaseOutQuint: (x) => 1 - Math.pow(1 - x, 5),\n\teaseInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,\n\teaseInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),\n\teaseOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),\n\teaseInOutExpo: (x) => {\n\t\treturn x === 0\n\t\t\t? 0\n\t\t\t: x === 1\n\t\t\t\t? 1\n\t\t\t\t: x < 0.5\n\t\t\t\t\t? Math.pow(2, 20 * x - 10) / 2\n\t\t\t\t\t: (2 - Math.pow(2, -20 * x + 10)) / 2\n\t},\n\teaseInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),\n\teaseOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),\n\teaseInOutCirc: (x) => {\n\t\treturn x < 0.5\n\t\t\t? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2\n\t\t\t: (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2\n\t},\n\teaseInBack: (x) => c3 * x * x * x - c1 * x * x,\n\teaseOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),\n\teaseInOutBack: (x) => {\n\t\treturn x < 0.5\n\t\t\t? (Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n\t\t\t: (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2\n\t},\n\teaseInElastic: (x) => {\n\t\treturn x === 0\n\t\t\t? 0\n\t\t\t: x === 1\n\t\t\t\t? 1\n\t\t\t\t: -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4)\n\t},\n\teaseOutElastic: (x) => {\n\t\treturn x === 0\n\t\t\t? 0\n\t\t\t: x === 1\n\t\t\t\t? 1\n\t\t\t\t: Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1\n\t},\n\teaseInOutElastic: (x) => {\n\t\treturn x === 0\n\t\t\t? 0\n\t\t\t: x === 1\n\t\t\t\t? 1\n\t\t\t\t: x < 0.5\n\t\t\t\t\t? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2\n\t\t\t\t\t: (Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5)) / 2 + 1\n\t},\n\teaseInBounce: (x) => 1 - easings.easeOutBounce(1 - x),\n\teaseOutBounce: (x) => {\n\t\tconst n1 = 7.5625\n\t\tconst d1 = 2.75\n\t\tif (x < 1 / d1) {\n\t\t\treturn n1 * x * x\n\t\t} else if (x < 2 / d1) {\n\t\t\treturn n1 * (x -= 1.5 / d1) * x + 0.75\n\t\t} else if (x < 2.5 / d1) {\n\t\t\treturn n1 * (x -= 2.25 / d1) * x + 0.9375\n\t\t} else {\n\t\t\treturn n1 * (x -= 2.625 / d1) * x + 0.984375\n\t\t}\n\t},\n\teaseInOutBounce: (x) => {\n\t\treturn x < 0.5\n\t\t\t? (1 - easings.easeOutBounce(1 - 2 * x)) / 2\n\t\t\t: (1 + easings.easeOutBounce(2 * x - 1)) / 2\n\t},\n}\n\nexport default easings\n", "export default class Timer {\n\n\ttime: number\n\taction: () => void\n\tfinished: boolean = false\n\tpaused: boolean = false\n\n\tconstructor(time: number, action: () => void) {\n\t\tthis.time = time\n\t\tthis.action = action\n\t}\n\n\ttick(dt: number): boolean {\n\t\tif (this.finished || this.paused) return false\n\t\tthis.time -= dt\n\t\tif (this.time <= 0) {\n\t\t\tthis.action()\n\t\t\tthis.finished = true\n\t\t\tthis.time = 0\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\treset(time) {\n\t\tthis.time = time\n\t\tthis.finished = false\n\t}\n\n}\n", "const VERSION = \"3000.1.12\"\n\nimport initApp from \"./app\"\n\nimport {\n\tsat,\n\tvec2,\n\tRect,\n\tPolygon,\n\tLine,\n\tCircle,\n\tColor,\n\tVec2,\n\tMat4,\n\tQuad,\n\tRNG,\n\tquad,\n\trgb,\n\thsl2rgb,\n\trand,\n\trandi,\n\trandSeed,\n\tchance,\n\tchoose,\n\tclamp,\n\tlerp,\n\tmap,\n\tmapc,\n\twave,\n\ttestLinePoint,\n\ttestLineLine,\n\ttestLineCircle,\n\ttestRectRect,\n\ttestRectLine,\n\ttestRectPoint,\n\ttestPolygonPoint,\n\ttestCirclePolygon,\n\tdeg2rad,\n\trad2deg,\n} from \"./math\"\n\nimport easings from \"./easings\"\n\nimport {\n\tIDList,\n\tEvent,\n\tEventHandler,\n\tdownload,\n\tdownloadText,\n\tdownloadJSON,\n\tdownloadBlob,\n\tuid,\n\tisDataURL,\n\tgetExt,\n\tdeepEq,\n\tdataURLToArrayBuffer,\n\tEventController,\n\t// eslint-disable-next-line\n\twarn,\n\t// eslint-disable-next-line\n\tbenchmark,\n\t// eslint-disable-next-line\n\tcomparePerf,\n\tBinaryHeap,\n} from \"./utils\"\n\nimport type {\n\tGfxShader,\n\tGfxFont,\n\tRenderProps,\n\tCharTransform,\n\tTextureOpt,\n\tImageSource,\n\tFormattedText,\n\tFormattedChar,\n\tDrawRectOpt,\n\tDrawLineOpt,\n\tDrawLinesOpt,\n\tDrawTriangleOpt,\n\tDrawPolygonOpt,\n\tDrawCircleOpt,\n\tDrawEllipseOpt,\n\tDrawUVQuadOpt,\n\tVertex,\n\tBitmapFontData,\n\tShaderData,\n\tLoadSpriteSrc,\n\tLoadSpriteOpt,\n\tSpriteAtlasData,\n\tLoadBitmapFontOpt,\n\tKaboomCtx,\n\tKaboomOpt,\n\tAudioPlay,\n\tAudioPlayOpt,\n\tDrawSpriteOpt,\n\tDrawTextOpt,\n\tTextAlign,\n\tGameObj,\n\tSceneName,\n\tSceneDef,\n\tCompList,\n\tComp,\n\tTag,\n\tKey,\n\tMouseButton,\n\tPosComp,\n\tScaleComp,\n\tRotateComp,\n\tColorComp,\n\tOpacityComp,\n\tAnchor,\n\tAnchorComp,\n\tZComp,\n\tFollowComp,\n\tOffScreenCompOpt,\n\tOffScreenComp,\n\tAreaCompOpt,\n\tAreaComp,\n\tSpriteComp,\n\tSpriteCompOpt,\n\tSpriteAnimPlayOpt,\n\tSpriteAnims,\n\tTextComp,\n\tTextCompOpt,\n\tRectComp,\n\tRectCompOpt,\n\tUVQuadComp,\n\tCircleCompOpt,\n\tCircleComp,\n\tOutlineComp,\n\tTimerComp,\n\tBodyComp,\n\tBodyCompOpt,\n\tUniform,\n\tShaderComp,\n\tFixedComp,\n\tStayComp,\n\tHealthComp,\n\tLifespanCompOpt,\n\tStateComp,\n\tDebug,\n\tKaboomPlugin,\n\tEmptyComp,\n\tLevelComp,\n\tEdge,\n\tTileComp,\n\tTileCompOpt,\n\tLevelOpt,\n\tRecording,\n\tBoomOpt,\n\tPeditFile,\n\tShape,\n\tDoubleJumpComp,\n\tTimerController,\n\tTweenController,\n\tLoadFontOpt,\n\tAgentComp,\n\tAgentCompOpt,\n\tPathFindOpt,\n\tGetOpt,\n\tVec2Args,\n\tNineSlice,\n\tLerpValue,\n\tTexFilter,\n\tMaskComp,\n\tMask,\n\tOutline,\n} from \"./types\"\n\nimport Timer from \"./timer\"\n\nimport beanSpriteSrc from \"./assets/bean.png\"\nimport burpSoundSrc from \"./assets/burp.mp3\"\nimport kaSpriteSrc from \"./assets/ka.png\"\nimport boomSpriteSrc from \"./assets/boom.png\"\n\ntype EventList<M> = {\n\t[event in keyof M]?: (event: M[event]) => void\n}\n\ninterface SpriteCurAnim {\n\tname: string,\n\ttimer: number,\n\tloop: boolean,\n\tspeed: number,\n\tpingpong: boolean,\n\tonEnd: () => void,\n}\n\n// some default charsets for loading bitmap fonts\nconst ASCII_CHARS = \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\"\n\nconst DEF_ANCHOR = \"topleft\"\nconst BG_GRID_SIZE = 64\n\nconst DEF_FONT = \"monospace\"\nconst DBG_FONT = \"monospace\"\nconst DEF_TEXT_SIZE = 36\nconst DEF_TEXT_CACHE_SIZE = 64\nconst MAX_TEXT_CACHE_SIZE = 256\nconst FONT_ATLAS_WIDTH = 2048\nconst FONT_ATLAS_HEIGHT = 2048\nconst SPRITE_ATLAS_WIDTH = 2048\nconst SPRITE_ATLAS_HEIGHT = 2048\n// 0.1 pixel padding to texture coordinates to prevent artifact\nconst UV_PAD = 0.1\nconst DEF_HASH_GRID_SIZE = 64\nconst DEF_FONT_FILTER = \"nearest\"\n\nconst LOG_MAX = 8\nconst LOG_TIME = 4\n\nconst VERTEX_FORMAT = [\n\t{ name: \"a_pos\", size: 2 },\n\t{ name: \"a_uv\", size: 2 },\n\t{ name: \"a_color\", size: 4 },\n]\n\nconst STRIDE = VERTEX_FORMAT.reduce((sum, f) => sum + f.size, 0)\n\nconst MAX_BATCHED_QUAD = 2048\nconst MAX_BATCHED_VERTS = MAX_BATCHED_QUAD * 4 * STRIDE\nconst MAX_BATCHED_INDICES = MAX_BATCHED_QUAD * 6\n\n// vertex shader template, replace {{user}} with user vertex shader code\nconst VERT_TEMPLATE = `\nattribute vec2 a_pos;\nattribute vec2 a_uv;\nattribute vec4 a_color;\n\nvarying vec2 v_pos;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nvec4 def_vert() {\n\treturn vec4(a_pos, 0.0, 1.0);\n}\n\n{{user}}\n\nvoid main() {\n\tvec4 pos = vert(a_pos, a_uv, a_color);\n\tv_pos = a_pos;\n\tv_uv = a_uv;\n\tv_color = a_color;\n\tgl_Position = pos;\n}\n`\n\n// fragment shader template, replace {{user}} with user fragment shader code\nconst FRAG_TEMPLATE = `\nprecision mediump float;\n\nvarying vec2 v_pos;\nvarying vec2 v_uv;\nvarying vec4 v_color;\n\nuniform sampler2D u_tex;\n\nvec4 def_frag() {\n\treturn v_color * texture2D(u_tex, v_uv);\n}\n\n{{user}}\n\nvoid main() {\n\tgl_FragColor = frag(v_pos, v_uv, v_color, u_tex);\n\tif (gl_FragColor.a == 0.0) {\n\t\tdiscard;\n\t}\n}\n`\n\n// default {{user}} vertex shader code\nconst DEF_VERT = `\nvec4 vert(vec2 pos, vec2 uv, vec4 color) {\n\treturn def_vert();\n}\n`\n\n// default {{user}} fragment shader code\nconst DEF_FRAG = `\nvec4 frag(vec2 pos, vec2 uv, vec4 color, sampler2D tex) {\n\treturn def_frag();\n}\n`\n\nconst COMP_DESC = new Set([\n\t\"id\",\n\t\"require\",\n])\n\nconst COMP_EVENTS = new Set([\n\t\"add\",\n\t\"update\",\n\t\"draw\",\n\t\"destroy\",\n\t\"inspect\",\n\t\"drawInspect\",\n])\n\n// convert anchor string to a vec2 offset\nfunction anchorPt(orig: Anchor | Vec2): Vec2 {\n\tswitch (orig) {\n\t\tcase \"topleft\": return new Vec2(-1, -1)\n\t\tcase \"top\": return new Vec2(0, -1)\n\t\tcase \"topright\": return new Vec2(1, -1)\n\t\tcase \"left\": return new Vec2(-1, 0)\n\t\tcase \"center\": return new Vec2(0, 0)\n\t\tcase \"right\": return new Vec2(1, 0)\n\t\tcase \"botleft\": return new Vec2(-1, 1)\n\t\tcase \"bot\": return new Vec2(0, 1)\n\t\tcase \"botright\": return new Vec2(1, 1)\n\t\tdefault: return orig\n\t}\n}\n\nfunction alignPt(align: TextAlign): number {\n\tswitch (align) {\n\t\tcase \"left\": return 0\n\t\tcase \"center\": return 0.5\n\t\tcase \"right\": return 1\n\t\tdefault: return 0\n\t}\n}\n\nfunction createEmptyAudioBuffer(ctx: AudioContext) {\n\treturn ctx.createBuffer(1, 1, 44100)\n}\n\n// only exports one kaboom() which contains all the state\nexport default (gopt: KaboomOpt = {}): KaboomCtx => {\n\n\tconst root = gopt.root ?? document.body\n\n\t// if root is not defined (which falls back to <body>) we assume user is using kaboom on a clean page, and modify <body> to better fit a full screen canvas\n\tif (root === document.body) {\n\t\tdocument.body.style[\"width\"] = \"100%\"\n\t\tdocument.body.style[\"height\"] = \"100%\"\n\t\tdocument.body.style[\"margin\"] = \"0px\"\n\t\tdocument.documentElement.style[\"width\"] = \"100%\"\n\t\tdocument.documentElement.style[\"height\"] = \"100%\"\n\t}\n\n\t// create a <canvas> if user didn't provide one\n\tconst canvas = gopt.canvas ?? (() => {\n\t\tconst canvas = document.createElement(\"canvas\")\n\t\troot.appendChild(canvas)\n\t\treturn canvas\n\t})()\n\n\t// global pixel scale\n\tconst gscale = gopt.scale ?? 1\n\tconst fixedSize = gopt.width && gopt.height && !gopt.stretch && !gopt.letterbox\n\n\t// adjust canvas size according to user size / viewport settings\n\tif (fixedSize) {\n\t\tcanvas.width = gopt.width * gscale\n\t\tcanvas.height = gopt.height * gscale\n\t} else {\n\t\tcanvas.width = canvas.parentElement.offsetWidth\n\t\tcanvas.height = canvas.parentElement.offsetHeight\n\t}\n\n\t// canvas css styles\n\tconst styles = [\n\t\t\"outline: none\",\n\t\t\"cursor: default\",\n\t]\n\n\tif (fixedSize) {\n\t\tconst cw = canvas.width\n\t\tconst ch = canvas.height\n\t\tstyles.push(`width: ${cw}px`)\n\t\tstyles.push(`height: ${ch}px`)\n\t} else {\n\t\tstyles.push(\"width: 100%\")\n\t\tstyles.push(\"height: 100%\")\n\t}\n\n\tif (gopt.crisp) {\n\t\t// chrome only supports pixelated and firefox only supports crisp-edges\n\t\tstyles.push(\"image-rendering: pixelated\")\n\t\tstyles.push(\"image-rendering: crisp-edges\")\n\t}\n\n\tcanvas.style.cssText = styles.join(\";\")\n\n\tconst pixelDensity = gopt.pixelDensity || window.devicePixelRatio\n\n\tcanvas.width *= pixelDensity\n\tcanvas.height *= pixelDensity\n\t// make canvas focusable\n\tcanvas.tabIndex = 0\n\n\tconst fontCacheCanvas = document.createElement(\"canvas\")\n\tfontCacheCanvas.width = MAX_TEXT_CACHE_SIZE\n\tfontCacheCanvas.height = MAX_TEXT_CACHE_SIZE\n\tconst fontCacheCtx = fontCacheCanvas.getContext(\"2d\", {\n\t\twillReadFrequently: true,\n\t})\n\n\tconst app = initApp({\n\t\tcanvas: canvas,\n\t\ttouchToMouse: gopt.touchToMouse,\n\t\tgamepads: gopt.gamepads,\n\t\tpixelDensity: gopt.pixelDensity,\n\t\tmaxFPS: gopt.maxFPS,\n\t})\n\n\tconst gc: Array<() => void> = []\n\n\tconst gl = app.canvas()\n\t\t.getContext(\"webgl\", {\n\t\t\tantialias: true,\n\t\t\tdepth: true,\n\t\t\tstencil: true,\n\t\t\talpha: true,\n\t\t\tpreserveDrawingBuffer: true,\n\t\t})\n\n\tfunction genBindFunc<T>(func: (ty: GLenum, item: T) => void) {\n\t\tconst bindings = {}\n\t\treturn {\n\t\t\tcur: (ty: GLenum) => {\n\t\t\t\tconst stack = bindings[ty] ?? []\n\t\t\t\treturn stack[stack.length - 1]\n\t\t\t},\n\t\t\tpush: (ty: GLenum, item: T) => {\n\t\t\t\tif (!bindings[ty]) bindings[ty] = []\n\t\t\t\tconst stack = bindings[ty]\n\t\t\t\tstack.push(item)\n\t\t\t\tfunc(ty, item)\n\t\t\t},\n\t\t\tpop: (ty: GLenum) => {\n\t\t\t\tconst stack = bindings[ty]\n\t\t\t\tif (!stack) throw new Error(`Unknown WebGL type: ${ty}`)\n\t\t\t\tif (stack.length <= 0) throw new Error(\"Can't unbind texture when there's no texture bound\")\n\t\t\t\tstack.pop()\n\t\t\t\tfunc(ty, stack[stack.length - 1] ?? null)\n\t\t\t},\n\t\t}\n\t}\n\n\tconst glTextureBinder = genBindFunc(gl.bindTexture.bind(gl))\n\tconst glFramebufferBinder = genBindFunc(gl.bindFramebuffer.bind(gl))\n\tconst glRenderbufferBinder = genBindFunc(gl.bindRenderbuffer.bind(gl))\n\n\tclass Texture {\n\n\t\tsrc: null | ImageSource = null\n\t\tglTex: WebGLTexture\n\t\twidth: number\n\t\theight: number\n\n\t\tconstructor(w: number, h: number, opt: TextureOpt = {}) {\n\n\t\t\tthis.glTex = gl.createTexture()\n\t\t\tgc.push(() => this.free())\n\t\t\tthis.bind()\n\n\t\t\tif (w && h) {\n\t\t\t\tgl.texImage2D(\n\t\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\t\t0, gl.RGBA,\n\t\t\t\t\tw,\n\t\t\t\t\th,\n\t\t\t\t\t0,\n\t\t\t\t\tgl.RGBA,\n\t\t\t\t\tgl.UNSIGNED_BYTE,\n\t\t\t\t\tnull,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tthis.width = w\n\t\t\tthis.height = h\n\n\t\t\tconst filter = (() => {\n\t\t\t\tswitch (opt.filter ?? gopt.texFilter) {\n\t\t\t\t\tcase \"linear\": return gl.LINEAR\n\t\t\t\t\tcase \"nearest\": return gl.NEAREST\n\t\t\t\t\tdefault: return gl.NEAREST\n\t\t\t\t}\n\t\t\t})()\n\n\t\t\tconst wrap = (() => {\n\t\t\t\tswitch (opt.wrap) {\n\t\t\t\t\tcase \"repeat\": return gl.REPEAT\n\t\t\t\t\tcase \"clampToEdge\": return gl.CLAMP_TO_EDGE\n\t\t\t\t\tdefault: return gl.CLAMP_TO_EDGE\n\t\t\t\t}\n\t\t\t})()\n\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filter)\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filter)\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrap)\n\t\t\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrap)\n\t\t\tthis.unbind()\n\n\t\t}\n\n\t\tstatic fromImage(img: ImageSource, opt: TextureOpt = {}): Texture {\n\t\t\tconst tex = new Texture(0, 0, opt)\n\t\t\ttex.bind()\n\t\t\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img)\n\t\t\ttex.width = img.width\n\t\t\ttex.height = img.height\n\t\t\ttex.unbind()\n\t\t\ttex.src = img\n\t\t\treturn tex\n\t\t}\n\n\t\tupdate(img: ImageSource, x = 0, y = 0) {\n\t\t\tthis.bind()\n\t\t\tgl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, gl.RGBA, gl.UNSIGNED_BYTE, img)\n\t\t\tthis.unbind()\n\t\t}\n\n\t\tbind() {\n\t\t\tglTextureBinder.push(gl.TEXTURE_2D, this.glTex)\n\t\t}\n\n\t\tunbind() {\n\t\t\tglTextureBinder.pop(gl.TEXTURE_2D)\n\t\t}\n\n\t\tfree() {\n\t\t\tgl.deleteTexture(this.glTex)\n\t\t}\n\n\t}\n\n\tclass KaboomError extends Error {\n\t\tconstructor(msg) {\n\t\t\tsuper(msg)\n\t\t\tthis.name = \"KaboomError\"\n\t\t}\n\t}\n\n\tclass TexPacker {\n\t\tprivate tex: Texture\n\t\tprivate canvas: HTMLCanvasElement\n\t\tprivate ctx: CanvasRenderingContext2D\n\t\tprivate x: number = 0\n\t\tprivate y: number = 0\n\t\tprivate curHeight: number = 0\n\t\tconstructor(w: number, h: number) {\n\t\t\tthis.canvas = document.createElement(\"canvas\")\n\t\t\tthis.canvas.width = w\n\t\t\tthis.canvas.height = h\n\t\t\tthis.tex = Texture.fromImage(this.canvas)\n\t\t\tthis.ctx = this.canvas.getContext(\"2d\")\n\t\t}\n\t\tadd(img: ImageSource): [Texture, Quad] {\n\t\t\tif (img.width > this.canvas.width || img.height > this.canvas.height) {\n\t\t\t\tthrow new KaboomError(`Texture size (${img.width} x ${img.height}) exceeds limit (${this.canvas.width} x ${this.canvas.height})`)\n\t\t\t}\n\t\t\tif (this.x + img.width > this.canvas.width) {\n\t\t\t\tthis.x = 0\n\t\t\t\tthis.y += this.curHeight\n\t\t\t\tthis.curHeight = 0\n\t\t\t}\n\t\t\tif (this.y + img.height > this.canvas.height) {\n\t\t\t\tthis.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n\t\t\t\tthis.tex = Texture.fromImage(this.canvas)\n\t\t\t\tthis.x = 0\n\t\t\t\tthis.y = 0\n\t\t\t\tthis.curHeight = 0\n\t\t\t}\n\t\t\tconst pos = new Vec2(this.x, this.y)\n\t\t\tthis.x += img.width\n\t\t\tif (img.height > this.curHeight) {\n\t\t\t\tthis.curHeight = img.height\n\t\t\t}\n\t\t\tif (img instanceof ImageData) {\n\t\t\t\tthis.ctx.putImageData(img, pos.x, pos.y)\n\t\t\t} else {\n\t\t\t\tthis.ctx.drawImage(img, pos.x, pos.y)\n\t\t\t}\n\t\t\tthis.tex.update(this.canvas)\n\t\t\treturn [this.tex, new Quad(\n\t\t\t\tpos.x / this.canvas.width,\n\t\t\t\tpos.y / this.canvas.height,\n\t\t\t\timg.width / this.canvas.width,\n\t\t\t\timg.height / this.canvas.height,\n\t\t\t)]\n\t\t}\n\t}\n\n\tclass FrameBuffer {\n\n\t\ttex: Texture\n\t\tglFramebuffer: WebGLFramebuffer\n\t\tglRenderbuffer: WebGLRenderbuffer\n\n\t\tconstructor(w: number, h: number, opt: TextureOpt = {}) {\n\t\t\tthis.tex = new Texture(w, h, opt)\n\t\t\tthis.glFramebuffer = gl.createFramebuffer()\n\t\t\tthis.glRenderbuffer = gl.createRenderbuffer()\n\t\t\tgc.push(() => this.free())\n\t\t\tthis.bind()\n\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, w, h)\n\t\t\tgl.framebufferTexture2D(\n\t\t\t\tgl.FRAMEBUFFER,\n\t\t\t\tgl.COLOR_ATTACHMENT0,\n\t\t\t\tgl.TEXTURE_2D,\n\t\t\t\tthis.tex.glTex,\n\t\t\t\t0,\n\t\t\t)\n\t\t\tgl.framebufferRenderbuffer(\n\t\t\t\tgl.FRAMEBUFFER,\n\t\t\t\tgl.DEPTH_STENCIL_ATTACHMENT,\n\t\t\t\tgl.RENDERBUFFER,\n\t\t\t\tthis.glRenderbuffer,\n\t\t\t)\n\t\t\tthis.unbind()\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.tex.width\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.tex.height\n\t\t}\n\n\t\ttoImageData() {\n\t\t\tconst data = new Uint8ClampedArray(this.width * this.height * 4)\n\t\t\tthis.bind()\n\t\t\tgl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, data)\n\t\t\tthis.unbind()\n\t\t\t// flip vertically\n\t\t\tconst bytesPerRow = this.width * 4\n\t\t\tconst temp = new Uint8Array(bytesPerRow)\n\t\t\tfor (let y = 0; y < (this.height / 2 | 0); y++) {\n\t\t\t\tconst topOffset = y * bytesPerRow\n\t\t\t\tconst bottomOffset = (this.height - y - 1) * bytesPerRow\n\t\t\t\ttemp.set(data.subarray(topOffset, topOffset + bytesPerRow))\n\t\t\t\tdata.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow)\n\t\t\t\tdata.set(temp, bottomOffset)\n\t\t\t}\n\t\t\treturn new ImageData(data, this.width, this.height)\n\t\t}\n\n\t\ttoDataURL() {\n\t\t\tconst canvas = document.createElement(\"canvas\")\n\t\t\tconst ctx = canvas.getContext(\"2d\")\n\t\t\tcanvas.width = this.width\n\t\t\tcanvas.height = this.height\n\t\t\tctx.putImageData(this.toImageData(), 0, 0)\n\t\t\treturn canvas.toDataURL()\n\t\t}\n\n\t\tbind() {\n\t\t\tglFramebufferBinder.push(gl.FRAMEBUFFER, this.glFramebuffer)\n\t\t\tglRenderbufferBinder.push(gl.RENDERBUFFER, this.glRenderbuffer)\n\t\t}\n\n\t\tunbind() {\n\t\t\tglFramebufferBinder.pop(gl.FRAMEBUFFER)\n\t\t\tglRenderbufferBinder.pop(gl.RENDERBUFFER)\n\t\t}\n\n\t\tfree() {\n\t\t\tgl.deleteFramebuffer(this.glFramebuffer)\n\t\t\tgl.deleteRenderbuffer(this.glRenderbuffer)\n\t\t\tthis.tex.free()\n\t\t}\n\n\t}\n\n\tconst gfx = (() => {\n\n\t\tconst defShader = makeShader(DEF_VERT, DEF_FRAG)\n\n\t\t// a 1x1 white texture to draw raw shapes like rectangles and polygons\n\t\t// we use a texture for those so we can use only 1 pipeline for drawing sprites + shapes\n\t\tconst emptyTex = Texture.fromImage(\n\t\t\tnew ImageData(new Uint8ClampedArray([ 255, 255, 255, 255 ]), 1, 1),\n\t\t)\n\n\t\tconst frameBuffer = (gopt.width && gopt.height)\n\t\t\t? new FrameBuffer(gopt.width * pixelDensity * gscale, gopt.height * pixelDensity * gscale)\n\t\t\t: new FrameBuffer(gl.drawingBufferWidth, gl.drawingBufferHeight)\n\n\t\tlet bgColor: null | Color = null\n\t\tlet bgAlpha = 1\n\n\t\tif (gopt.background) {\n\t\t\tbgColor = Color.fromArray(gopt.background)\n\t\t\tbgAlpha = gopt.background[3] ?? 1\n\t\t\tgl.clearColor(\n\t\t\t\tbgColor.r / 255,\n\t\t\t\tbgColor.g / 255,\n\t\t\t\tbgColor.b / 255,\n\t\t\t\tbgAlpha,\n\t\t\t)\n\t\t}\n\n\t\tgl.enable(gl.BLEND)\n\t\tgl.blendFuncSeparate(\n\t\t\tgl.SRC_ALPHA,\n\t\t\tgl.ONE_MINUS_SRC_ALPHA,\n\t\t\tgl.ONE,\n\t\t\tgl.ONE_MINUS_SRC_ALPHA,\n\t\t)\n\n\t\t// we only use one vertex and index buffer that batches all draw calls\n\t\tconst vbuf = gl.createBuffer()\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vbuf)\n\t\tgl.bufferData(gl.ARRAY_BUFFER, MAX_BATCHED_VERTS * 4, gl.DYNAMIC_DRAW)\n\n\t\tVERTEX_FORMAT.reduce((offset, f, i) => {\n\t\t\tgl.vertexAttribPointer(i, f.size, gl.FLOAT, false, STRIDE * 4, offset)\n\t\t\tgl.enableVertexAttribArray(i)\n\t\t\treturn offset + f.size * 4\n\t\t}, 0)\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null)\n\n\t\tconst ibuf = gl.createBuffer()\n\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibuf)\n\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, MAX_BATCHED_INDICES * 4, gl.DYNAMIC_DRAW)\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n\n\t\t// a checkerboard texture used for the default background\n\t\tconst bgTex = Texture.fromImage(\n\t\t\tnew ImageData(new Uint8ClampedArray([\n\t\t\t\t128, 128, 128, 255,\n\t\t\t\t190, 190, 190, 255,\n\t\t\t\t190, 190, 190, 255,\n\t\t\t\t128, 128, 128, 255,\n\t\t\t]), 2, 2), {\n\t\t\t\twrap: \"repeat\",\n\t\t\t\tfilter: \"nearest\",\n\t\t\t},\n\t\t)\n\n\t\treturn {\n\n\t\t\t// keep track of how many draw calls we're doing this frame\n\t\t\tdrawCalls: 0,\n\t\t\t// how many draw calls we're doing last frame, this is the number we give to users\n\t\t\tlastDrawCalls: 0,\n\n\t\t\t// gfx states\n\t\t\tdefShader: defShader,\n\t\t\tcurShader: defShader,\n\t\t\tframeBuffer: frameBuffer,\n\t\t\tpostShader: null,\n\t\t\tpostShaderUniform: null,\n\t\t\tdefTex: emptyTex,\n\t\t\tcurTex: emptyTex,\n\t\t\tcurUniform: {},\n\t\t\tvbuf: vbuf,\n\t\t\tibuf: ibuf,\n\n\t\t\t// local vertex / index buffer queue\n\t\t\tvqueue: [],\n\t\t\tiqueue: [],\n\n\t\t\ttransform: new Mat4(),\n\t\t\ttransformStack: [],\n\n\t\t\tbgTex: bgTex,\n\t\t\tbgColor: bgColor,\n\t\t\tbgAlpha: bgAlpha,\n\n\t\t\twidth: gopt.width ?? gl.drawingBufferWidth / pixelDensity / gscale,\n\t\t\theight: gopt.height ?? gl.drawingBufferHeight / pixelDensity / gscale,\n\n\t\t\tviewport: {\n\t\t\t\tx: 0,\n\t\t\t\ty: 0,\n\t\t\t\twidth: gl.drawingBufferWidth,\n\t\t\t\theight: gl.drawingBufferHeight,\n\t\t\t},\n\n\t\t\tfixed: false,\n\n\t\t}\n\n\t})()\n\n\tclass SpriteData {\n\n\t\ttex: Texture\n\t\tframes: Quad[] = [ new Quad(0, 0, 1, 1) ]\n\t\tanims: SpriteAnims = {}\n\t\tslice9: NineSlice | null = null\n\n\t\tconstructor(\n\t\t\ttex: Texture,\n\t\t\tframes?: Quad[],\n\t\t\tanims: SpriteAnims = {},\n\t\t\tslice9: NineSlice = null,\n\t\t) {\n\t\t\tthis.tex = tex\n\t\t\tif (frames) this.frames = frames\n\t\t\tthis.anims = anims\n\t\t\tthis.slice9 = slice9\n\t\t}\n\n\t\tget width() {\n\t\t\treturn this.tex.width * this.frames[0].w\n\t\t}\n\n\t\tget height() {\n\t\t\treturn this.tex.height * this.frames[0].h\n\t\t}\n\n\t\tstatic from(src: LoadSpriteSrc, opt: LoadSpriteOpt = {}): Promise<SpriteData> {\n\t\t\treturn typeof src === \"string\"\n\t\t\t\t? SpriteData.fromURL(src, opt)\n\t\t\t\t: Promise.resolve(SpriteData.fromImage(src, opt))\n\t\t}\n\n\t\tstatic fromImage(data: ImageSource, opt: LoadSpriteOpt = {}): SpriteData {\n\t\t\tconst [tex, quad] = assets.packer.add(data)\n\t\t\tconst frames = opt.frames ? opt.frames.map((f) => new Quad(\n\t\t\t\tquad.x + f.x * quad.w,\n\t\t\t\tquad.y + f.y * quad.h,\n\t\t\t\tf.w * quad.w,\n\t\t\t\tf.h * quad.h,\n\t\t\t)) : slice(opt.sliceX || 1, opt.sliceY || 1, quad.x, quad.y, quad.w, quad.h)\n\t\t\treturn new SpriteData(tex, frames, opt.anims, opt.slice9)\n\t\t}\n\n\t\tstatic fromURL(url: string, opt: LoadSpriteOpt = {}): Promise<SpriteData> {\n\t\t\treturn loadImg(url).then((img) => SpriteData.fromImage(img, opt))\n\t\t}\n\n\t}\n\n\tclass SoundData {\n\n\t\tbuf: AudioBuffer\n\n\t\tconstructor(buf: AudioBuffer) {\n\t\t\tthis.buf = buf\n\t\t}\n\n\t\tstatic fromArrayBuffer(buf: ArrayBuffer): Promise<SoundData> {\n\t\t\treturn new Promise((resolve, reject) =>\n\t\t\t\taudio.ctx.decodeAudioData(buf, resolve, reject),\n\t\t\t).then((buf: AudioBuffer) => new SoundData(buf))\n\t\t}\n\n\t\tstatic fromURL(url: string): Promise<SoundData> {\n\t\t\tif (isDataURL(url)) {\n\t\t\t\treturn SoundData.fromArrayBuffer(dataURLToArrayBuffer(url))\n\t\t\t} else {\n\t\t\t\treturn fetchArrayBuffer(url).then((buf) => SoundData.fromArrayBuffer(buf))\n\t\t\t}\n\t\t}\n\n\t}\n\n\tconst audio = (() => {\n\n\t\tconst ctx = new (\n\t\t\twindow.AudioContext || (window as any).webkitAudioContext\n\t\t)() as AudioContext\n\n\t\tconst masterNode = ctx.createGain()\n\t\tmasterNode.connect(ctx.destination)\n\n\t\t// by default browsers can only load audio async, we don't deal with that and just start with an empty audio buffer\n\t\tconst burpSnd = new SoundData(createEmptyAudioBuffer(ctx))\n\n\t\t// load that burp sound\n\t\tctx.decodeAudioData(burpSoundSrc.buffer.slice(0)).then((buf) => {\n\t\t\tburpSnd.buf = buf\n\t\t}).catch((err) => {\n\t\t\tconsole.error(\"Failed to load burp: \", err)\n\t\t})\n\n\t\treturn {\n\t\t\tctx,\n\t\t\tmasterNode,\n\t\t\tburpSnd,\n\t\t}\n\n\t})()\n\n\tclass Asset<D> {\n\t\tloaded: boolean = false\n\t\tdata: D | null = null\n\t\terror: Error | null = null\n\t\tprivate onLoadEvents: Event<[D]> = new Event()\n\t\tprivate onErrorEvents: Event<[Error]> = new Event()\n\t\tprivate onFinishEvents: Event<[]> = new Event()\n\t\tconstructor(loader: Promise<D>) {\n\t\t\tloader.then((data) => {\n\t\t\t\tthis.data = data\n\t\t\t\tthis.onLoadEvents.trigger(data)\n\t\t\t}).catch((err) => {\n\t\t\t\tthis.error = err\n\t\t\t\tif (this.onErrorEvents.numListeners() > 0) {\n\t\t\t\t\tthis.onErrorEvents.trigger(err)\n\t\t\t\t} else {\n\t\t\t\t\tthrow err\n\t\t\t\t}\n\t\t\t}).finally(() => {\n\t\t\t\tthis.onFinishEvents.trigger()\n\t\t\t\tthis.loaded = true\n\t\t\t})\n\t\t}\n\t\tstatic loaded<D>(data: D): Asset<D> {\n\t\t\tconst asset = new Asset(Promise.resolve(data)) as Asset<D>\n\t\t\tasset.data = data\n\t\t\tasset.loaded = true\n\t\t\treturn asset\n\t\t}\n\t\tonLoad(action: (data: D) => void) {\n\t\t\tif (this.loaded && this.data) {\n\t\t\t\taction(this.data)\n\t\t\t} else {\n\t\t\t\tthis.onLoadEvents.add(action)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\tonError(action: (err: Error) => void) {\n\t\t\tif (this.loaded && this.error) {\n\t\t\t\taction(this.error)\n\t\t\t} else {\n\t\t\t\tthis.onErrorEvents.add(action)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\tonFinish(action: () => void) {\n\t\t\tif (this.loaded) {\n\t\t\t\taction()\n\t\t\t} else {\n\t\t\t\tthis.onFinishEvents.add(action)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\t\tthen(action: (data: D) => void): Asset<D> {\n\t\t\treturn this.onLoad(action)\n\t\t}\n\t\tcatch(action: (err: Error) => void): Asset<D> {\n\t\t\treturn this.onError(action)\n\t\t}\n\t\tfinally(action: () => void): Asset<D> {\n\t\t\treturn this.onFinish(action)\n\t\t}\n\t}\n\n\tclass AssetBucket<D> {\n\t\tassets: Map<string, Asset<D>> = new Map()\n\t\tlastUID: number = 0\n\t\tadd(name: string | null, loader: Promise<D>): Asset<D> {\n\t\t\t// if user don't provide a name we use a generated one\n\t\t\tconst id = name ?? (this.lastUID++ + \"\")\n\t\t\tconst asset = new Asset(loader)\n\t\t\tthis.assets.set(id, asset)\n\t\t\treturn asset\n\t\t}\n\t\taddLoaded(name: string | null, data: D): Asset<D> {\n\t\t\tconst id = name ?? (this.lastUID++ + \"\")\n\t\t\tconst asset = Asset.loaded(data)\n\t\t\tthis.assets.set(id, asset)\n\t\t\treturn asset\n\t\t}\n\t\tget(handle: string): Asset<D> | void {\n\t\t\treturn this.assets.get(handle)\n\t\t}\n\t\tprogress(): number {\n\t\t\tif (this.assets.size === 0) {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tlet loaded = 0\n\t\t\tthis.assets.forEach((asset) => {\n\t\t\t\tif (asset.loaded) {\n\t\t\t\t\tloaded++\n\t\t\t\t}\n\t\t\t})\n\t\t\treturn loaded / this.assets.size\n\t\t}\n\t}\n\n\tconst assets = {\n\t\t// prefix for when loading from a url\n\t\turlPrefix: \"\",\n\t\t// asset holders\n\t\tsprites: new AssetBucket<SpriteData>(),\n\t\tfonts: new AssetBucket<FontData>(),\n\t\tbitmapFonts: new AssetBucket<BitmapFontData>(),\n\t\tsounds: new AssetBucket<SoundData>(),\n\t\tshaders: new AssetBucket<ShaderData>(),\n\t\tcustom: new AssetBucket<any>(),\n\t\tpacker: new TexPacker(SPRITE_ATLAS_WIDTH, SPRITE_ATLAS_HEIGHT),\n\t\t// if we finished initially loading all assets\n\t\tloaded: false,\n\t}\n\n\tconst game = {\n\n\t\t// general events\n\t\tevents: new EventHandler<{\n\t\t\tmouseMove: [],\n\t\t\tmouseDown: [MouseButton],\n\t\t\tmousePress: [MouseButton],\n\t\t\tmouseRelease: [MouseButton],\n\t\t\tcharInput: [string],\n\t\t\tkeyPress: [Key],\n\t\t\tkeyDown: [Key],\n\t\t\tkeyPressRepeat: [Key],\n\t\t\tkeyRelease: [Key],\n\t\t\ttouchStart: [Vec2, Touch],\n\t\t\ttouchMove: [Vec2, Touch],\n\t\t\ttouchEnd: [Vec2, Touch],\n\t\t\tgamepadButtonDown: [string],\n\t\t\tgamepadButtonPress: [string],\n\t\t\tgamepadButtonRelease: [string],\n\t\t\tgamepadStick: [string, Vec2],\n\t\t\tgamepadConnect: [Gamepad],\n\t\t\tgamepadDisconnect: [Gamepad],\n\t\t\tscroll: [Vec2],\n\t\t\tadd: [GameObj],\n\t\t\tdestroy: [GameObj],\n\t\t\tload: [],\n\t\t\tloading: [number],\n\t\t\terror: [Error],\n\t\t\tinput: [],\n\t\t\tframeEnd: [],\n\t\t\tresize: [],\n\t\t\tsceneLeave: [string],\n\t\t}>(),\n\n\t\t// object events\n\t\tobjEvents: new EventHandler(),\n\n\t\t// root game object\n\t\troot: make([]),\n\n\t\t// misc\n\t\tgravity: 0,\n\t\tscenes: {},\n\n\t\t// on screen log\n\t\tlogs: [],\n\n\t\t// camera\n\t\tcam: {\n\t\t\tpos: null,\n\t\t\tscale: new Vec2(1),\n\t\t\tangle: 0,\n\t\t\tshake: 0,\n\t\t\ttransform: new Mat4(),\n\t\t},\n\n\t}\n\n\t// TODO: accept Asset<T>?\n\t// wrap individual loaders with global loader counter, for stuff like progress bar\n\tfunction load<T>(prom: Promise<T>): Asset<T> {\n\t\treturn assets.custom.add(null, prom)\n\t}\n\n\t// get current load progress\n\tfunction loadProgress(): number {\n\t\tconst buckets = [\n\t\t\tassets.sprites,\n\t\t\tassets.sounds,\n\t\t\tassets.shaders,\n\t\t\tassets.fonts,\n\t\t\tassets.bitmapFonts,\n\t\t\tassets.custom,\n\t\t]\n\t\treturn buckets.reduce((n, bucket) => n + bucket.progress(), 0) / buckets.length\n\t}\n\n\t// global load path prefix\n\tfunction loadRoot(path?: string): string {\n\t\tif (path !== undefined) {\n\t\t\tassets.urlPrefix = path\n\t\t}\n\t\treturn assets.urlPrefix\n\t}\n\n\t// wrapper around fetch() that applies urlPrefix and basic error handling\n\tfunction fetchURL(path: string) {\n\t\tconst url = assets.urlPrefix + path\n\t\treturn fetch(url)\n\t\t\t.then((res) => {\n\t\t\t\tif (!res.ok) throw new KaboomError(`Failed to fetch \"${url}\"`)\n\t\t\t\treturn res\n\t\t\t})\n\t}\n\n\tfunction fetchJSON(path: string) {\n\t\treturn fetchURL(path).then((res) => res.json())\n\t}\n\n\tfunction fetchText(path: string) {\n\t\treturn fetchURL(path).then((res) => res.text())\n\t}\n\n\tfunction fetchArrayBuffer(path: string) {\n\t\treturn fetchURL(path).then((res) => res.arrayBuffer())\n\t}\n\n\t// wrapper around image loader to get a Promise\n\tfunction loadImg(src: string): Promise<HTMLImageElement> {\n\t\tconst img = new Image()\n\t\timg.crossOrigin = \"anonymous\"\n\t\timg.src = isDataURL(src) ? src : assets.urlPrefix + src\n\t\treturn new Promise<HTMLImageElement>((resolve, reject) => {\n\t\t\timg.onload = () => resolve(img)\n\t\t\timg.onerror = () => reject(new KaboomError(`Failed to load image from \"${src}\"`))\n\t\t})\n\t}\n\n\tfunction loadJSON(name, url) {\n\t\treturn assets.custom.add(name, fetchJSON(url))\n\t}\n\n\tclass FontData {\n\t\tfontface: FontFace\n\t\tfilter: TexFilter = DEF_FONT_FILTER\n\t\toutline: Outline | null = null\n\t\tconstructor(face: FontFace, opt: LoadFontOpt = {}) {\n\t\t\tthis.fontface = face\n\t\t\tthis.filter = opt.filter ?? DEF_FONT_FILTER\n\t\t\tif (opt.outline) {\n\t\t\t\tthis.outline = {\n\t\t\t\t\twidth: 1,\n\t\t\t\t\tcolor: rgb(0, 0, 0),\n\t\t\t\t}\n\t\t\t\tif (typeof opt.outline === \"number\") {\n\t\t\t\t\tthis.outline.width = opt.outline\n\t\t\t\t} else if (typeof opt.outline === \"object\") {\n\t\t\t\t\tif (opt.outline.width) this.outline.width = opt.outline.width\n\t\t\t\t\tif (opt.outline.color) this.outline.color = opt.outline.color\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// TODO: pass in null src to store opt for default fonts like \"monospace\"\n\tfunction loadFont(\n\t\tname: string,\n\t\tsrc: string | BinaryData,\n\t\topt: LoadFontOpt = {},\n\t): Asset<FontData> {\n\t\tconst font = new FontFace(name, typeof src === \"string\" ? `url(${src})` : src)\n\t\tdocument.fonts.add(font)\n\t\treturn assets.fonts.add(name, font.load().catch((err) => {\n\t\t\tthrow new KaboomError(`Failed to load font from \"${src}\": ${err}`)\n\t\t}).then((face) => new FontData(face, opt)))\n\t}\n\n\t// TODO: support outline\n\t// TODO: support LoadSpriteSrc\n\tfunction loadBitmapFont(\n\t\tname: string | null,\n\t\tsrc: string,\n\t\tgw: number,\n\t\tgh: number,\n\t\topt: LoadBitmapFontOpt = {},\n\t): Asset<BitmapFontData> {\n\t\treturn assets.bitmapFonts.add(name, loadImg(src)\n\t\t\t.then((img) => {\n\t\t\t\treturn makeFont(\n\t\t\t\t\tTexture.fromImage(img, opt),\n\t\t\t\t\tgw,\n\t\t\t\t\tgh,\n\t\t\t\t\topt.chars ?? ASCII_CHARS,\n\t\t\t\t)\n\t\t\t}),\n\t\t)\n\t}\n\n\t// get an array of frames based on configuration on how to slice the image\n\tfunction slice(x = 1, y = 1, dx = 0, dy = 0, w = 1, h = 1): Quad[] {\n\t\tconst frames = []\n\t\tconst qw = w / x\n\t\tconst qh = h / y\n\t\tfor (let j = 0; j < y; j++) {\n\t\t\tfor (let i = 0; i < x; i++) {\n\t\t\t\tframes.push(new Quad(\n\t\t\t\t\tdx + i * qw,\n\t\t\t\t\tdy + j * qh,\n\t\t\t\t\tqw,\n\t\t\t\t\tqh,\n\t\t\t\t))\n\t\t\t}\n\t\t}\n\t\treturn frames\n\t}\n\n\t// TODO: load synchronously if passed ImageSource\n\tfunction loadSpriteAtlas(\n\t\tsrc: LoadSpriteSrc,\n\t\tdata: SpriteAtlasData | string,\n\t): Asset<Record<string, SpriteData>> {\n\t\tif (typeof data === \"string\") {\n\t\t\treturn load(new Promise((res, rej) => {\n\t\t\t\tfetchJSON(data).then((json) => {\n\t\t\t\t\tloadSpriteAtlas(src, json).then(res).catch(rej)\n\t\t\t\t})\n\t\t\t}))\n\t\t}\n\t\treturn load(SpriteData.from(src).then((atlas) => {\n\t\t\tconst map = {}\n\t\t\tfor (const name in data) {\n\t\t\t\tconst info = data[name]\n\t\t\t\tconst quad = atlas.frames[0]\n\t\t\t\tconst w = SPRITE_ATLAS_WIDTH * quad.w\n\t\t\t\tconst h = SPRITE_ATLAS_HEIGHT * quad.h\n\t\t\t\tconst frames = info.frames ? info.frames.map((f) => new Quad(\n\t\t\t\t\tquad.x + (info.x + f.x) / w * quad.w,\n\t\t\t\t\tquad.y + (info.y + f.y) / h * quad.h,\n\t\t\t\t\tf.w / w * quad.w,\n\t\t\t\t\tf.h / h * quad.h,\n\t\t\t\t)) : slice(\n\t\t\t\t\tinfo.sliceX || 1,\n\t\t\t\t\tinfo.sliceY || 1,\n\t\t\t\t\tquad.x + info.x / w * quad.w,\n\t\t\t\t\tquad.y + info.y / h * quad.h,\n\t\t\t\t\tinfo.width / w * quad.w,\n\t\t\t\t\tinfo.height / h * quad.h,\n\t\t\t\t)\n\t\t\t\tconst spr = new SpriteData(atlas.tex, frames, info.anims)\n\t\t\t\tassets.sprites.addLoaded(name, spr)\n\t\t\t\tmap[name] = spr\n\t\t\t}\n\t\t\treturn map\n\t\t}))\n\t}\n\n\tfunction createSpriteSheet(\n\t\timages: ImageSource[],\n\t\topt: LoadSpriteOpt = {},\n\t): SpriteData {\n\t\tconst canvas = document.createElement(\"canvas\")\n\t\tconst width = images[0].width\n\t\tconst height = images[0].height\n\t\tcanvas.width = width * images.length\n\t\tcanvas.height = height\n\t\tconst ctx = canvas.getContext(\"2d\")\n\t\timages.forEach((img, i) => {\n\t\t\tif (img instanceof ImageData) {\n\t\t\t\tctx.putImageData(img, i * width, 0)\n\t\t\t} else {\n\t\t\t\tctx.drawImage(img, i * width, 0)\n\t\t\t}\n\t\t})\n\t\tconst merged = ctx.getImageData(0, 0, images.length * width, height)\n\t\treturn SpriteData.fromImage(merged, {\n\t\t\t...opt,\n\t\t\tsliceX: images.length,\n\t\t\tsliceY: 1,\n\t\t})\n\t}\n\n\t// load a sprite to asset manager\n\tfunction loadSprite(\n\t\tname: string | null,\n\t\tsrc: LoadSpriteSrc | LoadSpriteSrc[],\n\t\topt: LoadSpriteOpt = {\n\t\t\tsliceX: 1,\n\t\t\tsliceY: 1,\n\t\t\tanims: {},\n\t\t},\n\t): Asset<SpriteData> {\n\t\tif (Array.isArray(src)) {\n\t\t\tif (src.some((s) => typeof s === \"string\")) {\n\t\t\t\treturn assets.sprites.add(\n\t\t\t\t\tname,\n\t\t\t\t\tPromise.all(src.map((s) => {\n\t\t\t\t\t\treturn typeof s === \"string\" ? loadImg(s) : Promise.resolve(s)\n\t\t\t\t\t})).then((images) => createSpriteSheet(images, opt)),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\treturn assets.sprites.addLoaded(name, createSpriteSheet(src as ImageSource[], opt))\n\t\t\t}\n\t\t} else {\n\t\t\tif (typeof src === \"string\") {\n\t\t\t\treturn assets.sprites.add(name, SpriteData.from(src, opt))\n\t\t\t} else {\n\t\t\t\treturn assets.sprites.addLoaded(name, SpriteData.fromImage(src, opt))\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction loadPedit(name: string | null, src: string | PeditFile): Asset<SpriteData> {\n\n\t\t// eslint-disable-next-line\n\t\treturn assets.sprites.add(name, new Promise(async (resolve) => {\n\n\t\t\tconst data = typeof src === \"string\" ? await fetchJSON(src) : src\n\t\t\tconst images = await Promise.all(data.frames.map(loadImg))\n\t\t\tconst canvas = document.createElement(\"canvas\")\n\t\t\tcanvas.width = data.width\n\t\t\tcanvas.height = data.height * data.frames.length\n\n\t\t\tconst ctx = canvas.getContext(\"2d\")\n\n\t\t\timages.forEach((img: HTMLImageElement, i) => {\n\t\t\t\tctx.drawImage(img, 0, i * data.height)\n\t\t\t})\n\n\t\t\tconst spr = await loadSprite(null, canvas, {\n\t\t\t\tsliceY: data.frames.length,\n\t\t\t\tanims: data.anims,\n\t\t\t})\n\n\t\t\tresolve(spr)\n\n\t\t}))\n\n\t}\n\n\tfunction loadAseprite(\n\t\tname: string | null,\n\t\timgSrc: LoadSpriteSrc,\n\t\tjsonSrc: string,\n\t): Asset<SpriteData> {\n\t\tif (typeof imgSrc === \"string\" && !jsonSrc) {\n\t\t\tjsonSrc = imgSrc.replace(new RegExp(`${getExt(imgSrc)}$`), \"json\")\n\t\t}\n\t\tconst resolveJSON = typeof jsonSrc === \"string\"\n\t\t\t? fetchJSON(jsonSrc)\n\t\t\t: Promise.resolve(jsonSrc)\n\t\treturn assets.sprites.add(name, resolveJSON.then((data) => {\n\t\t\tconst size = data.meta.size\n\t\t\tconst frames = data.frames.map((f: any) => {\n\t\t\t\treturn new Quad(\n\t\t\t\t\tf.frame.x / size.w,\n\t\t\t\t\tf.frame.y / size.h,\n\t\t\t\t\tf.frame.w / size.w,\n\t\t\t\t\tf.frame.h / size.h,\n\t\t\t\t)\n\t\t\t})\n\t\t\tconst anims = {}\n\t\t\tfor (const anim of data.meta.frameTags) {\n\t\t\t\tif (anim.from === anim.to) {\n\t\t\t\t\tanims[anim.name] = anim.from\n\t\t\t\t} else {\n\t\t\t\t\tanims[anim.name] = {\n\t\t\t\t\t\tfrom: anim.from,\n\t\t\t\t\t\tto: anim.to,\n\t\t\t\t\t\tspeed: 10,\n\t\t\t\t\t\tloop: true,\n\t\t\t\t\t\tpingpong: anim.direction === \"pingpong\",\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn SpriteData.from(imgSrc, {\n\t\t\t\tframes: frames,\n\t\t\t\tanims: anims,\n\t\t\t})\n\t\t}))\n\t}\n\n\tfunction loadShader(\n\t\tname: string | null,\n\t\tvert?: string,\n\t\tfrag?: string,\n\t) {\n\t\treturn assets.shaders.addLoaded(name, makeShader(vert, frag))\n\t}\n\n\tfunction loadShaderURL(\n\t\tname: string | null,\n\t\tvert?: string,\n\t\tfrag?: string,\n\t): Asset<ShaderData> {\n\t\tconst resolveUrl = (url?: string) =>\n\t\t\turl\n\t\t\t\t? fetchText(url)\n\t\t\t\t: Promise.resolve(null)\n\t\tconst load = Promise.all([resolveUrl(vert), resolveUrl(frag)])\n\t\t\t.then(([vcode, fcode]: [string | null, string | null]) => {\n\t\t\t\treturn makeShader(vcode, fcode)\n\t\t\t})\n\t\treturn assets.shaders.add(name, load)\n\t}\n\n\t// TODO: allow stream big audio\n\t// load a sound to asset manager\n\tfunction loadSound(\n\t\tname: string | null,\n\t\tsrc: string | ArrayBuffer,\n\t): Asset<SoundData> {\n\t\treturn assets.sounds.add(\n\t\t\tname,\n\t\t\ttypeof src === \"string\"\n\t\t\t\t? SoundData.fromURL(src)\n\t\t\t\t: SoundData.fromArrayBuffer(src),\n\t\t)\n\t}\n\n\tfunction loadBean(name: string = \"bean\"): Asset<SpriteData> {\n\t\treturn loadSprite(name, beanSpriteSrc)\n\t}\n\n\tfunction getSprite(handle: string): Asset<SpriteData> | void {\n\t\treturn assets.sprites.get(handle)\n\t}\n\n\tfunction getSound(handle: string): Asset<SoundData> | void {\n\t\treturn assets.sounds.get(handle)\n\t}\n\n\tfunction getFont(handle: string): Asset<FontData> | void {\n\t\treturn assets.fonts.get(handle)\n\t}\n\n\tfunction getBitmapFont(handle: string): Asset<BitmapFontData> | void {\n\t\treturn assets.bitmapFonts.get(handle)\n\t}\n\n\tfunction getShader(handle: string): Asset<ShaderData> | void {\n\t\treturn assets.shaders.get(handle)\n\t}\n\n\tfunction getAsset(handle: string): Asset<any> | void {\n\t\treturn assets.custom.get(handle)\n\t}\n\n\tfunction resolveSprite(\n\t\tsrc: DrawSpriteOpt[\"sprite\"],\n\t): Asset<SpriteData> | null {\n\t\tif (typeof src === \"string\") {\n\t\t\tconst spr = getSprite(src)\n\t\t\tif (spr) {\n\t\t\t\t// if it's already loaded or being loading, return it\n\t\t\t\treturn spr\n\t\t\t} else if (loadProgress() < 1) {\n\t\t\t\t// if there's any other ongoing loading task we return empty and don't error yet\n\t\t\t\treturn null\n\t\t\t} else {\n\t\t\t\t// if all other assets are loaded and we still haven't found this sprite, throw\n\t\t\t\tthrow new KaboomError(`Sprite not found: ${src}`)\n\t\t\t}\n\t\t} else if (src instanceof SpriteData) {\n\t\t\treturn Asset.loaded(src)\n\t\t} else if (src instanceof Asset) {\n\t\t\treturn src\n\t\t} else {\n\t\t\tthrow new KaboomError(`Invalid sprite: ${src}`)\n\t\t}\n\t}\n\n\tfunction resolveSound(\n\t\tsrc: Parameters<typeof play>[0],\n\t): Asset<SoundData> | null {\n\t\tif (typeof src === \"string\") {\n\t\t\tconst snd = getSound(src)\n\t\t\tif (snd) {\n\t\t\t\treturn snd\n\t\t\t} else if (loadProgress() < 1) {\n\t\t\t\treturn null\n\t\t\t} else {\n\t\t\t\tthrow new KaboomError(`Sound not found: ${src}`)\n\t\t\t}\n\t\t} else if (src instanceof SoundData) {\n\t\t\treturn Asset.loaded(src)\n\t\t} else if (src instanceof Asset) {\n\t\t\treturn src\n\t\t} else {\n\t\t\tthrow new KaboomError(`Invalid sound: ${src}`)\n\t\t}\n\t}\n\n\tfunction resolveShader(\n\t\tsrc: RenderProps[\"shader\"],\n\t): ShaderData | Asset<ShaderData> | null {\n\t\tif (!src) {\n\t\t\treturn gfx.defShader\n\t\t}\n\t\tif (typeof src === \"string\") {\n\t\t\tconst shader = getShader(src)\n\t\t\tif (shader) {\n\t\t\t\treturn shader.data ?? shader\n\t\t\t} else if (loadProgress() < 1) {\n\t\t\t\treturn null\n\t\t\t} else {\n\t\t\t\tthrow new KaboomError(`Shader not found: ${src}`)\n\t\t\t}\n\t\t} else if (src instanceof Asset) {\n\t\t\treturn src.data ? src.data : src\n\t\t}\n\t\t// TODO: check type\n\t\t// @ts-ignore\n\t\treturn src\n\t}\n\n\tfunction resolveFont(\n\t\tsrc: DrawTextOpt[\"font\"],\n\t):\n\t\t| FontData\n\t\t| Asset<FontData>\n\t\t| BitmapFontData\n\t\t| Asset<BitmapFontData>\n\t\t| string\n\t\t| void\n\t{\n\t\tif (!src) {\n\t\t\treturn resolveFont(gopt.font ?? DEF_FONT)\n\t\t}\n\t\tif (typeof src === \"string\") {\n\t\t\tconst bfont = getBitmapFont(src)\n\t\t\tconst font = getFont(src)\n\t\t\tif (bfont) {\n\t\t\t\treturn bfont.data ?? bfont\n\t\t\t} else if (font) {\n\t\t\t\treturn font.data ?? font\n\t\t\t} else if (document.fonts.check(`${DEF_TEXT_CACHE_SIZE}px ${src}`)) {\n\t\t\t\treturn src\n\t\t\t} else if (loadProgress() < 1) {\n\t\t\t\treturn null\n\t\t\t} else {\n\t\t\t\tthrow new KaboomError(`Font not found: ${src}`)\n\t\t\t}\n\t\t} else if (src instanceof Asset) {\n\t\t\treturn src.data ? src.data : src\n\t\t}\n\t\t// TODO: check type\n\t\t// @ts-ignore\n\t\treturn src\n\t}\n\n\t// get / set master volume\n\tfunction volume(v?: number): number {\n\t\tif (v !== undefined) {\n\t\t\taudio.masterNode.gain.value = v\n\t\t}\n\t\treturn audio.masterNode.gain.value\n\t}\n\n\t// TODO: method to completely destory audio?\n\t// TODO: time() not correct when looped over or ended\n\t// TODO: onEnd() not working\n\t// plays a sound, returns a control handle\n\tfunction play(\n\t\tsrc: string | SoundData | Asset<SoundData>,\n\t\topt: AudioPlayOpt = {},\n\t): AudioPlay {\n\n\t\tconst ctx = audio.ctx\n\t\tlet paused = opt.paused ?? false\n\t\tlet srcNode = ctx.createBufferSource()\n\t\tconst onEndEvents = new Event()\n\t\tconst gainNode = ctx.createGain()\n\t\tconst pos = opt.seek ?? 0\n\t\tlet startTime = 0\n\t\tlet stopTime = 0\n\t\tlet started = false\n\n\t\tsrcNode.loop = Boolean(opt.loop)\n\t\tsrcNode.detune.value = opt.detune ?? 0\n\t\tsrcNode.playbackRate.value = opt.speed ?? 1\n\t\tsrcNode.connect(gainNode)\n\t\tsrcNode.onended = () => {\n\t\t\tif (getTime() >= srcNode.buffer?.duration ?? Number.POSITIVE_INFINITY) {\n\t\t\t\tonEndEvents.trigger()\n\t\t\t}\n\t\t}\n\t\tgainNode.connect(audio.masterNode)\n\t\tgainNode.gain.value = opt.volume ?? 1\n\n\t\tconst start = (data: SoundData) => {\n\t\t\tsrcNode.buffer = data.buf\n\t\t\tif (!paused) {\n\t\t\t\tstartTime = ctx.currentTime\n\t\t\t\tsrcNode.start(0, pos)\n\t\t\t\tstarted = true\n\t\t\t}\n\t\t}\n\n\t\tconst snd = resolveSound(src)\n\n\t\tif (snd instanceof Asset) {\n\t\t\tsnd.onLoad(start)\n\t\t}\n\n\t\tconst getTime = () => {\n\t\t\tif (!srcNode.buffer) return 0\n\t\t\tconst t = paused\n\t\t\t\t? stopTime - startTime\n\t\t\t\t: ctx.currentTime - startTime\n\t\t\tconst d = srcNode.buffer.duration\n\t\t\treturn srcNode.loop ? t % d : Math.min(t, d)\n\t\t}\n\n\t\tconst cloneNode = (oldNode: AudioBufferSourceNode) => {\n\t\t\tconst newNode = ctx.createBufferSource()\n\t\t\tnewNode.buffer = oldNode.buffer\n\t\t\tnewNode.loop = oldNode.loop\n\t\t\tnewNode.playbackRate.value = oldNode.playbackRate.value\n\t\t\tnewNode.detune.value = oldNode.detune.value\n\t\t\tnewNode.onended = oldNode.onended\n\t\t\tnewNode.connect(gainNode)\n\t\t\treturn newNode\n\t\t}\n\n\t\treturn {\n\n\t\t\tstop() {\n\t\t\t\tthis.paused = true\n\t\t\t\tthis.seek(0)\n\t\t\t},\n\n\t\t\tset paused(p: boolean) {\n\t\t\t\tif (paused === p) return\n\t\t\t\tpaused = p\n\t\t\t\tif (p) {\n\t\t\t\t\tif (started) {\n\t\t\t\t\t\tsrcNode.stop()\n\t\t\t\t\t\tstarted = false\n\t\t\t\t\t}\n\t\t\t\t\tstopTime = ctx.currentTime\n\t\t\t\t} else {\n\t\t\t\t\tsrcNode = cloneNode(srcNode)\n\t\t\t\t\tconst pos = stopTime - startTime\n\t\t\t\t\tsrcNode.start(0, pos)\n\t\t\t\t\tstarted = true\n\t\t\t\t\tstartTime = ctx.currentTime - pos\n\t\t\t\t\tstopTime = 0\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget paused() {\n\t\t\t\treturn paused\n\t\t\t},\n\n\t\t\tplay(time: number = 0) {\n\t\t\t\tthis.seek(time)\n\t\t\t\tthis.paused = false\n\t\t\t},\n\n\t\t\tseek(time: number) {\n\t\t\t\tif (!srcNode.buffer?.duration) return\n\t\t\t\tif (time > srcNode.buffer.duration) return\n\t\t\t\tif (paused) {\n\t\t\t\t\tsrcNode = cloneNode(srcNode)\n\t\t\t\t\tstartTime = stopTime - time\n\t\t\t\t} else {\n\t\t\t\t\tsrcNode.stop()\n\t\t\t\t\tsrcNode = cloneNode(srcNode)\n\t\t\t\t\tstartTime = ctx.currentTime - time\n\t\t\t\t\tsrcNode.start(0, time)\n\t\t\t\t\tstarted = true\n\t\t\t\t\tstopTime = 0\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// TODO: affect time()\n\t\t\tset speed(val: number) {\n\t\t\t\tsrcNode.playbackRate.value = val\n\t\t\t},\n\n\t\t\tget speed() {\n\t\t\t\treturn srcNode.playbackRate.value\n\t\t\t},\n\n\t\t\tset detune(val: number) {\n\t\t\t\tsrcNode.detune.value = val\n\t\t\t},\n\n\t\t\tget detune() {\n\t\t\t\treturn srcNode.detune.value\n\t\t\t},\n\n\t\t\tset volume(val: number) {\n\t\t\t\tgainNode.gain.value = Math.max(val, 0)\n\t\t\t},\n\n\t\t\tget volume() {\n\t\t\t\treturn gainNode.gain.value\n\t\t\t},\n\n\t\t\tset loop(l: boolean) {\n\t\t\t\tsrcNode.loop = l\n\t\t\t},\n\n\t\t\tget loop() {\n\t\t\t\treturn srcNode.loop\n\t\t\t},\n\n\t\t\tduration(): number {\n\t\t\t\treturn srcNode.buffer?.duration ?? 0\n\t\t\t},\n\n\t\t\ttime(): number {\n\t\t\t\treturn getTime() % this.duration()\n\t\t\t},\n\n\t\t\tonEnd(action: () => void) {\n\t\t\t\treturn onEndEvents.add(action)\n\t\t\t},\n\n\t\t\tthen(action: () => void) {\n\t\t\t\treturn this.onEnd(action)\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\t// core kaboom logic\n\tfunction burp(opt?: AudioPlayOpt): AudioPlay {\n\t\treturn play(audio.burpSnd, opt)\n\t}\n\n\ttype DrawTextureOpt = RenderProps & {\n\t\ttex: Texture,\n\t\twidth?: number,\n\t\theight?: number,\n\t\ttiled?: boolean,\n\t\tflipX?: boolean,\n\t\tflipY?: boolean,\n\t\tquad?: Quad,\n\t\tanchor?: Anchor | Vec2,\n\t}\n\n\tfunction makeShader(\n\t\tvertSrc: string | null = DEF_VERT,\n\t\tfragSrc: string | null = DEF_FRAG,\n\t): GfxShader {\n\n\t\tconst vcode = VERT_TEMPLATE.replace(\"{{user}}\", vertSrc ?? DEF_VERT)\n\t\tconst fcode = FRAG_TEMPLATE.replace(\"{{user}}\", fragSrc ?? DEF_FRAG)\n\t\tconst vertShader = gl.createShader(gl.VERTEX_SHADER)\n\t\tconst fragShader = gl.createShader(gl.FRAGMENT_SHADER)\n\n\t\tgl.shaderSource(vertShader, vcode)\n\t\tgl.shaderSource(fragShader, fcode)\n\t\tgl.compileShader(vertShader)\n\t\tgl.compileShader(fragShader)\n\n\t\tconst prog = gl.createProgram()\n\n\t\tgc.push(() => gl.deleteProgram(prog))\n\t\tgl.attachShader(prog, vertShader)\n\t\tgl.attachShader(prog, fragShader)\n\n\t\tgl.bindAttribLocation(prog, 0, \"a_pos\")\n\t\tgl.bindAttribLocation(prog, 1, \"a_uv\")\n\t\tgl.bindAttribLocation(prog, 2, \"a_color\")\n\n\t\tgl.linkProgram(prog)\n\n\t\tif (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {\n\n\t\t\tconst formatShaderError = (msg: string) => {\n\t\t\t\tconst FMT = /^ERROR:\\s0:(?<line>\\d+):\\s(?<msg>.+)/\n\t\t\t\tconst match = msg.match(FMT)\n\t\t\t\treturn {\n\t\t\t\t\tline: Number(match.groups.line),\n\t\t\t\t\t// seem to be a \\n\\0 at the end of error messages, causing unwanted line break\n\t\t\t\t\tmsg: match.groups.msg.replace(/\\n\\0$/, \"\"),\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst vertError = gl.getShaderInfoLog(vertShader)\n\t\t\tconst fragError = gl.getShaderInfoLog(fragShader)\n\t\t\tlet msg = \"\"\n\n\t\t\tif (vertError) {\n\t\t\t\tconst err = formatShaderError(vertError)\n\t\t\t\tmsg += `Vertex shader line ${err.line - 14}: ${err.msg}`\n\t\t\t}\n\n\t\t\tif (fragError) {\n\t\t\t\tconst err = formatShaderError(fragError)\n\t\t\t\tmsg += `Fragment shader line ${err.line - 14}: ${err.msg}`\n\t\t\t}\n\n\t\t\tthrow new KaboomError(msg)\n\n\t\t}\n\n\t\tgl.deleteShader(vertShader)\n\t\tgl.deleteShader(fragShader)\n\n\t\treturn {\n\n\t\t\tbind() {\n\t\t\t\tgl.useProgram(prog)\n\t\t\t},\n\n\t\t\tunbind() {\n\t\t\t\tgl.useProgram(null)\n\t\t\t},\n\n\t\t\tfree() {\n\t\t\t\tgl.deleteProgram(prog)\n\t\t\t},\n\n\t\t\t// TODO: support vec3 and vec4\n\t\t\tsend(uniform: Uniform) {\n\t\t\t\tfor (const name in uniform) {\n\t\t\t\t\tconst val = uniform[name]\n\t\t\t\t\tconst loc = gl.getUniformLocation(prog, name)\n\t\t\t\t\tif (typeof val === \"number\") {\n\t\t\t\t\t\tgl.uniform1f(loc, val)\n\t\t\t\t\t} else if (val instanceof Mat4) {\n\t\t\t\t\t\tgl.uniformMatrix4fv(loc, false, new Float32Array(val.m))\n\t\t\t\t\t} else if (val instanceof Color) {\n\t\t\t\t\t\t// TODO: opacity?\n\t\t\t\t\t\tgl.uniform3f(loc, val.r, val.g, val.b)\n\t\t\t\t\t} else if (val instanceof Vec2) {\n\t\t\t\t\t\tgl.uniform2f(loc, val.x, val.y)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction makeFont(\n\t\ttex: Texture,\n\t\tgw: number,\n\t\tgh: number,\n\t\tchars: string,\n\t): GfxFont {\n\n\t\tconst cols = tex.width / gw\n\t\tconst map: Record<string, Quad> = {}\n\t\tconst charMap = chars.split(\"\").entries()\n\n\t\tfor (const [i, ch] of charMap) {\n\t\t\tmap[ch] = new Quad(\n\t\t\t\t(i % cols) * gw,\n\t\t\t\tMath.floor(i / cols) * gh,\n\t\t\t\tgw,\n\t\t\t\tgh,\n\t\t\t)\n\t\t}\n\n\t\treturn {\n\t\t\ttex: tex,\n\t\t\tmap: map,\n\t\t\tsize: gh,\n\t\t}\n\n\t}\n\n\t// TODO: expose\n\tfunction drawRaw(\n\t\tverts: Vertex[],\n\t\tindices: number[],\n\t\tfixed: boolean,\n\t\ttex: Texture = gfx.defTex,\n\t\tshaderSrc: RenderProps[\"shader\"] = gfx.defShader,\n\t\tuniform: Uniform = {},\n\t) {\n\n\t\tconst shader = resolveShader(shaderSrc)\n\n\t\tif (!shader || shader instanceof Asset) {\n\t\t\treturn\n\t\t}\n\n\t\t// flush on texture / shader change and overflow\n\t\tif (\n\t\t\ttex !== gfx.curTex\n\t\t\t|| shader !== gfx.curShader\n\t\t\t|| !deepEq(gfx.curUniform, uniform)\n\t\t\t|| gfx.vqueue.length + verts.length * STRIDE > MAX_BATCHED_VERTS\n\t\t\t|| gfx.iqueue.length + indices.length > MAX_BATCHED_INDICES\n\t\t) {\n\t\t\tflush()\n\t\t}\n\n\t\tconst transform = (gfx.fixed || fixed)\n\t\t\t? gfx.transform\n\t\t\t: game.cam.transform.mult(gfx.transform)\n\n\t\tfor (const v of verts) {\n\t\t\t// normalized world space coordinate [-1.0 ~ 1.0]\n\t\t\tconst pt = screen2ndc(transform.multVec2(v.pos))\n\t\t\tgfx.vqueue.push(\n\t\t\t\tpt.x, pt.y,\n\t\t\t\tv.uv.x, v.uv.y,\n\t\t\t\tv.color.r / 255, v.color.g / 255, v.color.b / 255, v.opacity,\n\t\t\t)\n\t\t}\n\n\t\tfor (const i of indices) {\n\t\t\tgfx.iqueue.push(i + gfx.vqueue.length / STRIDE - verts.length)\n\t\t}\n\n\t\tgfx.curTex = tex\n\t\tgfx.curShader = shader\n\t\tgfx.curUniform = uniform\n\n\t}\n\n\t// draw all batched shapes\n\tfunction flush() {\n\n\t\tif (\n\t\t\t!gfx.curTex\n\t\t\t|| !gfx.curShader\n\t\t\t|| gfx.vqueue.length === 0\n\t\t\t|| gfx.iqueue.length === 0\n\t\t) {\n\t\t\treturn\n\t\t}\n\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, gfx.vbuf)\n\t\tgl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array(gfx.vqueue))\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gfx.ibuf)\n\t\tgl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, new Uint16Array(gfx.iqueue))\n\t\tgfx.curShader.bind()\n\t\tgfx.curShader.send(gfx.curUniform)\n\t\tgfx.curTex.bind()\n\t\tgl.drawElements(gl.TRIANGLES, gfx.iqueue.length, gl.UNSIGNED_SHORT, 0)\n\t\tgfx.curTex.unbind()\n\t\tgfx.curShader.unbind()\n\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null)\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n\n\t\tgfx.vqueue.length = 0\n\t\tgfx.iqueue.length = 0\n\n\t\tgfx.drawCalls++\n\n\t}\n\n\t// start a rendering frame, reset some states\n\tfunction frameStart() {\n\n\t\t// clear backbuffer\n\t\tgl.clear(gl.COLOR_BUFFER_BIT)\n\t\tgfx.frameBuffer.bind()\n\t\tgl.viewport(0, 0, gfx.frameBuffer.width, gfx.frameBuffer.height)\n\t\t// clear framebuffer\n\t\tgl.clear(gl.COLOR_BUFFER_BIT)\n\n\t\tif (!gfx.bgColor) {\n\t\t\tdrawUnscaled(() => {\n\t\t\t\tdrawUVQuad({\n\t\t\t\t\twidth: width(),\n\t\t\t\t\theight: height(),\n\t\t\t\t\tquad: new Quad(\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\twidth() / BG_GRID_SIZE,\n\t\t\t\t\t\theight() / BG_GRID_SIZE,\n\t\t\t\t\t),\n\t\t\t\t\ttex: gfx.bgTex,\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t\tgfx.drawCalls = 0\n\t\tgfx.fixed = false\n\t\tgfx.transformStack.length = 0\n\t\tgfx.transform = new Mat4()\n\n\t}\n\n\tfunction usePostEffect(name: string, uniform?: Uniform | (() => Uniform)) {\n\t\tgfx.postShader = name\n\t\tgfx.postShaderUniform = uniform ?? null\n\t}\n\n\tfunction frameEnd() {\n\n\t\t// TODO: don't render debug UI with framebuffer\n\t\t// TODO: polish framebuffer rendering / sizing issues\n\t\tflush()\n\t\tgfx.lastDrawCalls = gfx.drawCalls\n\t\tgfx.frameBuffer.unbind()\n\t\tgl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight)\n\n\t\tconst ow = gfx.width\n\t\tconst oh = gfx.height\n\t\tgfx.width = gl.drawingBufferWidth / pixelDensity\n\t\tgfx.height = gl.drawingBufferHeight / pixelDensity\n\n\t\tdrawTexture({\n\t\t\tflipY: true,\n\t\t\ttex: gfx.frameBuffer.tex,\n\t\t\tpos: new Vec2(gfx.viewport.x, gfx.viewport.y),\n\t\t\twidth: gfx.viewport.width,\n\t\t\theight: gfx.viewport.height,\n\t\t\tshader: gfx.postShader,\n\t\t\tuniform: typeof gfx.postShaderUniform === \"function\"\n\t\t\t\t? gfx.postShaderUniform()\n\t\t\t\t: gfx.postShaderUniform,\n\t\t\tfixed: true,\n\t\t})\n\n\t\tflush()\n\t\tgfx.width = ow\n\t\tgfx.height = oh\n\n\t}\n\n\t// convert a screen space coordinate to webgl normalized device coordinate\n\tfunction screen2ndc(pt: Vec2): Vec2 {\n\t\treturn new Vec2(\n\t\t\tpt.x / width() * 2 - 1,\n\t\t\t-pt.y / height() * 2 + 1,\n\t\t)\n\t}\n\n\tfunction pushMatrix(m: Mat4) {\n\t\tgfx.transform = m.clone()\n\t}\n\n\tfunction pushTranslate(...args: Vec2Args) {\n\t\tif (args[0] === undefined) return\n\t\tconst p = vec2(...args)\n\t\tif (p.x === 0 && p.y === 0) return\n\t\tgfx.transform.translate(p)\n\t}\n\n\tfunction pushScale(...args: Vec2Args) {\n\t\tif (args[0] === undefined) return\n\t\tconst p = vec2(...args)\n\t\tif (p.x === 1 && p.y === 1) return\n\t\tgfx.transform.scale(p)\n\t}\n\n\tfunction pushRotate(a: number) {\n\t\tif (!a) return\n\t\tgfx.transform.rotate(a)\n\t}\n\n\tfunction pushTransform() {\n\t\tgfx.transformStack.push(gfx.transform.clone())\n\t}\n\n\tfunction popTransform() {\n\t\tif (gfx.transformStack.length > 0) {\n\t\t\tgfx.transform = gfx.transformStack.pop()\n\t\t}\n\t}\n\n\t// draw a uv textured quad\n\tfunction drawUVQuad(opt: DrawUVQuadOpt) {\n\n\t\tif (opt.width === undefined || opt.height === undefined) {\n\t\t\tthrow new KaboomError(\"drawUVQuad() requires property \\\"width\\\" and \\\"height\\\".\")\n\t\t}\n\n\t\tif (opt.width <= 0 || opt.height <= 0) {\n\t\t\treturn\n\t\t}\n\n\t\tconst w = opt.width\n\t\tconst h = opt.height\n\t\tconst anchor = anchorPt(opt.anchor || DEF_ANCHOR)\n\t\tconst offset = anchor.scale(new Vec2(w, h).scale(-0.5))\n\t\tconst q = opt.quad || new Quad(0, 0, 1, 1)\n\t\tconst color = opt.color || rgb(255, 255, 255)\n\t\tconst opacity = opt.opacity ?? 1\n\n\t\t// apply uv padding to avoid artifacts\n\t\tconst uvPadX = opt.tex ? UV_PAD / opt.tex.width : 0\n\t\tconst uvPadY = opt.tex ? UV_PAD / opt.tex.height : 0\n\t\tconst qx = q.x + uvPadX\n\t\tconst qy = q.y + uvPadY\n\t\tconst qw = q.w - uvPadX * 2\n\t\tconst qh = q.h - uvPadY * 2\n\n\t\tpushTransform()\n\t\tpushTranslate(opt.pos)\n\t\tpushRotate(opt.angle)\n\t\tpushScale(opt.scale)\n\t\tpushTranslate(offset)\n\n\t\tdrawRaw([\n\t\t\t{\n\t\t\t\tpos: new Vec2(-w / 2, h / 2),\n\t\t\t\tuv: new Vec2(opt.flipX ? qx + qw : qx, opt.flipY ? qy : qy + qh),\n\t\t\t\tcolor: color,\n\t\t\t\topacity: opacity,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpos: new Vec2(-w / 2, -h / 2),\n\t\t\t\tuv: new Vec2(opt.flipX ? qx + qw : qx, opt.flipY ? qy + qh : qy),\n\t\t\t\tcolor: color,\n\t\t\t\topacity: opacity,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpos: new Vec2(w / 2, -h / 2),\n\t\t\t\tuv: new Vec2(opt.flipX ? qx : qx + qw, opt.flipY ? qy + qh : qy),\n\t\t\t\tcolor: color,\n\t\t\t\topacity: opacity,\n\t\t\t},\n\t\t\t{\n\t\t\t\tpos: new Vec2(w / 2, h / 2),\n\t\t\t\tuv: new Vec2(opt.flipX ? qx : qx + qw, opt.flipY ? qy : qy + qh),\n\t\t\t\tcolor: color,\n\t\t\t\topacity: opacity,\n\t\t\t},\n\t\t], [0, 1, 3, 1, 2, 3], opt.fixed, opt.tex, opt.shader, opt.uniform)\n\n\t\tpopTransform()\n\n\t}\n\n\t// TODO: clean\n\tfunction drawTexture(opt: DrawTextureOpt) {\n\n\t\tif (!opt.tex) {\n\t\t\tthrow new KaboomError(\"drawTexture() requires property \\\"tex\\\".\")\n\t\t}\n\n\t\tconst q = opt.quad ?? new Quad(0, 0, 1, 1)\n\t\tconst w = opt.tex.width * q.w\n\t\tconst h = opt.tex.height * q.h\n\t\tconst scale = new Vec2(1)\n\n\t\tif (opt.tiled) {\n\n\t\t\t// TODO: draw fract\n\t\t\tconst repX = Math.ceil((opt.width || w) / w)\n\t\t\tconst repY = Math.ceil((opt.height || h) / h)\n\t\t\tconst anchor = anchorPt(opt.anchor || DEF_ANCHOR).add(new Vec2(1, 1)).scale(0.5)\n\t\t\tconst offset = anchor.scale(repX * w, repY * h)\n\n\t\t\t// TODO: rotation\n\t\t\tfor (let i = 0; i < repX; i++) {\n\t\t\t\tfor (let j = 0; j < repY; j++) {\n\t\t\t\t\tdrawUVQuad(Object.assign({}, opt, {\n\t\t\t\t\t\tpos: (opt.pos || new Vec2(0)).add(new Vec2(w * i, h * j)).sub(offset),\n\t\t\t\t\t\tscale: scale.scale(opt.scale || new Vec2(1)),\n\t\t\t\t\t\ttex: opt.tex,\n\t\t\t\t\t\tquad: q,\n\t\t\t\t\t\twidth: w,\n\t\t\t\t\t\theight: h,\n\t\t\t\t\t\tanchor: \"topleft\",\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\n\t\t\t// TODO: should this ignore scale?\n\t\t\tif (opt.width && opt.height) {\n\t\t\t\tscale.x = opt.width / w\n\t\t\t\tscale.y = opt.height / h\n\t\t\t} else if (opt.width) {\n\t\t\t\tscale.x = opt.width / w\n\t\t\t\tscale.y = scale.x\n\t\t\t} else if (opt.height) {\n\t\t\t\tscale.y = opt.height / h\n\t\t\t\tscale.x = scale.y\n\t\t\t}\n\n\t\t\tdrawUVQuad(Object.assign({}, opt, {\n\t\t\t\tscale: scale.scale(opt.scale || new Vec2(1)),\n\t\t\t\ttex: opt.tex,\n\t\t\t\tquad: q,\n\t\t\t\twidth: w,\n\t\t\t\theight: h,\n\t\t\t}))\n\n\t\t}\n\n\t}\n\n\tfunction drawSprite(opt: DrawSpriteOpt) {\n\n\t\tif (!opt.sprite) {\n\t\t\tthrow new KaboomError(\"drawSprite() requires property \\\"sprite\\\"\")\n\t\t}\n\n\t\t// TODO: slow\n\t\tconst spr = resolveSprite(opt.sprite)\n\n\t\tif (!spr || !spr.data) {\n\t\t\treturn\n\t\t}\n\n\t\tconst q = spr.data.frames[opt.frame ?? 0]\n\n\t\tif (!q) {\n\t\t\tthrow new KaboomError(`Frame not found: ${opt.frame ?? 0}`)\n\t\t}\n\n\t\tdrawTexture(Object.assign({}, opt, {\n\t\t\ttex: spr.data.tex,\n\t\t\tquad: q.scale(opt.quad ?? new Quad(0, 0, 1, 1)),\n\t\t}))\n\n\t}\n\n\t// generate vertices to form an arc\n\tfunction getArcPts(\n\t\tpos: Vec2,\n\t\tradiusX: number,\n\t\tradiusY: number,\n\t\tstart: number,\n\t\tend: number,\n\t\tres: number = 1,\n\t): Vec2[] {\n\n\t\t// normalize and turn start and end angles to radians\n\t\tstart = deg2rad(start % 360)\n\t\tend = deg2rad(end % 360)\n\t\tif (end <= start) end += Math.PI * 2\n\n\t\tconst pts = []\n\t\tconst nverts = Math.ceil((end - start) / deg2rad(8) * res)\n\t\tconst step = (end - start) / nverts\n\n\t\t// calculate vertices\n\t\tfor (let a = start; a < end; a += step) {\n\t\t\tpts.push(pos.add(radiusX * Math.cos(a), radiusY * Math.sin(a)))\n\t\t}\n\n\t\tpts.push(pos.add(radiusX * Math.cos(end), radiusY * Math.sin(end)))\n\n\t\treturn pts\n\n\t}\n\n\tfunction drawRect(opt: DrawRectOpt) {\n\n\t\tif (opt.width === undefined || opt.height === undefined) {\n\t\t\tthrow new KaboomError(\"drawRect() requires property \\\"width\\\" and \\\"height\\\".\")\n\t\t}\n\n\t\tif (opt.width <= 0 || opt.height <= 0) {\n\t\t\treturn\n\t\t}\n\n\t\tconst w = opt.width\n\t\tconst h = opt.height\n\t\tconst anchor = anchorPt(opt.anchor || DEF_ANCHOR).add(1, 1)\n\t\tconst offset = anchor.scale(new Vec2(w, h).scale(-0.5))\n\n\t\tlet pts = [\n\t\t\tnew Vec2(0, 0),\n\t\t\tnew Vec2(w, 0),\n\t\t\tnew Vec2(w, h),\n\t\t\tnew Vec2(0, h),\n\t\t]\n\n\t\t// TODO: gradient for rounded rect\n\t\t// TODO: drawPolygon should handle generic rounded corners\n\t\tif (opt.radius) {\n\n\t\t\t// maxium radius is half the shortest side\n\t\t\tconst r = Math.min(Math.min(w, h) / 2, opt.radius)\n\n\t\t\tpts = [\n\t\t\t\tnew Vec2(r, 0),\n\t\t\t\tnew Vec2(w - r, 0),\n\t\t\t\t...getArcPts(new Vec2(w - r, r), r, r, 270, 360),\n\t\t\t\tnew Vec2(w, r),\n\t\t\t\tnew Vec2(w, h - r),\n\t\t\t\t...getArcPts(new Vec2(w - r, h - r), r, r, 0, 90),\n\t\t\t\tnew Vec2(w - r, h),\n\t\t\t\tnew Vec2(r, h),\n\t\t\t\t...getArcPts(new Vec2(r, h - r), r, r, 90, 180),\n\t\t\t\tnew Vec2(0, h - r),\n\t\t\t\tnew Vec2(0, r),\n\t\t\t\t...getArcPts(new Vec2(r, r), r, r, 180, 270),\n\t\t\t]\n\n\t\t}\n\n\t\tdrawPolygon(Object.assign({}, opt, {\n\t\t\toffset,\n\t\t\tpts,\n\t\t\t...(opt.gradient ? {\n\t\t\t\tcolors: opt.horizontal ? [\n\t\t\t\t\topt.gradient[0],\n\t\t\t\t\topt.gradient[1],\n\t\t\t\t\topt.gradient[1],\n\t\t\t\t\topt.gradient[0],\n\t\t\t\t] : [\n\t\t\t\t\topt.gradient[0],\n\t\t\t\t\topt.gradient[0],\n\t\t\t\t\topt.gradient[1],\n\t\t\t\t\topt.gradient[1],\n\t\t\t\t],\n\t\t\t} : {}),\n\t\t}))\n\n\t}\n\n\tfunction drawLine(opt: DrawLineOpt) {\n\n\t\tconst { p1, p2 } = opt\n\n\t\tif (!p1 || !p2) {\n\t\t\tthrow new KaboomError(\"drawLine() requires properties \\\"p1\\\" and \\\"p2\\\".\")\n\t\t}\n\n\t\tconst w = opt.width || 1\n\n\t\t// the displacement from the line end point to the corner point\n\t\tconst dis = p2.sub(p1).unit().normal().scale(w * 0.5)\n\n\t\t// calculate the 4 corner points of the line polygon\n\t\tconst verts = [\n\t\t\tp1.sub(dis),\n\t\t\tp1.add(dis),\n\t\t\tp2.add(dis),\n\t\t\tp2.sub(dis),\n\t\t].map((p) => ({\n\t\t\tpos: new Vec2(p.x, p.y),\n\t\t\tuv: new Vec2(0),\n\t\t\tcolor: opt.color ?? Color.WHITE,\n\t\t\topacity: opt.opacity ?? 1,\n\t\t}))\n\n\t\tdrawRaw(verts, [0, 1, 3, 1, 2, 3], opt.fixed, gfx.defTex, opt.shader, opt.uniform)\n\n\t}\n\n\tfunction drawLines(opt: DrawLinesOpt) {\n\n\t\tconst pts = opt.pts\n\n\t\tif (!pts) {\n\t\t\tthrow new KaboomError(\"drawLines() requires property \\\"pts\\\".\")\n\t\t}\n\n\t\tif (pts.length < 2) {\n\t\t\treturn\n\t\t}\n\n\t\tif (opt.radius && pts.length >= 3) {\n\n\t\t\t// TODO: line joines\n\t\t\t// TODO: rounded vertices for arbitury polygonic shape\n\t\t\tlet minSLen = pts[0].sdist(pts[1])\n\n\t\t\tfor (let i = 1; i < pts.length - 1; i++) {\n\t\t\t\tminSLen = Math.min(pts[i].sdist(pts[i + 1]), minSLen)\n\t\t\t}\n\n\t\t\t// eslint-disable-next-line\n\t\t\tconst radius = Math.min(opt.radius, Math.sqrt(minSLen) / 2)\n\n\t\t\tdrawLine(Object.assign({}, opt, { p1: pts[0], p2: pts[1] }))\n\n\t\t\tfor (let i = 1; i < pts.length - 2; i++) {\n\t\t\t\tconst p1 = pts[i]\n\t\t\t\tconst p2 = pts[i + 1]\n\t\t\t\tdrawLine(Object.assign({}, opt, {\n\t\t\t\t\tp1: p1,\n\t\t\t\t\tp2: p2,\n\t\t\t\t}))\n\t\t\t}\n\n\t\t\tdrawLine(Object.assign({}, opt, {\n\t\t\t\tp1: pts[pts.length - 2],\n\t\t\t\tp2: pts[pts.length - 1],\n\t\t\t}))\n\n\t\t} else {\n\n\t\t\tfor (let i = 0; i < pts.length - 1; i++) {\n\t\t\t\tdrawLine(Object.assign({}, opt, {\n\t\t\t\t\tp1: pts[i],\n\t\t\t\t\tp2: pts[i + 1],\n\t\t\t\t}))\n\t\t\t\t// TODO: other line join types\n\t\t\t\tif (opt.join !== \"none\") {\n\t\t\t\t\tdrawCircle(Object.assign({}, opt, {\n\t\t\t\t\t\tpos: pts[i],\n\t\t\t\t\t\tradius: opt.width / 2,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tfunction drawTriangle(opt: DrawTriangleOpt) {\n\t\tif (!opt.p1 || !opt.p2 || !opt.p3) {\n\t\t\tthrow new KaboomError(\"drawPolygon() requires properties \\\"p1\\\", \\\"p2\\\" and \\\"p3\\\".\")\n\t\t}\n\t\treturn drawPolygon(Object.assign({}, opt, {\n\t\t\tpts: [opt.p1, opt.p2, opt.p3],\n\t\t}))\n\t}\n\n\tfunction drawCircle(opt: DrawCircleOpt) {\n\n\t\tif (typeof opt.radius !== \"number\") {\n\t\t\tthrow new KaboomError(\"drawCircle() requires property \\\"radius\\\".\")\n\t\t}\n\n\t\tif (opt.radius === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tdrawEllipse(Object.assign({}, opt, {\n\t\t\tradiusX: opt.radius,\n\t\t\tradiusY: opt.radius,\n\t\t\tangle: 0,\n\t\t}))\n\n\t}\n\n\tfunction drawEllipse(opt: DrawEllipseOpt) {\n\n\t\tif (opt.radiusX === undefined || opt.radiusY === undefined) {\n\t\t\tthrow new KaboomError(\"drawEllipse() requires properties \\\"radiusX\\\" and \\\"radiusY\\\".\")\n\t\t}\n\n\t\tif (opt.radiusX === 0 || opt.radiusY === 0) {\n\t\t\treturn\n\t\t}\n\n\t\tconst start = opt.start ?? 0\n\t\tconst end = opt.end ?? 360\n\t\tconst offset = anchorPt(opt.anchor ?? \"center\").scale(new Vec2(-opt.radiusX, -opt.radiusY))\n\n\t\tconst pts = getArcPts(\n\t\t\toffset,\n\t\t\topt.radiusX,\n\t\t\topt.radiusY,\n\t\t\tstart,\n\t\t\tend,\n\t\t\topt.resolution,\n\t\t)\n\n\t\t// center\n\t\tpts.unshift(offset)\n\n\t\tconst polyOpt = Object.assign({}, opt, {\n\t\t\tpts,\n\t\t\tradius: 0,\n\t\t\t...(opt.gradient ? {\n\t\t\t\tcolors: [\n\t\t\t\t\topt.gradient[0],\n\t\t\t\t\t...Array(pts.length - 1).fill(opt.gradient[1]),\n\t\t\t\t],\n\t\t\t} : {}),\n\t\t})\n\n\t\t// full circle with outline shouldn't have the center point\n\t\tif (end - start >= 360 && opt.outline) {\n\t\t\tif (opt.fill !== false) {\n\t\t\t\tdrawPolygon(Object.assign(polyOpt, {\n\t\t\t\t\toutline: null,\n\t\t\t\t}))\n\t\t\t}\n\t\t\tdrawPolygon(Object.assign(polyOpt, {\n\t\t\t\tpts: pts.slice(1),\n\t\t\t\tfill: false,\n\t\t\t}))\n\t\t\treturn\n\t\t}\n\n\t\tdrawPolygon(polyOpt)\n\n\t}\n\n\tfunction drawPolygon(opt: DrawPolygonOpt) {\n\n\t\tif (!opt.pts) {\n\t\t\tthrow new KaboomError(\"drawPolygon() requires property \\\"pts\\\".\")\n\t\t}\n\n\t\tconst npts = opt.pts.length\n\n\t\tif (npts < 3) {\n\t\t\treturn\n\t\t}\n\n\t\tpushTransform()\n\t\tpushTranslate(opt.pos)\n\t\tpushScale(opt.scale)\n\t\tpushRotate(opt.angle)\n\t\tpushTranslate(opt.offset)\n\n\t\tif (opt.fill !== false) {\n\n\t\t\tconst color = opt.color ?? Color.WHITE\n\n\t\t\tconst verts = opt.pts.map((pt, i) => ({\n\t\t\t\tpos: new Vec2(pt.x, pt.y),\n\t\t\t\tuv: new Vec2(0, 0),\n\t\t\t\tcolor: opt.colors ? (opt.colors[i] ?? color) : color,\n\t\t\t\topacity: opt.opacity ?? 1,\n\t\t\t}))\n\n\t\t\t// TODO: better triangulation\n\t\t\tconst indices = [...Array(npts - 2).keys()]\n\t\t\t\t.map((n) => [0, n + 1, n + 2])\n\t\t\t\t.flat()\n\n\t\t\tdrawRaw(verts, opt.indices ?? indices, opt.fixed, gfx.defTex, opt.shader, opt.uniform)\n\n\t\t}\n\n\t\tif (opt.outline) {\n\t\t\tdrawLines({\n\t\t\t\tpts: [ ...opt.pts, opt.pts[0] ],\n\t\t\t\tradius: opt.radius,\n\t\t\t\twidth: opt.outline.width,\n\t\t\t\tcolor: opt.outline.color,\n\t\t\t\tjoin: opt.outline.join,\n\t\t\t\tuniform: opt.uniform,\n\t\t\t\tfixed: opt.fixed,\n\t\t\t\topacity: opt.opacity,\n\t\t\t})\n\t\t}\n\n\t\tpopTransform()\n\n\t}\n\n\tfunction drawStenciled(content: () => void, mask: () => void, test: number) {\n\n\t\tflush()\n\t\tgl.clear(gl.STENCIL_BUFFER_BIT)\n\t\tgl.enable(gl.STENCIL_TEST)\n\n\t\t// don't perform test, pure write\n\t\tgl.stencilFunc(\n\t\t\tgl.NEVER,\n\t\t\t1,\n\t\t\t0xFF,\n\t\t)\n\n\t\t// always replace since we're writing to the buffer\n\t\tgl.stencilOp(\n\t\t\tgl.REPLACE,\n\t\t\tgl.REPLACE,\n\t\t\tgl.REPLACE,\n\t\t)\n\n\t\tmask()\n\t\tflush()\n\n\t\t// perform test\n\t\tgl.stencilFunc(\n\t\t\ttest,\n\t\t\t1,\n\t\t\t0xFF,\n\t\t)\n\n\t\t// don't write since we're only testing\n\t\tgl.stencilOp(\n\t\t\tgl.KEEP,\n\t\t\tgl.KEEP,\n\t\t\tgl.KEEP,\n\t\t)\n\n\t\tcontent()\n\t\tflush()\n\t\tgl.disable(gl.STENCIL_TEST)\n\n\t}\n\n\tfunction drawMasked(content: () => void, mask: () => void) {\n\t\tdrawStenciled(content, mask, gl.EQUAL)\n\t}\n\n\tfunction drawSubtracted(content: () => void, mask: () => void) {\n\t\tdrawStenciled(content, mask, gl.NOTEQUAL)\n\t}\n\n\tfunction getViewportScale() {\n\t\treturn (gfx.viewport.width + gfx.viewport.height) / (gfx.width + gfx.height)\n\t}\n\n\tfunction drawUnscaled(content: () => void) {\n\t\tflush()\n\t\tconst ow = gfx.width\n\t\tconst oh = gfx.height\n\t\tgfx.width = gfx.viewport.width\n\t\tgfx.height = gfx.viewport.height\n\t\tcontent()\n\t\tflush()\n\t\tgfx.width = ow\n\t\tgfx.height = oh\n\t}\n\n\tfunction applyCharTransform(fchar: FormattedChar, tr: CharTransform) {\n\t\tif (tr.pos) fchar.pos = fchar.pos.add(tr.pos)\n\t\tif (tr.scale) fchar.scale = fchar.scale.scale(vec2(tr.scale))\n\t\tif (tr.angle) fchar.angle += tr.angle\n\t\tif (tr.color) fchar.color = fchar.color.mult(tr.color)\n\t\tif (tr.opacity) fchar.opacity *= tr.opacity\n\t}\n\n\t// TODO: escape\n\t// eslint-disable-next-line\n\tconst TEXT_STYLE_RE = /\\[(?<style>\\w+)\\](?<text>.*?)\\[\\/\\k<style>\\]/g\n\n\t// TODO: handle nested\n\tfunction compileStyledText(text: string): {\n\t\tcharStyleMap: Record<number, string[]>,\n\t\ttext: string,\n\t} {\n\n\t\tconst charStyleMap = {}\n\t\t// get the text without the styling syntax\n\t\tconst renderText = text.replace(TEXT_STYLE_RE, \"$2\")\n\t\tlet idxOffset = 0\n\n\t\t// put each styled char index into a map for easy access when iterating each char\n\t\tfor (const match of text.matchAll(TEXT_STYLE_RE)) {\n\t\t\tconst origIdx = match.index - idxOffset\n\t\t\tfor (let i = 0; i < match.groups.text.length; i++) {\n\t\t\t\tcharStyleMap[i + origIdx] = [match.groups.style]\n\t\t\t}\n\t\t\t// omit the style syntax in format string when calculating index\n\t\t\tidxOffset += match[0].length - match.groups.text.length\n\t\t}\n\n\t\treturn {\n\t\t\tcharStyleMap: charStyleMap,\n\t\t\ttext: renderText,\n\t\t}\n\n\t}\n\n\ttype FontAtlas = {\n\t\tfont: BitmapFontData,\n\t\tcursor: Vec2,\n\t\toutline: Outline | null,\n\t}\n\n\tconst fontAtlases: Record<string, FontAtlas> = {}\n\n\t// TODO: cache formatted text\n\t// format text and return a list of chars with their calculated position\n\tfunction formatText(opt: DrawTextOpt): FormattedText {\n\n\t\tif (opt.text === undefined) {\n\t\t\tthrow new KaboomError(\"formatText() requires property \\\"text\\\".\")\n\t\t}\n\n\t\tlet font = resolveFont(opt.font)\n\n\t\t// if it's still loading\n\t\tif (opt.text === \"\" || font instanceof Asset || !font) {\n\t\t\treturn {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0,\n\t\t\t\tchars: [],\n\t\t\t\topt: opt,\n\t\t\t}\n\t\t}\n\n\t\tconst { charStyleMap, text } = compileStyledText(opt.text + \"\")\n\t\tconst chars = text.split(\"\")\n\n\t\t// if it's not bitmap font, we draw it with 2d canvas or use cached image\n\t\tif (font instanceof FontData || typeof font === \"string\") {\n\n\t\t\tconst fontName = font instanceof FontData ? font.fontface.family : font\n\t\t\tconst opts: {\n\t\t\t\toutline: Outline | null,\n\t\t\t\tfilter: TexFilter,\n\t\t\t} = font instanceof FontData ? {\n\t\t\t\toutline: font.outline,\n\t\t\t\tfilter: font.filter,\n\t\t\t} : {\n\t\t\t\toutline: null,\n\t\t\t\tfilter: DEF_FONT_FILTER,\n\t\t\t}\n\n\t\t\t// TODO: customizable font tex filter\n\t\t\tconst atlas: FontAtlas = fontAtlases[fontName] ?? {\n\t\t\t\tfont: {\n\t\t\t\t\ttex: new Texture(FONT_ATLAS_WIDTH, FONT_ATLAS_HEIGHT, {\n\t\t\t\t\t\tfilter: opts.filter,\n\t\t\t\t\t}),\n\t\t\t\t\tmap: {},\n\t\t\t\t\tsize: DEF_TEXT_CACHE_SIZE,\n\t\t\t\t},\n\t\t\t\tcursor: new Vec2(0),\n\t\t\t\toutline: opts.outline,\n\t\t\t}\n\n\t\t\tif (!fontAtlases[fontName]) {\n\t\t\t\tfontAtlases[fontName] = atlas\n\t\t\t}\n\n\t\t\tfont = atlas.font\n\n\t\t\tfor (const ch of chars) {\n\n\t\t\t\tif (!atlas.font.map[ch]) {\n\n\t\t\t\t\t// TODO: use assets.packer to pack font texture\n\t\t\t\t\tconst c2d = fontCacheCtx\n\t\t\t\t\tc2d.clearRect(0, 0, fontCacheCanvas.width, fontCacheCanvas.height)\n\t\t\t\t\tc2d.font = `${font.size}px ${fontName}`\n\t\t\t\t\tc2d.textBaseline = \"top\"\n\t\t\t\t\tc2d.textAlign = \"left\"\n\t\t\t\t\tc2d.fillStyle = \"#ffffff\"\n\t\t\t\t\tconst m = c2d.measureText(ch)\n\t\t\t\t\tlet w = Math.ceil(m.width)\n\t\t\t\t\tlet h = font.size\n\t\t\t\t\tif (atlas.outline) {\n\t\t\t\t\t\tc2d.lineJoin = \"round\"\n\t\t\t\t\t\tc2d.lineWidth = atlas.outline.width * 2\n\t\t\t\t\t\tc2d.strokeStyle = atlas.outline.color.toHex()\n\t\t\t\t\t\tc2d.strokeText(ch, atlas.outline.width, atlas.outline.width)\n\t\t\t\t\t\tw += atlas.outline.width * 2\n\t\t\t\t\t\th += atlas.outline.width * 3\n\t\t\t\t\t}\n\t\t\t\t\tc2d.fillText(ch, atlas.outline?.width ?? 0, atlas.outline?.width ?? 0)\n\n\t\t\t\t\tconst img = c2d.getImageData(0, 0, w, h)\n\n\t\t\t\t\t// if we are about to exceed the X axis of the texture, go to another line\n\t\t\t\t\tif (atlas.cursor.x + w > FONT_ATLAS_WIDTH) {\n\t\t\t\t\t\tatlas.cursor.x = 0\n\t\t\t\t\t\tatlas.cursor.y += h\n\t\t\t\t\t\tif (atlas.cursor.y > FONT_ATLAS_HEIGHT) {\n\t\t\t\t\t\t\t// TODO: create another atlas\n\t\t\t\t\t\t\tthrow new KaboomError(\"Font atlas exceeds character limit\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfont.tex.update(img, atlas.cursor.x, atlas.cursor.y)\n\t\t\t\t\tfont.map[ch] = new Quad(atlas.cursor.x, atlas.cursor.y, w, h)\n\t\t\t\t\tatlas.cursor.x += w\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst size = opt.size || font.size\n\t\tconst scale = vec2(opt.scale ?? 1).scale(size / font.size)\n\t\tconst lineSpacing = opt.lineSpacing ?? 0\n\t\tconst letterSpacing = opt.letterSpacing ?? 0\n\t\tlet curX = 0\n\t\tlet tw = 0\n\t\tlet th = 0\n\t\tconst lines: Array<{\n\t\t\twidth: number,\n\t\t\tchars: FormattedChar[],\n\t\t}> = []\n\t\tlet curLine: FormattedChar[] = []\n\t\tlet cursor = 0\n\t\tlet lastSpace = null\n\t\tlet lastSpaceWidth = null\n\n\t\t// TODO: word break\n\t\twhile (cursor < chars.length) {\n\n\t\t\tlet ch = chars[cursor]\n\n\t\t\t// always new line on '\\n'\n\t\t\tif (ch === \"\\n\") {\n\n\t\t\t\tth += size + lineSpacing\n\n\t\t\t\tlines.push({\n\t\t\t\t\twidth: curX - letterSpacing,\n\t\t\t\t\tchars: curLine,\n\t\t\t\t})\n\n\t\t\t\tlastSpace = null\n\t\t\t\tlastSpaceWidth = null\n\t\t\t\tcurX = 0\n\t\t\t\tcurLine = []\n\n\t\t\t} else {\n\n\t\t\t\tlet q = font.map[ch]\n\n\t\t\t\t// TODO: leave space if character not found?\n\t\t\t\tif (q) {\n\n\t\t\t\t\tlet gw = q.w * scale.x\n\n\t\t\t\t\tif (opt.width && curX + gw > opt.width) {\n\t\t\t\t\t\t// new line on last word if width exceeds\n\t\t\t\t\t\tth += size + lineSpacing\n\t\t\t\t\t\tif (lastSpace != null) {\n\t\t\t\t\t\t\tcursor -= curLine.length - lastSpace\n\t\t\t\t\t\t\tch = chars[cursor]\n\t\t\t\t\t\t\tq = font.map[ch]\n\t\t\t\t\t\t\tgw = q.w * scale.x\n\t\t\t\t\t\t\t// omit trailing space\n\t\t\t\t\t\t\tcurLine = curLine.slice(0, lastSpace - 1)\n\t\t\t\t\t\t\tcurX = lastSpaceWidth\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastSpace = null\n\t\t\t\t\t\tlastSpaceWidth = null\n\t\t\t\t\t\tlines.push({\n\t\t\t\t\t\t\twidth: curX - letterSpacing,\n\t\t\t\t\t\t\tchars: curLine,\n\t\t\t\t\t\t})\n\t\t\t\t\t\tcurX = 0\n\t\t\t\t\t\tcurLine = []\n\t\t\t\t\t}\n\n\t\t\t\t\t// push char\n\t\t\t\t\tcurLine.push({\n\t\t\t\t\t\ttex: font.tex,\n\t\t\t\t\t\twidth: q.w,\n\t\t\t\t\t\theight: q.h,\n\t\t\t\t\t\t// without some padding there'll be visual artifacts on edges\n\t\t\t\t\t\tquad: new Quad(\n\t\t\t\t\t\t\tq.x / font.tex.width,\n\t\t\t\t\t\t\tq.y / font.tex.height,\n\t\t\t\t\t\t\tq.w / font.tex.width,\n\t\t\t\t\t\t\tq.h / font.tex.height,\n\t\t\t\t\t\t),\n\t\t\t\t\t\tch: ch,\n\t\t\t\t\t\tpos: new Vec2(curX, th),\n\t\t\t\t\t\topacity: opt.opacity ?? 1,\n\t\t\t\t\t\tcolor: opt.color ?? Color.WHITE,\n\t\t\t\t\t\tscale: vec2(scale),\n\t\t\t\t\t\tangle: 0,\n\t\t\t\t\t})\n\n\t\t\t\t\tif (ch === \" \") {\n\t\t\t\t\t\tlastSpace = curLine.length\n\t\t\t\t\t\tlastSpaceWidth = curX\n\t\t\t\t\t}\n\n\t\t\t\t\tcurX += gw\n\t\t\t\t\ttw = Math.max(tw, curX)\n\t\t\t\t\tcurX += letterSpacing\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tcursor++\n\n\t\t}\n\n\t\tlines.push({\n\t\t\twidth: curX - letterSpacing,\n\t\t\tchars: curLine,\n\t\t})\n\n\t\tth += size\n\n\t\tif (opt.width) {\n\t\t\ttw = opt.width\n\t\t}\n\n\t\tconst fchars: FormattedChar[] = []\n\n\t\tfor (const line of lines) {\n\n\t\t\tconst ox = (tw - line.width) * alignPt(opt.align ?? \"left\")\n\n\t\t\tfor (const fchar of line.chars) {\n\n\t\t\t\tconst q = font.map[fchar.ch]\n\t\t\t\tconst idx = fchars.length\n\n\t\t\t\tfchar.pos = fchar.pos.add(ox, 0).add(\n\t\t\t\t\tq.w * scale.x * 0.5,\n\t\t\t\t\tq.h * scale.y * 0.5,\n\t\t\t\t)\n\n\t\t\t\tif (opt.transform) {\n\t\t\t\t\tconst tr = typeof opt.transform === \"function\"\n\t\t\t\t\t\t? opt.transform(idx, fchar.ch)\n\t\t\t\t\t\t: opt.transform\n\t\t\t\t\tif (tr) {\n\t\t\t\t\t\tapplyCharTransform(fchar, tr)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (charStyleMap[idx]) {\n\t\t\t\t\tconst styles = charStyleMap[idx]\n\t\t\t\t\tfor (const name of styles) {\n\t\t\t\t\t\tconst style = opt.styles[name]\n\t\t\t\t\t\tconst tr = typeof style === \"function\"\n\t\t\t\t\t\t\t? style(idx, fchar.ch)\n\t\t\t\t\t\t\t: style\n\t\t\t\t\t\tif (tr) {\n\t\t\t\t\t\t\tapplyCharTransform(fchar, tr)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfchars.push(fchar)\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\twidth: tw,\n\t\t\theight: th,\n\t\t\tchars: fchars,\n\t\t\topt: opt,\n\t\t}\n\n\t}\n\n\tfunction drawText(opt: DrawTextOpt) {\n\t\tdrawFormattedText(formatText(opt))\n\t}\n\n\tfunction drawFormattedText(ftext: FormattedText) {\n\t\tpushTransform()\n\t\tpushTranslate(ftext.opt.pos)\n\t\tpushRotate(ftext.opt.angle)\n\t\tpushTranslate(anchorPt(ftext.opt.anchor ?? \"topleft\").add(1, 1).scale(ftext.width, ftext.height).scale(-0.5))\n\t\tftext.chars.forEach((ch) => {\n\t\t\tdrawUVQuad({\n\t\t\t\ttex: ch.tex,\n\t\t\t\twidth: ch.width,\n\t\t\t\theight: ch.height,\n\t\t\t\tpos: ch.pos,\n\t\t\t\tscale: ch.scale,\n\t\t\t\tangle: ch.angle,\n\t\t\t\tcolor: ch.color,\n\t\t\t\topacity: ch.opacity,\n\t\t\t\tquad: ch.quad,\n\t\t\t\tanchor: \"center\",\n\t\t\t\tuniform: ftext.opt.uniform,\n\t\t\t\tshader: ftext.opt.shader,\n\t\t\t\tfixed: ftext.opt.fixed,\n\t\t\t})\n\t\t})\n\t\tpopTransform()\n\t}\n\n\t// get game width\n\tfunction width(): number {\n\t\treturn gfx.width\n\t}\n\n\t// get game height\n\tfunction height(): number {\n\t\treturn gfx.height\n\t}\n\n\tconst winEvents: EventList<WindowEventMap> = {}\n\n\t// transform a point from window space to content space\n\tfunction windowToContent(pt: Vec2) {\n\t\treturn new Vec2(\n\t\t\t(pt.x - gfx.viewport.x) * width() / gfx.viewport.width,\n\t\t\t(pt.y - gfx.viewport.y) * height() / gfx.viewport.height,\n\t\t)\n\t}\n\n\t// transform a point from content space to view space\n\tfunction contentToView(pt: Vec2) {\n\t\treturn new Vec2(\n\t\t\tpt.x * gfx.viewport.width / gfx.width,\n\t\t\tpt.y * gfx.viewport.height / gfx.height,\n\t\t)\n\t}\n\n\tfunction mousePos() {\n\t\treturn windowToContent(app.mousePos())\n\t}\n\n\twinEvents.error = (e) => {\n\t\tif (e.error && e.error instanceof KaboomError) {\n\t\t\thandleErr(e.error)\n\t\t} else if (e instanceof KaboomError) {\n\t\t\thandleErr(e)\n\t\t}\n\t}\n\n\twinEvents.unhandledrejection = (e) => {\n\t\tif (e.reason instanceof KaboomError) {\n\t\t\thandleErr(e.reason)\n\t\t}\n\t}\n\n\tfor (const name in winEvents) {\n\t\twindow.addEventListener(name, winEvents[name])\n\t}\n\n\tlet debugPaused = false\n\n\tconst debug: Debug = {\n\t\tinspect: false,\n\t\ttimeScale: 1,\n\t\tshowLog: true,\n\t\tfps: () => app.fps(),\n\t\tnumFrames: () => app.numFrames(),\n\t\tstepFrame: updateFrame,\n\t\tdrawCalls: () => gfx.lastDrawCalls,\n\t\tclearLog: () => game.logs = [],\n\t\tlog: (msg) => {\n\t\t\tconst max = gopt.logMax ?? LOG_MAX\n\t\t\tgame.logs.unshift({\n\t\t\t\tmsg: msg,\n\t\t\t\ttime: app.time(),\n\t\t\t})\n\t\t\tif (game.logs.length > max) {\n\t\t\t\tgame.logs = game.logs.slice(0, max)\n\t\t\t}\n\t\t},\n\t\terror: (msg) => debug.log(new KaboomError(msg.toString ? msg.toString() : msg as string)),\n\t\tcurRecording: null,\n\t\tnumObjects: () => get(\"*\", { recursive: true }).length,\n\t\tget paused() {\n\t\t\treturn debugPaused\n\t\t},\n\t\tset paused(v) {\n\t\t\tdebugPaused = v\n\t\t\tif (v) {\n\t\t\t\taudio.ctx.suspend()\n\t\t\t} else {\n\t\t\t\taudio.ctx.resume()\n\t\t\t}\n\t\t},\n\t}\n\n\tfunction dt() {\n\t\treturn app.dt() * debug.timeScale\n\t}\n\n\tfunction camPos(...pos: Vec2Args): Vec2 {\n\t\tif (pos.length > 0) {\n\t\t\tgame.cam.pos = vec2(...pos)\n\t\t}\n\t\treturn game.cam.pos ? game.cam.pos.clone() : center()\n\t}\n\n\tfunction camScale(...scale: Vec2Args): Vec2 {\n\t\tif (scale.length > 0) {\n\t\t\tgame.cam.scale = vec2(...scale)\n\t\t}\n\t\treturn game.cam.scale.clone()\n\t}\n\n\tfunction camRot(angle: number): number {\n\t\tif (angle !== undefined) {\n\t\t\tgame.cam.angle = angle\n\t\t}\n\t\treturn game.cam.angle\n\t}\n\n\tfunction shake(intensity: number = 12) {\n\t\tgame.cam.shake += intensity\n\t}\n\n\tfunction toScreen(p: Vec2): Vec2 {\n\t\treturn game.cam.transform.multVec2(p)\n\t}\n\n\tfunction toWorld(p: Vec2): Vec2 {\n\t\treturn game.cam.transform.invert().multVec2(p)\n\t}\n\n\tfunction calcTransform(obj: GameObj): Mat4 {\n\t\tconst tr = new Mat4()\n\t\tif (obj.pos) tr.translate(obj.pos)\n\t\tif (obj.scale) tr.scale(obj.scale)\n\t\tif (obj.angle) tr.rotate(obj.angle)\n\t\treturn obj.parent ? tr.mult(obj.parent.transform) : tr\n\t}\n\n\tfunction make<T>(comps: CompList<T> = []): GameObj<T> {\n\n\t\tconst compStates = new Map()\n\t\tconst cleanups = {}\n\t\tconst events = new EventHandler()\n\t\tconst inputEvents: EventController[] = []\n\t\tlet onCurCompCleanup = null\n\t\tlet paused = false\n\n\t\t// @ts-ignore\n\t\tconst obj: GameObj = {\n\n\t\t\tid: uid(),\n\t\t\t// TODO: a nice way to hide / pause when add()-ing\n\t\t\thidden: false,\n\t\t\ttransform: new Mat4(),\n\t\t\tchildren: [],\n\t\t\tparent: null,\n\n\t\t\tset paused(p) {\n\t\t\t\tif (p === paused) return\n\t\t\t\tpaused = p\n\t\t\t\tfor (const e of inputEvents) {\n\t\t\t\t\te.paused = p\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tget paused() {\n\t\t\t\treturn paused\n\t\t\t},\n\n\t\t\tadd<T2>(a: CompList<T2> | GameObj<T2> = []): GameObj<T2> {\n\t\t\t\tconst obj = Array.isArray(a) ? make(a) : a\n\t\t\t\tif (obj.parent) {\n\t\t\t\t\tthrow new KaboomError(\"Cannot add a game obj that already has a parent.\")\n\t\t\t\t}\n\t\t\t\tobj.parent = this\n\t\t\t\tobj.transform = calcTransform(obj)\n\t\t\t\tthis.children.push(obj)\n\t\t\t\t// TODO: trigger add for children\n\t\t\t\tobj.trigger(\"add\", obj)\n\t\t\t\tgame.events.trigger(\"add\", obj)\n\t\t\t\treturn obj\n\t\t\t},\n\n\t\t\treadd(obj: GameObj): GameObj {\n\t\t\t\tconst idx = this.children.indexOf(obj)\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tthis.children.splice(idx, 1)\n\t\t\t\t\tthis.children.push(obj)\n\t\t\t\t}\n\t\t\t\treturn obj\n\t\t\t},\n\n\t\t\tremove(obj: GameObj): void {\n\t\t\t\tconst idx = this.children.indexOf(obj)\n\t\t\t\tif (idx !== -1) {\n\t\t\t\t\tobj.parent = null\n\t\t\t\t\tthis.children.splice(idx, 1)\n\t\t\t\t\tconst trigger = (o) => {\n\t\t\t\t\t\to.trigger(\"destroy\")\n\t\t\t\t\t\tgame.events.trigger(\"destroy\", o)\n\t\t\t\t\t\to.children.forEach((child) => trigger(child))\n\t\t\t\t\t}\n\t\t\t\t\ttrigger(obj)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// TODO: recursive\n\t\t\tremoveAll(tag?: Tag) {\n\t\t\t\tif (tag) {\n\t\t\t\t\tthis.get(tag).forEach((obj) => this.remove(obj))\n\t\t\t\t} else {\n\t\t\t\t\tfor (const child of [...this.children]) this.remove(child)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tupdate() {\n\t\t\t\tif (this.paused) return\n\t\t\t\tthis.children\n\t\t\t\t\t.sort((o1, o2) => (o1.z ?? 0) - (o2.z ?? 0))\n\t\t\t\t\t.forEach((child) => child.update())\n\t\t\t\tthis.trigger(\"update\")\n\t\t\t},\n\n\t\t\tdraw(this: GameObj<PosComp | ScaleComp | RotateComp | FixedComp | MaskComp>) {\n\t\t\t\tif (this.hidden) return\n\t\t\t\tconst f = gfx.fixed\n\t\t\t\tif (this.fixed) gfx.fixed = true\n\t\t\t\tpushTransform()\n\t\t\t\tpushTranslate(this.pos)\n\t\t\t\tpushScale(this.scale)\n\t\t\t\tpushRotate(this.angle)\n\t\t\t\tconst children = this.children.sort((o1, o2) => (o1.z ?? 0) - (o2.z ?? 0))\n\t\t\t\t// TODO: automatically don't draw if offscreen\n\t\t\t\tif (this.mask) {\n\t\t\t\t\tconst maskFunc = {\n\t\t\t\t\t\tintersect: drawMasked,\n\t\t\t\t\t\tsubtract: drawSubtracted,\n\t\t\t\t\t}[this.mask]\n\t\t\t\t\tif (!maskFunc) {\n\t\t\t\t\t\tthrow new KaboomError(`Invalid mask func: \"${this.mask}\"`)\n\t\t\t\t\t}\n\t\t\t\t\tmaskFunc(() => {\n\t\t\t\t\t\tchildren.forEach((child) => child.draw())\n\t\t\t\t\t}, () => {\n\t\t\t\t\t\tthis.trigger(\"draw\")\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tthis.trigger(\"draw\")\n\t\t\t\t\tchildren.forEach((child) => child.draw())\n\t\t\t\t}\n\t\t\t\tpopTransform()\n\t\t\t\tgfx.fixed = f\n\t\t\t},\n\n\t\t\tdrawInspect(this: GameObj<PosComp | ScaleComp | RotateComp>) {\n\t\t\t\tif (this.hidden) return\n\t\t\t\tpushTransform()\n\t\t\t\tpushTranslate(this.pos)\n\t\t\t\tpushScale(this.scale)\n\t\t\t\tpushRotate(this.angle)\n\t\t\t\tthis.children\n\t\t\t\t\t.sort((o1, o2) => (o1.z ?? 0) - (o2.z ?? 0))\n\t\t\t\t\t.forEach((child) => child.drawInspect())\n\t\t\t\tthis.trigger(\"drawInspect\")\n\t\t\t\tpopTransform()\n\t\t\t},\n\n\t\t\t// use a comp, or tag\n\t\t\tuse(comp: Comp | Tag) {\n\n\t\t\t\tif (!comp) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// tag\n\t\t\t\tif (typeof comp === \"string\") {\n\t\t\t\t\treturn this.use({\n\t\t\t\t\t\tid: comp,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tlet gc = []\n\n\t\t\t\t// clear if overwrite\n\t\t\t\tif (comp.id) {\n\t\t\t\t\tthis.unuse(comp.id)\n\t\t\t\t\tcleanups[comp.id] = []\n\t\t\t\t\tgc = cleanups[comp.id]\n\t\t\t\t\tcompStates.set(comp.id, comp)\n\t\t\t\t}\n\n\t\t\t\tfor (const k in comp) {\n\n\t\t\t\t\tif (COMP_DESC.has(k)) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\n\t\t\t\t\tconst prop = Object.getOwnPropertyDescriptor(comp, k)\n\n\t\t\t\t\tif (typeof prop.value === \"function\") {\n\t\t\t\t\t\tcomp[k] = comp[k].bind(this)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prop.set) {\n\t\t\t\t\t\tObject.defineProperty(comp, k, {\n\t\t\t\t\t\t\tset: prop.set.bind(this),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prop.get) {\n\t\t\t\t\t\tObject.defineProperty(comp, k, {\n\t\t\t\t\t\t\tget: prop.get.bind(this),\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\n\t\t\t\t\tif (COMP_EVENTS.has(k)) {\n\t\t\t\t\t\t// automatically clean up events created by components in add() stage\n\t\t\t\t\t\tconst func = k === \"add\" ? () => {\n\t\t\t\t\t\t\tonCurCompCleanup = (c) => gc.push(c)\n\t\t\t\t\t\t\tcomp[k]()\n\t\t\t\t\t\t\tonCurCompCleanup = null\n\t\t\t\t\t\t} : comp[k]\n\t\t\t\t\t\tgc.push(this.on(k, func).cancel)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (this[k] === undefined) {\n\t\t\t\t\t\t\t// assign comp fields to game obj\n\t\t\t\t\t\t\tObject.defineProperty(this, k, {\n\t\t\t\t\t\t\t\tget: () => comp[k],\n\t\t\t\t\t\t\t\tset: (val) => comp[k] = val,\n\t\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\tgc.push(() => delete this[k])\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow new KaboomError(`Duplicate component property: \"${k}\"`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// check for component dependencies\n\t\t\t\tconst checkDeps = () => {\n\t\t\t\t\tif (!comp.require) return\n\t\t\t\t\tfor (const dep of comp.require) {\n\t\t\t\t\t\tif (!this.c(dep)) {\n\t\t\t\t\t\t\tthrow new KaboomError(`Component \"${comp.id}\" requires component \"${dep}\"`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (comp.destroy) {\n\t\t\t\t\tgc.push(comp.destroy.bind(this))\n\t\t\t\t}\n\n\t\t\t\t// manually trigger add event if object already exist\n\t\t\t\tif (this.exists()) {\n\t\t\t\t\tcheckDeps()\n\t\t\t\t\tif (comp.add) {\n\t\t\t\t\t\tonCurCompCleanup = (c) => gc.push(c)\n\t\t\t\t\t\tcomp.add.call(this)\n\t\t\t\t\t\tonCurCompCleanup = null\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (comp.require) {\n\t\t\t\t\t\tgc.push(this.on(\"add\", checkDeps).cancel)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tunuse(id: Tag) {\n\t\t\t\tif (cleanups[id]) {\n\t\t\t\t\tcleanups[id].forEach((e) => e())\n\t\t\t\t\tdelete cleanups[id]\n\t\t\t\t}\n\t\t\t\tif (compStates.has(id)) {\n\t\t\t\t\tcompStates.delete(id)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tc(id: Tag): Comp {\n\t\t\t\treturn compStates.get(id)\n\t\t\t},\n\n\t\t\tget(t: Tag | Tag[], opts: GetOpt = {}): GameObj[] {\n\t\t\t\tlet list: GameObj[] = opts.recursive\n\t\t\t\t\t? this.children.flatMap(function recurse(child) {\n\t\t\t\t\t\treturn [child, ...child.children.flatMap(recurse)]\n\t\t\t\t\t})\n\t\t\t\t\t: this.children\n\t\t\t\tlist = list.filter((child) => t ? child.is(t) : true)\n\t\t\t\tif (opts.liveUpdate) {\n\t\t\t\t\tconst isChild = (obj) => {\n\t\t\t\t\t\treturn opts.recursive\n\t\t\t\t\t\t\t? this.isAncestorOf(obj)\n\t\t\t\t\t\t\t: obj.parent === this\n\t\t\t\t\t}\n\t\t\t\t\tconst events = []\n\t\t\t\t\t// TODO: handle when object add / remove tags\n\t\t\t\t\t// TODO: clean up when obj destroyed\n\t\t\t\t\tevents.push(onAdd((obj) => {\n\t\t\t\t\t\tif (isChild(obj) && obj.is(t)) {\n\t\t\t\t\t\t\tlist.push(obj)\n\t\t\t\t\t\t}\n\t\t\t\t\t}))\n\t\t\t\t\tevents.push(onDestroy((obj) => {\n\t\t\t\t\t\tif (isChild(obj) && obj.is(t)) {\n\t\t\t\t\t\t\tconst idx = list.findIndex((o) => o.id === obj.id)\n\t\t\t\t\t\t\tif (idx !== -1) {\n\t\t\t\t\t\t\t\tlist.splice(idx, 1)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}))\n\t\t\t\t\tthis.onDestroy(() => {\n\t\t\t\t\t\tfor (const ev of events) {\n\t\t\t\t\t\t\tev.cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t\treturn list\n\t\t\t},\n\n\t\t\tisAncestorOf(obj: GameObj) {\n\t\t\t\tif (!obj.parent) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\treturn obj.parent === this || this.isAncestorOf(obj.parent)\n\t\t\t},\n\n\t\t\texists(): boolean {\n\t\t\t\treturn game.root.isAncestorOf(this)\n\t\t\t},\n\n\t\t\tis(tag: Tag | Tag[]): boolean {\n\t\t\t\tif (tag === \"*\") {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t\tif (Array.isArray(tag)) {\n\t\t\t\t\tfor (const t of tag) {\n\t\t\t\t\t\tif (!this.c(t)) {\n\t\t\t\t\t\t\treturn false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true\n\t\t\t\t} else {\n\t\t\t\t\treturn this.c(tag) != null\n\t\t\t\t}\n\t\t\t},\n\n\t\t\ton(name: string, action: (...args) => void): EventController {\n\t\t\t\tconst ctrl = events.on(name, action.bind(this))\n\t\t\t\tif (onCurCompCleanup) {\n\t\t\t\t\tonCurCompCleanup(() => ctrl.cancel())\n\t\t\t\t}\n\t\t\t\treturn ctrl\n\t\t\t},\n\n\t\t\ttrigger(name: string, ...args): void {\n\t\t\t\tevents.trigger(name, ...args)\n\t\t\t\tgame.objEvents.trigger(name, this, ...args)\n\t\t\t},\n\n\t\t\tdestroy() {\n\t\t\t\tif (this.parent) {\n\t\t\t\t\tthis.parent.remove(this)\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tinspect() {\n\t\t\t\tconst info = {}\n\t\t\t\tfor (const [tag, comp] of compStates) {\n\t\t\t\t\tinfo[tag] = comp.inspect ? comp.inspect() : null\n\t\t\t\t}\n\t\t\t\treturn info\n\t\t\t},\n\n\t\t\tonAdd(cb: () => void): EventController {\n\t\t\t\treturn this.on(\"add\", cb)\n\t\t\t},\n\n\t\t\tonUpdate(cb: () => void): EventController {\n\t\t\t\treturn this.on(\"update\", cb)\n\t\t\t},\n\n\t\t\tonDraw(cb: () => void): EventController {\n\t\t\t\treturn this.on(\"draw\", cb)\n\t\t\t},\n\n\t\t\tonDestroy(action: () => void): EventController {\n\t\t\t\treturn this.on(\"destroy\", action)\n\t\t\t},\n\n\t\t\tclearEvents() {\n\t\t\t\tevents.clear()\n\t\t\t},\n\n\t\t}\n\n\t\t// TODO: type with as const\n\t\tconst evs = [\n\t\t\t\"onKeyPress\",\n\t\t\t\"onKeyPressRepeat\",\n\t\t\t\"onKeyDown\",\n\t\t\t\"onKeyRelease\",\n\t\t\t\"onMousePress\",\n\t\t\t\"onMouseDown\",\n\t\t\t\"onMouseRelease\",\n\t\t\t\"onMouseMove\",\n\t\t\t\"onCharInput\",\n\t\t\t\"onMouseMove\",\n\t\t\t\"onTouchStart\",\n\t\t\t\"onTouchMove\",\n\t\t\t\"onTouchEnd\",\n\t\t\t\"onScroll\",\n\t\t\t\"onGamepadButtonPress\",\n\t\t\t\"onGamepadButtonDown\",\n\t\t\t\"onGamepadButtonRelease\",\n\t\t\t\"onGamepadStick\",\n\t\t]\n\n\t\tfor (const e of evs) {\n\t\t\tobj[e] = (...args) => {\n\t\t\t\tconst ev = app[e](...args)\n\t\t\t\tinputEvents.push(ev)\n\t\t\t\t// TODO: what if the game object is destroy and re-added\n\t\t\t\tobj.onDestroy(() => ev.cancel())\n\t\t\t\treturn ev\n\t\t\t}\n\t\t}\n\n\t\tfor (const comp of comps) {\n\t\t\tobj.use(comp)\n\t\t}\n\n\t\treturn obj as unknown as GameObj<T>\n\n\t}\n\n\t// add an event to a tag\n\tfunction on(event: string, tag: Tag, cb: (obj: GameObj, ...args) => void): EventController {\n\t\tif (!game.objEvents[event]) {\n\t\t\tgame.objEvents[event] = new IDList()\n\t\t}\n\t\treturn game.objEvents.on(event, (obj, ...args) => {\n\t\t\tif (obj.is(tag)) {\n\t\t\t\tcb(obj, ...args)\n\t\t\t}\n\t\t})\n\t}\n\n\t// add update event to a tag or global update\n\tconst onUpdate = ((tag: Tag | (() => void), action?: (obj: GameObj) => void) => {\n\t\tif (typeof tag === \"function\" && action === undefined) {\n\t\t\tconst obj = add([{ update: tag }])\n\t\t\treturn {\n\t\t\t\tget paused() {\n\t\t\t\t\treturn obj.paused\n\t\t\t\t},\n\t\t\t\tset paused(p) {\n\t\t\t\t\tobj.paused = p\n\t\t\t\t},\n\t\t\t\tcancel: () => obj.destroy(),\n\t\t\t}\n\t\t} else if (typeof tag === \"string\") {\n\t\t\treturn on(\"update\", tag, action)\n\t\t}\n\t}) as KaboomCtx[\"onUpdate\"]\n\n\t// add draw event to a tag or global draw\n\tconst onDraw = ((tag: Tag | (() => void), action?: (obj: GameObj) => void) => {\n\t\tif (typeof tag === \"function\" && action === undefined) {\n\t\t\tconst obj = add([{ draw: tag }])\n\t\t\treturn {\n\t\t\t\tget paused() {\n\t\t\t\t\treturn obj.hidden\n\t\t\t\t},\n\t\t\t\tset paused(p) {\n\t\t\t\t\tobj.hidden = p\n\t\t\t\t},\n\t\t\t\tcancel: () => obj.destroy(),\n\t\t\t}\n\t\t} else if (typeof tag === \"string\") {\n\t\t\treturn on(\"draw\", tag, action)\n\t\t}\n\t}) as KaboomCtx[\"onDraw\"]\n\n\tfunction onAdd(tag: Tag | ((obj: GameObj) => void), action?: (obj: GameObj) => void) {\n\t\tif (typeof tag === \"function\" && action === undefined) {\n\t\t\treturn game.events.on(\"add\", tag)\n\t\t} else if (typeof tag === \"string\") {\n\t\t\treturn on(\"add\", tag, action)\n\t\t}\n\t}\n\n\tfunction onDestroy(tag: Tag | ((obj: GameObj) => void), action?: (obj: GameObj) => void) {\n\t\tif (typeof tag === \"function\" && action === undefined) {\n\t\t\treturn game.events.on(\"destroy\", tag)\n\t\t} else if (typeof tag === \"string\") {\n\t\t\treturn on(\"destroy\", tag, action)\n\t\t}\n\t}\n\n\t// add an event that runs with objs with t1 collides with objs with t2\n\tfunction onCollide(\n\t\tt1: Tag,\n\t\tt2: Tag,\n\t\tf: (a: GameObj, b: GameObj, col?: Collision) => void,\n\t): EventController {\n\t\treturn on(\"collide\", t1, (a, b, col) => b.is(t2) && f(a, b, col))\n\t}\n\n\tfunction onCollideUpdate(\n\t\tt1: Tag,\n\t\tt2: Tag,\n\t\tf: (a: GameObj, b: GameObj, col?: Collision) => void,\n\t): EventController {\n\t\treturn on(\"collideUpdate\", t1, (a, b, col) => b.is(t2) && f(a, b, col))\n\t}\n\n\tfunction onCollideEnd(\n\t\tt1: Tag,\n\t\tt2: Tag,\n\t\tf: (a: GameObj, b: GameObj, col?: Collision) => void,\n\t): EventController {\n\t\treturn on(\"collideEnd\", t1, (a, b, col) => b.is(t2) && f(a, b, col))\n\t}\n\n\tfunction forAllCurrentAndFuture(t: Tag, action: (obj: GameObj) => void) {\n\t\tget(t, { recursive: true }).forEach(action)\n\t\tonAdd(t, action)\n\t}\n\n\t// add an event that runs when objs with tag t is clicked\n\tfunction onClick(tag: Tag | (() => void), action?: (obj: GameObj) => void): EventController {\n\t\tif (typeof tag === \"function\") {\n\t\t\treturn app.onMousePress(tag)\n\t\t} else {\n\t\t\tconst events = []\n\t\t\tforAllCurrentAndFuture(tag, (obj) => {\n\t\t\t\tif (!obj.area)\n\t\t\t\t\tthrow new KaboomError(\"onClick() requires the object to have area() component\")\n\t\t\t\tevents.push(obj.onClick(() => action(obj)))\n\t\t\t})\n\t\t\treturn EventController.join(events)\n\t\t}\n\t}\n\n\t// add an event that runs once when objs with tag t is hovered\n\tfunction onHover(t: Tag, action: (obj: GameObj) => void): EventController {\n\t\tconst events = []\n\t\tforAllCurrentAndFuture(t, (obj) => {\n\t\t\tif (!obj.area)\n\t\t\t\tthrow new KaboomError(\"onHover() requires the object to have area() component\")\n\t\t\tevents.push(obj.onHover(() => action(obj)))\n\t\t})\n\t\treturn EventController.join(events)\n\t}\n\n\t// add an event that runs once when objs with tag t is hovered\n\tfunction onHoverUpdate(t: Tag, action: (obj: GameObj) => void): EventController {\n\t\tconst events = []\n\t\tforAllCurrentAndFuture(t, (obj) => {\n\t\t\tif (!obj.area)\n\t\t\t\tthrow new KaboomError(\"onHoverUpdate() requires the object to have area() component\")\n\t\t\tevents.push(obj.onHoverUpdate(() => action(obj)))\n\t\t})\n\t\treturn EventController.join(events)\n\t}\n\n\t// add an event that runs once when objs with tag t is unhovered\n\tfunction onHoverEnd(t: Tag, action: (obj: GameObj) => void): EventController {\n\t\tconst events = []\n\t\tforAllCurrentAndFuture(t, (obj) => {\n\t\t\tif (!obj.area)\n\t\t\t\tthrow new KaboomError(\"onHoverEnd() requires the object to have area() component\")\n\t\t\tevents.push(obj.onHoverEnd(() => action(obj)))\n\t\t})\n\t\treturn EventController.join(events)\n\t}\n\n\t// TODO: use PromiseLike?\n\t// TODO: use root game object and timer()?\n\t// add an event that'd be run after t\n\tfunction wait(time: number, action?: () => void): TimerController {\n\t\tlet t = 0\n\t\tconst actions = []\n\t\tif (action) actions.push(action)\n\t\tconst ev = onUpdate(() => {\n\t\t\tt += dt()\n\t\t\tif (t >= time) {\n\t\t\t\tev.cancel()\n\t\t\t\tactions.forEach((action) => action())\n\t\t\t}\n\t\t})\n\t\treturn {\n\t\t\tpaused: ev.paused,\n\t\t\tcancel: ev.cancel,\n\t\t\tonEnd(action) {\n\t\t\t\tactions.push(action)\n\t\t\t},\n\t\t\tthen(action) {\n\t\t\t\tthis.onEnd(action)\n\t\t\t\treturn this\n\t\t\t},\n\t\t}\n\t}\n\n\t// add an event that's run every t seconds\n\tfunction loop(t: number, action: () => void): EventController {\n\n\t\tlet curTimer: null | TimerController = null\n\n\t\tconst newAction = () => {\n\t\t\t// TODO: should f be execute right away as loop() is called?\n\t\t\tcurTimer = wait(t, newAction)\n\t\t\taction()\n\t\t}\n\n\t\tcurTimer = wait(0, newAction)\n\n\t\treturn {\n\t\t\tget paused() {\n\t\t\t\treturn curTimer.paused\n\t\t\t},\n\t\t\tset paused(p) {\n\t\t\t\tcurTimer.paused = p\n\t\t\t},\n\t\t\tcancel: () => curTimer.cancel(),\n\t\t}\n\n\t}\n\n\tfunction enterDebugMode() {\n\n\t\tapp.onKeyPress(\"f1\", () => {\n\t\t\tdebug.inspect = !debug.inspect\n\t\t})\n\n\t\tapp.onKeyPress(\"f2\", () => {\n\t\t\tdebug.clearLog()\n\t\t})\n\n\t\tapp.onKeyPress(\"f8\", () => {\n\t\t\tdebug.paused = !debug.paused\n\t\t})\n\n\t\tapp.onKeyPress(\"f7\", () => {\n\t\t\tdebug.timeScale = toFixed(clamp(debug.timeScale - 0.2, 0, 2), 1)\n\t\t})\n\n\t\tapp.onKeyPress(\"f9\", () => {\n\t\t\tdebug.timeScale = toFixed(clamp(debug.timeScale + 0.2, 0, 2), 1)\n\t\t})\n\n\t\tapp.onKeyPress(\"f10\", () => {\n\t\t\tdebug.stepFrame()\n\t\t})\n\n\t}\n\n\tfunction enterBurpMode() {\n\t\tapp.onKeyPress(\"b\", () => burp())\n\t}\n\n\tfunction setGravity(g: number) {\n\t\tgame.gravity = g\n\t}\n\n\tfunction getGravity() {\n\t\treturn game.gravity\n\t}\n\n\tfunction setBackground(...args) {\n\t\tif (args.length === 1 || args.length === 2) {\n\t\t\tgfx.bgColor = rgb(args[0])\n\t\t\tif (args[1]) gfx.bgAlpha = args[1]\n\t\t} else if (args.length === 3 || args.length === 4) {\n\t\t\tgfx.bgColor = rgb(args[0], args[1], args[2])\n\t\t\tif (args[3]) gfx.bgAlpha = args[3]\n\t\t}\n\t\tgl.clearColor(\n\t\t\tgfx.bgColor.r / 255,\n\t\t\tgfx.bgColor.g / 255,\n\t\t\tgfx.bgColor.b / 255,\n\t\t\tgfx.bgAlpha,\n\t\t)\n\t}\n\n\tfunction getBackground() {\n\t\treturn gfx.bgColor.clone()\n\t}\n\n\t// TODO: manage global velocity here?\n\tfunction pos(...args: Vec2Args): PosComp {\n\n\t\treturn {\n\n\t\t\tid: \"pos\",\n\t\t\tpos: vec2(...args),\n\n\t\t\tmoveBy(...args: Vec2Args) {\n\t\t\t\tthis.pos = this.pos.add(vec2(...args))\n\t\t\t},\n\n\t\t\t// move with velocity (pixels per second)\n\t\t\tmove(...args: Vec2Args) {\n\t\t\t\tthis.moveBy(vec2(...args).scale(dt()))\n\t\t\t},\n\n\t\t\t// move to a destination, with optional speed\n\t\t\tmoveTo(...args) {\n\t\t\t\tif (typeof args[0] === \"number\" && typeof args[1] === \"number\") {\n\t\t\t\t\treturn this.moveTo(vec2(args[0], args[1]), args[2])\n\t\t\t\t}\n\t\t\t\tconst dest = args[0]\n\t\t\t\tconst speed = args[1]\n\t\t\t\tif (speed === undefined) {\n\t\t\t\t\tthis.pos = vec2(dest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst diff = dest.sub(this.pos)\n\t\t\t\tif (diff.len() <= speed * dt()) {\n\t\t\t\t\tthis.pos = vec2(dest)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tthis.move(diff.unit().scale(speed))\n\t\t\t},\n\n\t\t\tworldPos(this: GameObj<PosComp>): Vec2 {\n\t\t\t\treturn this.parent\n\t\t\t\t\t? this.parent.transform.multVec2(this.pos)\n\t\t\t\t\t: this.pos\n\t\t\t},\n\n\t\t\t// get the screen position (transformed by camera)\n\t\t\tscreenPos(this: GameObj<PosComp | FixedComp>): Vec2 {\n\t\t\t\tconst pos = this.worldPos()\n\t\t\t\treturn isFixed(this)\n\t\t\t\t\t? pos\n\t\t\t\t\t: toScreen(pos)\n\t\t\t},\n\n\t\t\tinspect() {\n\t\t\t\treturn `(${Math.round(this.pos.x)}, ${Math.round(this.pos.y)})`\n\t\t\t},\n\n\t\t\tdrawInspect() {\n\t\t\t\tdrawCircle({\n\t\t\t\t\tcolor: rgb(255, 0, 0),\n\t\t\t\t\tradius: 4 / getViewportScale(),\n\t\t\t\t})\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\t// TODO: allow single number assignment\n\tfunction scale(...args: Vec2Args): ScaleComp {\n\t\tif (args.length === 0) {\n\t\t\treturn scale(1)\n\t\t}\n\t\treturn {\n\t\t\tid: \"scale\",\n\t\t\tscale: vec2(...args),\n\t\t\tscaleTo(...args: Vec2Args) {\n\t\t\t\tthis.scale = vec2(...args)\n\t\t\t},\n\t\t\tscaleBy(...args: Vec2Args) {\n\t\t\t\tthis.scale.scale(vec2(...args))\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn `(${toFixed(this.scale.x, 2)}, ${toFixed(this.scale.y, 2)})`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction rotate(r: number): RotateComp {\n\t\treturn {\n\t\t\tid: \"rotate\",\n\t\t\tangle: r ?? 0,\n\t\t\trotateBy(angle: number) {\n\t\t\t\tthis.angle += angle\n\t\t\t},\n\t\t\trotateTo(angle: number) {\n\t\t\t\tthis.angle = angle\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn `${Math.round(this.angle)}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction color(...args): ColorComp {\n\t\treturn {\n\t\t\tid: \"color\",\n\t\t\tcolor: rgb(...args),\n\t\t\tinspect() {\n\t\t\t\treturn this.color.toString()\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction toFixed(n: number, f: number) {\n\t\treturn Number(n.toFixed(f))\n\t}\n\n\t// TODO: fadeIn here?\n\tfunction opacity(a: number): OpacityComp {\n\t\treturn {\n\t\t\tid: \"opacity\",\n\t\t\topacity: a ?? 1,\n\t\t\tinspect() {\n\t\t\t\treturn `${toFixed(this.opacity, 1)}`\n\t\t\t},\n\t\t\tfadeOut(time = 1, easeFunc = easings.linear): TweenController {\n\t\t\t\treturn tween(this.opacity, 0, time, (a) => this.opacity = a, easeFunc)\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction anchor(o: Anchor | Vec2): AnchorComp {\n\t\tif (!o) {\n\t\t\tthrow new KaboomError(\"Please define an anchor\")\n\t\t}\n\t\treturn {\n\t\t\tid: \"anchor\",\n\t\t\tanchor: o,\n\t\t\tinspect() {\n\t\t\t\tif (typeof this.anchor === \"string\") {\n\t\t\t\t\treturn this.anchor\n\t\t\t\t} else {\n\t\t\t\t\treturn this.anchor.toString()\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction z(z: number): ZComp {\n\t\treturn {\n\t\t\tid: \"z\",\n\t\t\tz: z,\n\t\t\tinspect() {\n\t\t\t\treturn `${this.z}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction follow(obj: GameObj, offset?: Vec2): FollowComp {\n\t\treturn {\n\t\t\tid: \"follow\",\n\t\t\trequire: [ \"pos\" ],\n\t\t\tfollow: {\n\t\t\t\tobj: obj,\n\t\t\t\toffset: offset ?? vec2(0),\n\t\t\t},\n\t\t\tadd(this: GameObj<FollowComp | PosComp>) {\n\t\t\t\tif (obj.exists()) {\n\t\t\t\t\tthis.pos = this.follow.obj.pos.add(this.follow.offset)\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate(this: GameObj<FollowComp | PosComp>) {\n\t\t\t\tif (obj.exists()) {\n\t\t\t\t\tthis.pos = this.follow.obj.pos.add(this.follow.offset)\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction move(dir: number | Vec2, speed: number): EmptyComp {\n\t\tconst d = typeof dir === \"number\" ? Vec2.fromAngle(dir) : dir.unit()\n\t\treturn {\n\t\t\tid: \"move\",\n\t\t\trequire: [ \"pos\" ],\n\t\t\tupdate(this: GameObj<PosComp>) {\n\t\t\t\tthis.move(d.scale(speed))\n\t\t\t},\n\t\t}\n\t}\n\n\tconst DEF_OFFSCREEN_DIS = 200\n\n\tfunction offscreen(opt: OffScreenCompOpt = {}): OffScreenComp {\n\t\tconst distance = opt.distance ?? DEF_OFFSCREEN_DIS\n\t\tlet isOut = false\n\t\treturn {\n\t\t\tid: \"offscreen\",\n\t\t\trequire: [ \"pos\" ],\n\t\t\tisOffScreen(this: GameObj<PosComp>): boolean {\n\t\t\t\tconst pos = this.screenPos()\n\t\t\t\tconst screenRect = new Rect(vec2(0), width(), height())\n\t\t\t\treturn !testRectPoint(screenRect, pos)\n\t\t\t\t\t&& screenRect.sdistToPoint(pos) > distance * distance\n\t\t\t},\n\t\t\tonExitScreen(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"exitView\", action)\n\t\t\t},\n\t\t\tonEnterScreen(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"enterView\", action)\n\t\t\t},\n\t\t\tupdate(this: GameObj) {\n\t\t\t\tif (this.isOffScreen()) {\n\t\t\t\t\tif (!isOut) {\n\t\t\t\t\t\tthis.trigger(\"exitView\")\n\t\t\t\t\t\tisOut = true\n\t\t\t\t\t}\n\t\t\t\t\tif (opt.hide) this.hidden = true\n\t\t\t\t\tif (opt.pause) this.paused = true\n\t\t\t\t\tif (opt.destroy) this.destroy()\n\t\t\t\t} else {\n\t\t\t\t\tif (isOut) {\n\t\t\t\t\t\tthis.trigger(\"enterView\")\n\t\t\t\t\t\tisOut = false\n\t\t\t\t\t}\n\t\t\t\t\tif (opt.hide) this.hidden = false\n\t\t\t\t\tif (opt.pause) this.paused = false\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction isFixed(obj: GameObj) {\n\t\tif (obj.fixed) return true\n\t\treturn obj.parent ? isFixed(obj.parent) : false\n\t}\n\n\tfunction area(opt: AreaCompOpt = {}): AreaComp {\n\n\t\tconst colliding = {}\n\t\tconst collidingThisFrame = new Set()\n\n\t\treturn {\n\n\t\t\tid: \"area\",\n\t\t\tcollisionIgnore: opt.collisionIgnore ?? [],\n\n\t\t\tadd(this: GameObj<AreaComp>) {\n\n\t\t\t\tif (this.area.cursor) {\n\t\t\t\t\tthis.onHover(() => app.setCursor(this.area.cursor))\n\t\t\t\t}\n\n\t\t\t\tthis.onCollideUpdate((obj, col) => {\n\t\t\t\t\tif (!colliding[obj.id]) {\n\t\t\t\t\t\tthis.trigger(\"collide\", obj, col)\n\t\t\t\t\t}\n\t\t\t\t\tcolliding[obj.id] = col\n\t\t\t\t\tcollidingThisFrame.add(obj.id)\n\t\t\t\t})\n\n\t\t\t},\n\n\t\t\tupdate(this: GameObj<AreaComp>) {\n\t\t\t\tfor (const id in colliding) {\n\t\t\t\t\tif (!collidingThisFrame.has(Number(id))) {\n\t\t\t\t\t\tthis.trigger(\"collideEnd\", colliding[id].target)\n\t\t\t\t\t\tdelete colliding[id]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcollidingThisFrame.clear()\n\t\t\t},\n\n\t\t\tdrawInspect(this: GameObj<AreaComp | AnchorComp | FixedComp>) {\n\n\t\t\t\tconst a = this.localArea()\n\n\t\t\t\tpushTransform()\n\t\t\t\tpushScale(this.area.scale)\n\t\t\t\tpushTranslate(this.area.offset)\n\n\t\t\t\tconst opts = {\n\t\t\t\t\toutline: {\n\t\t\t\t\t\twidth: 4 / getViewportScale(),\n\t\t\t\t\t\tcolor: rgb(0, 0, 255),\n\t\t\t\t\t},\n\t\t\t\t\tanchor: this.anchor,\n\t\t\t\t\tfill: false,\n\t\t\t\t\tfixed: isFixed(this),\n\t\t\t\t}\n\n\t\t\t\tif (a instanceof Rect) {\n\t\t\t\t\tdrawRect({\n\t\t\t\t\t\t...opts,\n\t\t\t\t\t\tpos: a.pos,\n\t\t\t\t\t\twidth: a.width,\n\t\t\t\t\t\theight: a.height,\n\t\t\t\t\t})\n\t\t\t\t} else if (a instanceof Polygon) {\n\t\t\t\t\tdrawPolygon({\n\t\t\t\t\t\t...opts,\n\t\t\t\t\t\tpts: a.pts,\n\t\t\t\t\t})\n\t\t\t\t} else if (a instanceof Circle) {\n\t\t\t\t\tdrawCircle({\n\t\t\t\t\t\t...opts,\n\t\t\t\t\t\tpos: a.center,\n\t\t\t\t\t\tradius: a.radius,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tpopTransform()\n\n\t\t\t},\n\n\t\t\tarea: {\n\t\t\t\tshape: opt.shape ?? null,\n\t\t\t\tscale: opt.scale ? vec2(opt.scale) : vec2(1),\n\t\t\t\toffset: opt.offset ?? vec2(0),\n\t\t\t\tcursor: opt.cursor ?? null,\n\t\t\t},\n\n\t\t\tisClicked(): boolean {\n\t\t\t\treturn app.isMousePressed() && this.isHovering()\n\t\t\t},\n\n\t\t\tisHovering(this: GameObj) {\n\t\t\t\tconst mpos = isFixed(this) ? mousePos() : toWorld(mousePos())\n\t\t\t\treturn this.hasPoint(mpos)\n\t\t\t},\n\n\t\t\tcheckCollision(this: GameObj, other: GameObj<AreaComp>) {\n\t\t\t\treturn colliding[other.id] ?? null\n\t\t\t},\n\n\t\t\tgetCollisions() {\n\t\t\t\treturn Object.values(colliding)\n\t\t\t},\n\n\t\t\t// TODO: perform check instead of use cache\n\t\t\tisColliding(other: GameObj<AreaComp>) {\n\t\t\t\treturn Boolean(colliding[other.id])\n\t\t\t},\n\n\t\t\tisOverlapping(other) {\n\t\t\t\tconst col = colliding[other.id]\n\t\t\t\treturn col && col.hasOverlap()\n\t\t\t},\n\n\t\t\tonClick(this: GameObj<AreaComp>, f: () => void): EventController {\n\t\t\t\tconst e = app.onMousePress(\"left\", () => {\n\t\t\t\t\tif (this.isHovering()) {\n\t\t\t\t\t\tf()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\tthis.onDestroy(() => e.cancel())\n\t\t\t\treturn e\n\t\t\t},\n\n\t\t\tonHover(this: GameObj, action: () => void): EventController {\n\t\t\t\tlet hovering = false\n\t\t\t\treturn this.onUpdate(() => {\n\t\t\t\t\tif (!hovering) {\n\t\t\t\t\t\tif (this.isHovering()) {\n\t\t\t\t\t\t\thovering = true\n\t\t\t\t\t\t\taction()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thovering = this.isHovering()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tonHoverUpdate(this: GameObj, onHover: () => void): EventController {\n\t\t\t\treturn this.onUpdate(() => {\n\t\t\t\t\tif (this.isHovering()) {\n\t\t\t\t\t\tonHover()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tonHoverEnd(this: GameObj, action: () => void): EventController {\n\t\t\t\tlet hovering = false\n\t\t\t\treturn this.onUpdate(() => {\n\t\t\t\t\tif (hovering) {\n\t\t\t\t\t\tif (!this.isHovering()) {\n\t\t\t\t\t\t\thovering = false\n\t\t\t\t\t\t\taction()\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\thovering = this.isHovering()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tonCollide(\n\t\t\t\tthis: GameObj,\n\t\t\t\ttag: Tag | ((obj: GameObj, col?: Collision) => void),\n\t\t\t\tcb?: (obj: GameObj, col?: Collision) => void,\n\t\t\t): EventController {\n\t\t\t\tif (typeof tag === \"function\" && cb === undefined) {\n\t\t\t\t\treturn this.on(\"collide\", tag)\n\t\t\t\t} else if (typeof tag === \"string\") {\n\t\t\t\t\treturn this.onCollide((obj, col) => {\n\t\t\t\t\t\tif (obj.is(tag)) {\n\t\t\t\t\t\t\tcb(obj, col)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonCollideUpdate(\n\t\t\t\tthis: GameObj<AreaComp>,\n\t\t\t\ttag: Tag | ((obj: GameObj, col?: Collision) => void),\n\t\t\t\tcb?: (obj: GameObj, col?: Collision) => void,\n\t\t\t): EventController {\n\t\t\t\tif (typeof tag === \"function\" && cb === undefined) {\n\t\t\t\t\treturn this.on(\"collideUpdate\", tag)\n\t\t\t\t} else if (typeof tag === \"string\") {\n\t\t\t\t\treturn this.on(\"collideUpdate\", (obj, col) => obj.is(tag) && cb(obj, col))\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tonCollideEnd(\n\t\t\t\tthis: GameObj<AreaComp>,\n\t\t\t\ttag: Tag | ((obj: GameObj) => void),\n\t\t\t\tcb?: (obj: GameObj) => void,\n\t\t\t): EventController {\n\t\t\t\tif (typeof tag === \"function\" && cb === undefined) {\n\t\t\t\t\treturn this.on(\"collideEnd\", tag)\n\t\t\t\t} else if (typeof tag === \"string\") {\n\t\t\t\t\treturn this.on(\"collideEnd\", (obj) => obj.is(tag) && cb(obj))\n\t\t\t\t}\n\t\t\t},\n\n\t\t\thasPoint(pt: Vec2): boolean {\n\t\t\t\t// TODO: convert to pt to local space instead\n\t\t\t\treturn testPolygonPoint(this.worldArea(), pt)\n\t\t\t},\n\n\t\t\t// push an obj out of another if they're overlapped\n\t\t\tresolveCollision(this: GameObj<AreaComp | PosComp>, obj: GameObj<AreaComp>) {\n\t\t\t\tconst col = this.checkCollision(obj)\n\t\t\t\tif (col && !col.resolved) {\n\t\t\t\t\tthis.pos = this.pos.add(col.displacement)\n\t\t\t\t\tcol.resolved = true\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tlocalArea(this: GameObj<AreaComp | { renderArea(): Shape }>): Shape {\n\t\t\t\treturn this.area.shape\n\t\t\t\t\t? this.area.shape\n\t\t\t\t\t: this.renderArea()\n\t\t\t},\n\n\t\t\t// TODO: cache\n\t\t\tworldArea(this: GameObj<AreaComp | AnchorComp>): Polygon {\n\n\t\t\t\tconst localArea = this.localArea()\n\n\t\t\t\tif (!(localArea instanceof Polygon || localArea instanceof Rect)) {\n\t\t\t\t\tthrow new KaboomError(\"Only support polygon and rect shapes for now\")\n\t\t\t\t}\n\n\t\t\t\tconst transform = this.transform\n\t\t\t\t\t.clone()\n\t\t\t\t\t.scale(vec2(this.area.scale ?? 1))\n\t\t\t\t\t.translate(this.area.offset)\n\n\t\t\t\tif (localArea instanceof Rect) {\n\t\t\t\t\tconst offset = anchorPt(this.anchor || DEF_ANCHOR)\n\t\t\t\t\t\t.add(1, 1)\n\t\t\t\t\t\t.scale(-0.5)\n\t\t\t\t\t\t.scale(localArea.width, localArea.height)\n\t\t\t\t\ttransform.translate(offset)\n\t\t\t\t}\n\n\t\t\t\treturn localArea.transform(transform) as Polygon\n\n\t\t\t},\n\n\t\t\tscreenArea(this: GameObj<AreaComp | FixedComp>): Polygon {\n\t\t\t\tconst area = this.worldArea()\n\t\t\t\tif (isFixed(this)) {\n\t\t\t\t\treturn area\n\t\t\t\t} else {\n\t\t\t\t\treturn area.transform(game.cam.transform)\n\t\t\t\t}\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction getRenderProps(obj: GameObj<any>) {\n\t\treturn {\n\t\t\tcolor: obj.color,\n\t\t\topacity: obj.opacity,\n\t\t\tanchor: obj.anchor,\n\t\t\toutline: obj.outline,\n\t\t\tshader: obj.shader,\n\t\t\tuniform: obj.uniform,\n\t\t}\n\t}\n\n\t// TODO: clean\n\tfunction sprite(\n\t\tsrc: string | SpriteData | Asset<SpriteData>,\n\t\topt: SpriteCompOpt = {},\n\t): SpriteComp {\n\n\t\tlet spriteData: SpriteData | null = null\n\t\tlet curAnim: SpriteCurAnim | null = null\n\t\t// 1  - from small index to large index\n\t\t// -1 - reverse\n\t\tlet curAnimDir: -1 | 1 | null = null\n\t\tconst spriteLoadedEvent = new Event<[SpriteData]>()\n\n\t\tif (!src) {\n\t\t\tthrow new KaboomError(\"Please pass the resource name or data to sprite()\")\n\t\t}\n\n\t\tconst calcTexScale = (tex: Texture, q: Quad, w?: number, h?: number): Vec2 => {\n\t\t\tconst scale = vec2(1, 1)\n\t\t\tif (w && h) {\n\t\t\t\tscale.x = w / (tex.width * q.w)\n\t\t\t\tscale.y = h / (tex.height * q.h)\n\t\t\t} else if (w) {\n\t\t\t\tscale.x = w / (tex.width * q.w)\n\t\t\t\tscale.y = scale.x\n\t\t\t} else if (h) {\n\t\t\t\tscale.y = h / (tex.height * q.h)\n\t\t\t\tscale.x = scale.y\n\t\t\t}\n\t\t\treturn scale\n\t\t}\n\n\t\treturn {\n\n\t\t\tid: \"sprite\",\n\t\t\t// TODO: allow update\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tframe: opt.frame || 0,\n\t\t\tquad: opt.quad || new Quad(0, 0, 1, 1),\n\t\t\tanimSpeed: opt.animSpeed ?? 1,\n\t\t\tflipX: opt.flipX ?? false,\n\t\t\tflipY: opt.flipY ?? false,\n\n\t\t\tdraw(this: GameObj<SpriteComp>) {\n\n\t\t\t\tif (!spriteData) return\n\n\t\t\t\tconst q = spriteData.frames[this.frame ?? 0]\n\n\t\t\t\tif (!q) {\n\t\t\t\t\tthrow new KaboomError(`Frame not found: ${this.frame ?? 0}`)\n\t\t\t\t}\n\n\t\t\t\tif (spriteData.slice9) {\n\t\t\t\t\t// TODO: tile\n\t\t\t\t\t// TODO: use scale or width / height, or both?\n\t\t\t\t\tconst { left, right, top, bottom } = spriteData.slice9\n\t\t\t\t\tconst tw = spriteData.tex.width * q.w\n\t\t\t\t\tconst th = spriteData.tex.height * q.h\n\t\t\t\t\tconst iw = this.width - left - right\n\t\t\t\t\tconst ih = this.height - top - bottom\n\t\t\t\t\tconst w1 = left / tw\n\t\t\t\t\tconst w3 = right / tw\n\t\t\t\t\tconst w2 = 1 - w1 - w3\n\t\t\t\t\tconst h1 = top / th\n\t\t\t\t\tconst h3 = bottom / th\n\t\t\t\t\tconst h2 = 1 - h1 - h3\n\t\t\t\t\tconst quads = [\n\t\t\t\t\t\t// uv\n\t\t\t\t\t\tquad(0,       0,       w1, h1),\n\t\t\t\t\t\tquad(w1,      0,       w2, h1),\n\t\t\t\t\t\tquad(w1 + w2, 0,       w3, h1),\n\t\t\t\t\t\tquad(0,       h1,      w1, h2),\n\t\t\t\t\t\tquad(w1,      h1,      w2, h2),\n\t\t\t\t\t\tquad(w1 + w2, h1,      w3, h2),\n\t\t\t\t\t\tquad(0,       h1 + h2, w1, h3),\n\t\t\t\t\t\tquad(w1,      h1 + h2, w2, h3),\n\t\t\t\t\t\tquad(w1 + w2, h1 + h2, w3, h3),\n\t\t\t\t\t\t// transform\n\t\t\t\t\t\tquad(0,         0,        left,  top),\n\t\t\t\t\t\tquad(left,      0,        iw,    top),\n\t\t\t\t\t\tquad(left + iw, 0,        right, top),\n\t\t\t\t\t\tquad(0,         top,      left,  ih),\n\t\t\t\t\t\tquad(left,      top,      iw,    ih),\n\t\t\t\t\t\tquad(left + iw, top,      right, ih),\n\t\t\t\t\t\tquad(0,         top + ih, left,  bottom),\n\t\t\t\t\t\tquad(left,      top + ih, iw,    bottom),\n\t\t\t\t\t\tquad(left + iw, top + ih, right, bottom),\n\t\t\t\t\t]\n\t\t\t\t\tfor (let i = 0; i < 9; i++) {\n\t\t\t\t\t\tconst uv = quads[i]\n\t\t\t\t\t\tconst transform = quads[i + 9]\n\t\t\t\t\t\tdrawTexture(Object.assign(getRenderProps(this), {\n\t\t\t\t\t\t\tpos: transform.pos(),\n\t\t\t\t\t\t\ttex: spriteData.tex,\n\t\t\t\t\t\t\tquad: q.scale(uv),\n\t\t\t\t\t\t\tflipX: this.flipX,\n\t\t\t\t\t\t\tflipY: this.flipY,\n\t\t\t\t\t\t\ttiled: opt.tiled,\n\t\t\t\t\t\t\twidth: transform.w,\n\t\t\t\t\t\t\theight: transform.h,\n\t\t\t\t\t\t}))\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tdrawTexture(Object.assign(getRenderProps(this), {\n\t\t\t\t\t\ttex: spriteData.tex,\n\t\t\t\t\t\tquad: q.scale(this.quad ?? new Quad(0, 0, 1, 1)),\n\t\t\t\t\t\tflipX: this.flipX,\n\t\t\t\t\t\tflipY: this.flipY,\n\t\t\t\t\t\ttiled: opt.tiled,\n\t\t\t\t\t\twidth: this.width,\n\t\t\t\t\t\theight: this.height,\n\t\t\t\t\t}))\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tadd(this: GameObj<SpriteComp>) {\n\n\t\t\t\tconst setSpriteData = (spr) => {\n\n\t\t\t\t\tlet q = spr.frames[0].clone()\n\n\t\t\t\t\tif (opt.quad) {\n\t\t\t\t\t\tq = q.scale(opt.quad)\n\t\t\t\t\t}\n\n\t\t\t\t\tconst scale = calcTexScale(spr.tex, q, opt.width, opt.height)\n\n\t\t\t\t\tthis.width = spr.tex.width * q.w * scale.x\n\t\t\t\t\tthis.height = spr.tex.height * q.h * scale.y\n\n\t\t\t\t\tif (opt.anim) {\n\t\t\t\t\t\tthis.play(opt.anim)\n\t\t\t\t\t}\n\n\t\t\t\t\tspriteData = spr\n\t\t\t\t\tspriteLoadedEvent.trigger(spriteData)\n\n\t\t\t\t}\n\n\t\t\t\tconst spr = resolveSprite(src)\n\n\t\t\t\tif (spr) {\n\t\t\t\t\tspr.onLoad(setSpriteData)\n\t\t\t\t} else {\n\t\t\t\t\tonLoad(() => setSpriteData(resolveSprite(src).data))\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tupdate(this: GameObj<SpriteComp>) {\n\n\t\t\t\tif (!curAnim) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst anim = spriteData.anims[curAnim.name]\n\n\t\t\t\tif (typeof anim === \"number\") {\n\t\t\t\t\tthis.frame = anim\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (anim.speed === 0) {\n\t\t\t\t\tthrow new KaboomError(\"Sprite anim speed cannot be 0\")\n\t\t\t\t}\n\n\t\t\t\tcurAnim.timer += dt() * this.animSpeed\n\n\t\t\t\tif (curAnim.timer >= (1 / curAnim.speed)) {\n\n\t\t\t\t\tcurAnim.timer = 0\n\t\t\t\t\tthis.frame += curAnimDir\n\n\t\t\t\t\tif (this.frame < Math.min(anim.from, anim.to) ||\n\t\t\t\t\t\tthis.frame > Math.max(anim.from, anim.to)) {\n\t\t\t\t\t\tif (curAnim.loop) {\n\t\t\t\t\t\t\tif (curAnim.pingpong) {\n\t\t\t\t\t\t\t\tthis.frame -= curAnimDir\n\t\t\t\t\t\t\t\tcurAnimDir *= -1\n\t\t\t\t\t\t\t\tthis.frame += curAnimDir\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.frame = anim.from\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.frame = anim.to\n\t\t\t\t\t\t\tcurAnim.onEnd()\n\t\t\t\t\t\t\tthis.stop()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t},\n\n\t\t\tplay(this: GameObj<SpriteComp>, name: string, opt: SpriteAnimPlayOpt = {}) {\n\n\t\t\t\tif (!spriteData) {\n\t\t\t\t\tspriteLoadedEvent.add(() => this.play(name, opt))\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tconst anim = spriteData.anims[name]\n\n\t\t\t\tif (anim === undefined) {\n\t\t\t\t\tthrow new KaboomError(`Anim not found: ${name}`)\n\t\t\t\t}\n\n\t\t\t\tif (curAnim) {\n\t\t\t\t\tthis.stop()\n\t\t\t\t}\n\n\t\t\t\tcurAnim = typeof anim === \"number\"\n\t\t\t\t\t? {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\ttimer: 0,\n\t\t\t\t\t\tloop: false,\n\t\t\t\t\t\tpingpong: false,\n\t\t\t\t\t\tspeed: 0,\n\t\t\t\t\t\tonEnd: () => {},\n\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\tname: name,\n\t\t\t\t\t\ttimer: 0,\n\t\t\t\t\t\tloop: opt.loop ?? anim.loop ?? false,\n\t\t\t\t\t\tpingpong: opt.pingpong ?? anim.pingpong ?? false,\n\t\t\t\t\t\tspeed: opt.speed ?? anim.speed ?? 10,\n\t\t\t\t\t\tonEnd: opt.onEnd ?? (() => {}),\n\t\t\t\t\t}\n\n\t\t\t\tcurAnimDir = typeof anim === \"number\"\n\t\t\t\t\t? null\n\t\t\t\t\t: anim.from < anim.to ? 1 : -1\n\n\t\t\t\tthis.frame = typeof anim === \"number\"\n\t\t\t\t\t? anim\n\t\t\t\t\t: anim.from\n\n\t\t\t\tthis.trigger(\"animStart\", name)\n\n\t\t\t},\n\n\t\t\tstop(this: GameObj<SpriteComp>) {\n\t\t\t\tif (!curAnim) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tconst prevAnim = curAnim.name\n\t\t\t\tcurAnim = null\n\t\t\t\tthis.trigger(\"animEnd\", prevAnim)\n\t\t\t},\n\n\t\t\tnumFrames() {\n\t\t\t\treturn spriteData?.frames.length ?? 0\n\t\t\t},\n\n\t\t\tcurAnim() {\n\t\t\t\treturn curAnim?.name\n\t\t\t},\n\n\t\t\tonAnimEnd(\n\t\t\t\tthis: GameObj<SpriteComp>,\n\t\t\t\taction: (name: string) => void,\n\t\t\t): EventController {\n\t\t\t\treturn this.on(\"animEnd\", action)\n\t\t\t},\n\n\t\t\tonAnimStart(\n\t\t\t\tthis: GameObj<SpriteComp>,\n\t\t\t\taction: (name: string) => void,\n\t\t\t): EventController {\n\t\t\t\treturn this.on(\"animStart\", action)\n\t\t\t},\n\n\t\t\trenderArea() {\n\t\t\t\treturn new Rect(vec2(0), this.width, this.height)\n\t\t\t},\n\n\t\t\tinspect() {\n\t\t\t\tif (typeof src === \"string\") {\n\t\t\t\t\treturn `\"${src}\"`\n\t\t\t\t}\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction text(t: string, opt: TextCompOpt = {}): TextComp {\n\n\t\tfunction update(obj: GameObj<TextComp | any>) {\n\n\t\t\tconst ftext = formatText(Object.assign(getRenderProps(obj), {\n\t\t\t\ttext: obj.text + \"\",\n\t\t\t\tsize: obj.textSize,\n\t\t\t\tfont: obj.font,\n\t\t\t\twidth: opt.width && obj.width,\n\t\t\t\talign: obj.align,\n\t\t\t\tletterSpacing: obj.letterSpacing,\n\t\t\t\tlineSpacing: obj.lineSpacing,\n\t\t\t\t// TODO: shouldn't run when object / ancestor is paused\n\t\t\t\ttransform: obj.textTransform,\n\t\t\t\tstyles: obj.textStyles,\n\t\t\t}))\n\n\t\t\tif (!opt.width) {\n\t\t\t\tobj.width = ftext.width / (obj.scale?.x || 1)\n\t\t\t}\n\n\t\t\tobj.height = ftext.height / (obj.scale?.y || 1)\n\n\t\t\treturn ftext\n\n\t\t}\n\n\t\tconst obj = {\n\n\t\t\tid: \"text\",\n\t\t\tset text(nt) {\n\t\t\t\tt = nt\n\t\t\t\t// @ts-ignore\n\t\t\t\tupdate(this)\n\t\t\t},\n\t\t\tget text() {\n\t\t\t\treturn t\n\t\t\t},\n\t\t\ttextSize: opt.size ?? DEF_TEXT_SIZE,\n\t\t\tfont: opt.font,\n\t\t\twidth: opt.width ?? 0,\n\t\t\theight: 0,\n\t\t\talign: opt.align,\n\t\t\tlineSpacing: opt.lineSpacing,\n\t\t\tletterSpacing: opt.letterSpacing,\n\t\t\ttextTransform: opt.transform,\n\t\t\ttextStyles: opt.styles,\n\n\t\t\tadd(this: GameObj<TextComp>) {\n\t\t\t\tonLoad(() => update(this))\n\t\t\t},\n\n\t\t\tdraw(this: GameObj<TextComp>) {\n\t\t\t\tdrawFormattedText(update(this))\n\t\t\t},\n\n\t\t\trenderArea() {\n\t\t\t\treturn new Rect(vec2(0), this.width, this.height)\n\t\t\t},\n\n\t\t}\n\n\t\t// @ts-ignore\n\t\tupdate(obj)\n\n\t\treturn obj\n\n\t}\n\n\tfunction rect(w: number, h: number, opt: RectCompOpt = {}): RectComp {\n\t\treturn {\n\t\t\tid: \"rect\",\n\t\t\twidth: w,\n\t\t\theight: h,\n\t\t\tradius: opt.radius || 0,\n\t\t\tdraw(this: GameObj<RectComp>) {\n\t\t\t\tdrawRect(Object.assign(getRenderProps(this), {\n\t\t\t\t\twidth: this.width,\n\t\t\t\t\theight: this.height,\n\t\t\t\t\tradius: this.radius,\n\t\t\t\t\tfill: opt.fill,\n\t\t\t\t}))\n\t\t\t},\n\t\t\trenderArea() {\n\t\t\t\treturn new Rect(vec2(0), this.width, this.height)\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction uvquad(w: number, h: number): UVQuadComp {\n\t\treturn {\n\t\t\tid: \"rect\",\n\t\t\twidth: w,\n\t\t\theight: h,\n\t\t\tdraw(this: GameObj<UVQuadComp>) {\n\t\t\t\tdrawUVQuad(Object.assign(getRenderProps(this), {\n\t\t\t\t\twidth: this.width,\n\t\t\t\t\theight: this.height,\n\t\t\t\t}))\n\t\t\t},\n\t\t\trenderArea() {\n\t\t\t\treturn new Rect(vec2(0), this.width, this.height)\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn `${Math.ceil(this.width)}, ${Math.ceil(this.height)}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction circle(radius: number, opt: CircleCompOpt = {}): CircleComp {\n\t\treturn {\n\t\t\tid: \"circle\",\n\t\t\tradius: radius,\n\t\t\tdraw(this: GameObj<CircleComp>) {\n\t\t\t\tdrawCircle(Object.assign(getRenderProps(this), {\n\t\t\t\t\tradius: this.radius,\n\t\t\t\t\tfill: opt.fill,\n\t\t\t\t}))\n\t\t\t},\n\t\t\trenderArea(this: GameObj<AnchorComp | CircleComp>) {\n\t\t\t\treturn new Rect(new Vec2(this.anchor ? 0 : -this.radius), this.radius * 2, this.radius * 2)\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn `${Math.ceil(this.radius)}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction outline(width: number = 1, color: Color = rgb(0, 0, 0)): OutlineComp {\n\t\treturn {\n\t\t\tid: \"outline\",\n\t\t\toutline: {\n\t\t\t\twidth,\n\t\t\t\tcolor,\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction timer(): TimerComp {\n\t\treturn {\n\t\t\tid: \"timer\",\n\t\t\twait(this: GameObj<TimerComp>, time: number, action?: () => void): TimerController {\n\t\t\t\tconst actions = []\n\t\t\t\tif (action) actions.push(action)\n\t\t\t\tlet t = 0\n\t\t\t\tconst ev = this.onUpdate(() => {\n\t\t\t\t\tt += dt()\n\t\t\t\t\tif (t >= time) {\n\t\t\t\t\t\tactions.forEach((f) => f())\n\t\t\t\t\t\tev.cancel()\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn {\n\t\t\t\t\tget paused() {\n\t\t\t\t\t\treturn ev.paused\n\t\t\t\t\t},\n\t\t\t\t\tset paused(p) {\n\t\t\t\t\t\tev.paused = p\n\t\t\t\t\t},\n\t\t\t\t\tcancel: ev.cancel,\n\t\t\t\t\tonEnd(action) {\n\t\t\t\t\t\tactions.push(action)\n\t\t\t\t\t},\n\t\t\t\t\tthen(action) {\n\t\t\t\t\t\tthis.onEnd(action)\n\t\t\t\t\t\treturn this\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t\tloop(t: number, action: () => void): EventController {\n\t\t\t\tlet curTimer: null | TimerController = null\n\t\t\t\tconst newAction = () => {\n\t\t\t\t\t// TODO: should f be execute right away as loop() is called?\n\t\t\t\t\tcurTimer = this.wait(t, newAction)\n\t\t\t\t\taction()\n\t\t\t\t}\n\t\t\t\tcurTimer = this.wait(0, newAction)\n\t\t\t\treturn {\n\t\t\t\t\tget paused() {\n\t\t\t\t\t\treturn curTimer.paused\n\t\t\t\t\t},\n\t\t\t\t\tset paused(p) {\n\t\t\t\t\t\tcurTimer.paused = p\n\t\t\t\t\t},\n\t\t\t\t\tcancel: () => curTimer.cancel(),\n\t\t\t\t}\n\t\t\t},\n\t\t\ttween<V extends LerpValue>(\n\t\t\t\tthis: GameObj<TimerComp>,\n\t\t\t\tfrom: V,\n\t\t\t\tto: V,\n\t\t\t\tduration: number,\n\t\t\t\tsetValue: (value: V) => void,\n\t\t\t\teaseFunc = easings.linear,\n\t\t\t) {\n\t\t\t\tlet curTime = 0\n\t\t\t\tconst onEndEvents: Array<() => void> = []\n\t\t\t\tconst ev = this.onUpdate(() => {\n\t\t\t\t\tcurTime += dt()\n\t\t\t\t\tconst t = Math.min(curTime / duration, 1)\n\t\t\t\t\tsetValue(lerp(from, to, easeFunc(t)))\n\t\t\t\t\tif (t === 1) {\n\t\t\t\t\t\tev.cancel()\n\t\t\t\t\t\tsetValue(to)\n\t\t\t\t\t\tonEndEvents.forEach((action) => action())\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\treturn {\n\t\t\t\t\tget paused() {\n\t\t\t\t\t\treturn ev.paused\n\t\t\t\t\t},\n\t\t\t\t\tset paused(p) {\n\t\t\t\t\t\tev.paused = p\n\t\t\t\t\t},\n\t\t\t\t\tonEnd(action: () => void) {\n\t\t\t\t\t\tonEndEvents.push(action)\n\t\t\t\t\t},\n\t\t\t\t\tthen(action: () => void) {\n\t\t\t\t\t\tthis.onEnd(action)\n\t\t\t\t\t\treturn this\n\t\t\t\t\t},\n\t\t\t\t\tcancel() {\n\t\t\t\t\t\tev.cancel()\n\t\t\t\t\t},\n\t\t\t\t\tfinish() {\n\t\t\t\t\t\tev.cancel()\n\t\t\t\t\t\tsetValue(to)\n\t\t\t\t\t\tonEndEvents.forEach((action) => action())\n\t\t\t\t\t},\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\t// maximum y velocity with body()\n\tconst DEF_JUMP_FORCE = 640\n\tconst MAX_VEL = 65536\n\n\t// TODO: land on wall\n\tfunction body(opt: BodyCompOpt = {}): BodyComp {\n\n\t\tconst vel = vec2(0)\n\t\tlet curPlatform: GameObj<PosComp | AreaComp | BodyComp> | null = null\n\t\tlet lastPlatformPos = null\n\t\tlet wantFall = false\n\n\t\treturn {\n\n\t\t\tid: \"body\",\n\t\t\trequire: [ \"pos\", \"area\" ],\n\t\t\tjumpForce: opt.jumpForce ?? DEF_JUMP_FORCE,\n\t\t\tgravityScale: opt.gravityScale ?? 1,\n\t\t\tisStatic: opt.isStatic ?? false,\n\t\t\t// TODO: prefer density * area()\n\t\t\tmass: opt.mass ?? 1,\n\n\t\t\tadd(this: GameObj<PosComp | BodyComp | AreaComp>) {\n\n\t\t\t\tif (this.mass === 0) {\n\t\t\t\t\tthrow new KaboomError(\"Can't set body mass to 0\")\n\t\t\t\t}\n\n\t\t\t\t// static vs static: don't resolve\n\t\t\t\t// static vs non-static: always resolve non-static\n\t\t\t\t// non-static vs non-static: resolve the first one\n\t\t\t\tthis.onCollideUpdate((other: GameObj<PosComp | BodyComp>, col) => {\n\n\t\t\t\t\tif (!other.is(\"body\")) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif (col.resolved) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.trigger(\"beforePhysicsResolve\", col)\n\t\t\t\t\tother.trigger(\"beforePhysicsResolve\", col.reverse())\n\n\t\t\t\t\t// user can mark 'resolved' in beforePhysicsResolve to stop a resolution\n\t\t\t\t\tif (col.resolved) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.isStatic && other.isStatic) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else if (!this.isStatic && !other.isStatic) {\n\t\t\t\t\t\t// TODO: update all children transform?\n\t\t\t\t\t\tconst tmass = this.mass + other.mass\n\t\t\t\t\t\tthis.pos = this.pos.add(col.displacement.scale(other.mass / tmass))\n\t\t\t\t\t\tother.pos = other.pos.add(col.displacement.scale(-this.mass / tmass))\n\t\t\t\t\t\tthis.transform = calcTransform(this)\n\t\t\t\t\t\tother.transform = calcTransform(other)\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if one is static and on is not, resolve the non static one\n\t\t\t\t\t\tconst col2 = (!this.isStatic && other.isStatic) ? col : col.reverse()\n\t\t\t\t\t\tcol2.source.pos = col2.source.pos.add(col2.displacement)\n\t\t\t\t\t\tcol2.source.transform = calcTransform(col2.source)\n\t\t\t\t\t}\n\n\t\t\t\t\tcol.resolved = true\n\t\t\t\t\tthis.trigger(\"physicsResolve\", col)\n\t\t\t\t\tother.trigger(\"physicsResolve\", col.reverse())\n\n\t\t\t\t})\n\n\t\t\t\tthis.onPhysicsResolve((col) => {\n\t\t\t\t\tif (game.gravity) {\n\t\t\t\t\t\tif (col.isBottom() && this.isFalling()) {\n\t\t\t\t\t\t\tvel.y = 0\n\t\t\t\t\t\t\tcurPlatform = col.target as GameObj<PosComp | BodyComp | AreaComp>\n\t\t\t\t\t\t\tlastPlatformPos = col.target.pos\n\t\t\t\t\t\t\tif (wantFall) {\n\t\t\t\t\t\t\t\twantFall = false\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.trigger(\"ground\", curPlatform)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (col.isTop() && this.isJumping()) {\n\t\t\t\t\t\t\tvel.y = 0\n\t\t\t\t\t\t\tthis.trigger(\"headbutt\", col.target)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t},\n\n\t\t\tupdate(this: GameObj<PosComp | BodyComp | AreaComp>) {\n\n\t\t\t\tif (!game.gravity) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (this.isStatic) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tif (wantFall) {\n\t\t\t\t\tcurPlatform = null\n\t\t\t\t\tlastPlatformPos = null\n\t\t\t\t\tthis.trigger(\"fallOff\")\n\t\t\t\t\twantFall = false\n\t\t\t\t}\n\n\t\t\t\tif (curPlatform) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t!this.isOverlapping(curPlatform)\n\t\t\t\t\t\t|| !curPlatform.exists()\n\t\t\t\t\t\t|| !curPlatform.is(\"body\")\n\t\t\t\t\t) {\n\t\t\t\t\t\twantFall = true\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!curPlatform.pos.eq(lastPlatformPos)\n\t\t\t\t\t\t\t&& opt.stickToPlatform !== false\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.moveBy(curPlatform.pos.sub(lastPlatformPos))\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlastPlatformPos = curPlatform.pos\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst prevVelY = vel.y\n\t\t\t\tvel.y += game.gravity * this.gravityScale * dt()\n\t\t\t\tvel.y = Math.min(vel.y, opt.maxVelocity ?? MAX_VEL)\n\t\t\t\tif (prevVelY < 0 && vel.y >= 0) {\n\t\t\t\t\tthis.trigger(\"fall\")\n\t\t\t\t}\n\t\t\t\tthis.move(vel)\n\n\t\t\t},\n\n\t\t\tonPhysicsResolve(this: GameObj, action) {\n\t\t\t\treturn this.on(\"physicsResolve\", action)\n\t\t\t},\n\n\t\t\tonBeforePhysicsResolve(this: GameObj, action) {\n\t\t\t\treturn this.on(\"beforePhysicsResolve\", action)\n\t\t\t},\n\n\t\t\tcurPlatform(): GameObj | null {\n\t\t\t\treturn curPlatform\n\t\t\t},\n\n\t\t\tisGrounded() {\n\t\t\t\treturn curPlatform !== null\n\t\t\t},\n\n\t\t\tisFalling(): boolean {\n\t\t\t\treturn vel.y > 0\n\t\t\t},\n\n\t\t\tisJumping(): boolean {\n\t\t\t\treturn vel.y < 0\n\t\t\t},\n\n\t\t\tjump(force: number) {\n\t\t\t\tcurPlatform = null\n\t\t\t\tlastPlatformPos = null\n\t\t\t\tvel.y = -force || -this.jumpForce\n\t\t\t},\n\n\t\t\tonGround(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"ground\", action)\n\t\t\t},\n\n\t\t\tonFall(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"fall\", action)\n\t\t\t},\n\n\t\t\tonFallOff(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"fallOff\", action)\n\t\t\t},\n\n\t\t\tonHeadbutt(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"headbutt\", action)\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction doubleJump(numJumps: number = 2): DoubleJumpComp {\n\t\tlet jumpsLeft = numJumps\n\t\treturn {\n\t\t\tid: \"doubleJump\",\n\t\t\trequire: [ \"body\" ],\n\t\t\tnumJumps: numJumps,\n\t\t\tadd(this: GameObj<BodyComp | DoubleJumpComp>) {\n\t\t\t\tthis.onGround(() => {\n\t\t\t\t\tjumpsLeft = this.numJumps\n\t\t\t\t})\n\t\t\t},\n\t\t\tdoubleJump(this: GameObj<BodyComp | DoubleJumpComp>, force?: number) {\n\t\t\t\tif (jumpsLeft <= 0) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (jumpsLeft < this.numJumps) {\n\t\t\t\t\tthis.trigger(\"doubleJump\")\n\t\t\t\t}\n\t\t\t\tjumpsLeft--\n\t\t\t\tthis.jump(force)\n\t\t\t},\n\t\t\tonDoubleJump(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"doubleJump\", action)\n\t\t\t},\n\t\t\tinspect(this: GameObj<BodyComp | DoubleJumpComp>) {\n\t\t\t\treturn `${jumpsLeft}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction shader(id: string, uniform?: Uniform | (() => Uniform)): ShaderComp {\n\t\treturn {\n\t\t\tid: \"shader\",\n\t\t\tshader: id,\n\t\t\t...(typeof uniform === \"function\" ? {\n\t\t\t\tuniform: uniform(),\n\t\t\t\tupdate() {\n\t\t\t\t\tthis.uniform = uniform()\n\t\t\t\t},\n\t\t\t} : {\n\t\t\t\tuniform: uniform,\n\t\t\t}),\n\t\t}\n\t}\n\n\tfunction fixed(): FixedComp {\n\t\treturn {\n\t\t\tid: \"fixed\",\n\t\t\tfixed: true,\n\t\t}\n\t}\n\n\tfunction stay(scenesToStay?: string[]): StayComp {\n\t\treturn {\n\t\t\tid: \"stay\",\n\t\t\tstay: true,\n\t\t\tscenesToStay: scenesToStay,\n\t\t}\n\t}\n\n\tfunction health(hp: number): HealthComp {\n\t\tif (hp == null) {\n\t\t\tthrow new KaboomError(\"health() requires the initial amount of hp\")\n\t\t}\n\t\tconst maxHP = hp\n\t\treturn {\n\t\t\tid: \"health\",\n\t\t\thurt(this: GameObj, n: number = 1) {\n\t\t\t\tthis.setHP(hp - n)\n\t\t\t\tthis.trigger(\"hurt\", n)\n\t\t\t},\n\t\t\theal(this: GameObj, n: number = 1) {\n\t\t\t\tthis.setHP(hp + n)\n\t\t\t\tthis.trigger(\"heal\", n)\n\t\t\t},\n\t\t\thp(): number {\n\t\t\t\treturn hp\n\t\t\t},\n\t\t\tmaxHP(): number {\n\t\t\t\treturn maxHP\n\t\t\t},\n\t\t\tsetHP(this: GameObj, n: number) {\n\t\t\t\thp = n\n\t\t\t\tif (hp <= 0) {\n\t\t\t\t\tthis.trigger(\"death\")\n\t\t\t\t}\n\t\t\t},\n\t\t\tonHurt(this: GameObj, action: (amount?: number) => void): EventController {\n\t\t\t\treturn this.on(\"hurt\", action)\n\t\t\t},\n\t\t\tonHeal(this: GameObj, action: (amount?: number) => void): EventController {\n\t\t\t\treturn this.on(\"heal\", action)\n\t\t\t},\n\t\t\tonDeath(this: GameObj, action: () => void): EventController {\n\t\t\t\treturn this.on(\"death\", action)\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn `${hp}`\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction lifespan(time: number, opt: LifespanCompOpt = {}): EmptyComp {\n\t\tif (time == null) {\n\t\t\tthrow new KaboomError(\"lifespan() requires time\")\n\t\t}\n\t\tconst fade = opt.fade ?? 0\n\t\treturn {\n\t\t\tid: \"lifespan\",\n\t\t\tasync add(this: GameObj<OpacityComp>) {\n\t\t\t\tawait wait(time)\n\t\t\t\t// TODO: this secretively requires opacity comp, make opacity on every game obj?\n\t\t\t\tif (fade > 0 && this.opacity) {\n\t\t\t\t\tawait tween(this.opacity, 0, fade, (a) => this.opacity = a, easings.linear)\n\t\t\t\t}\n\t\t\t\tthis.destroy()\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction state(\n\t\tinitState: string,\n\t\tstateList?: string[],\n\t\ttransitions?: Record<string, string | string[]>,\n\t): StateComp {\n\n\t\tif (!initState) {\n\t\t\tthrow new KaboomError(\"state() requires an initial state\")\n\t\t}\n\n\t\tconst events = {}\n\n\t\tfunction initStateEvents(state: string) {\n\t\t\tif (!events[state]) {\n\t\t\t\tevents[state] = {\n\t\t\t\t\tenter: new Event(),\n\t\t\t\t\tend: new Event(),\n\t\t\t\t\tupdate: new Event(),\n\t\t\t\t\tdraw: new Event(),\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction on(event, state, action) {\n\t\t\tinitStateEvents(state)\n\t\t\treturn events[state][event].add(action)\n\t\t}\n\n\t\tfunction trigger(event, state, ...args) {\n\t\t\tinitStateEvents(state)\n\t\t\tevents[state][event].trigger(...args)\n\t\t}\n\n\t\tlet didFirstEnter = false\n\n\t\treturn {\n\n\t\t\tid: \"state\",\n\t\t\tstate: initState,\n\n\t\t\tenterState(state: string, ...args) {\n\n\t\t\t\tdidFirstEnter = true\n\n\t\t\t\tif (stateList && !stateList.includes(state)) {\n\t\t\t\t\tthrow new KaboomError(`State not found: ${state}`)\n\t\t\t\t}\n\n\t\t\t\tconst oldState = this.state\n\n\t\t\t\tif (transitions) {\n\n\t\t\t\t\t// check if the transition is legal, if transition graph is defined\n\t\t\t\t\tif (!transitions?.[oldState]) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tconst available = typeof transitions[oldState] === \"string\"\n\t\t\t\t\t\t? [transitions[oldState]]\n\t\t\t\t\t\t: transitions[oldState] as string[]\n\n\t\t\t\t\tif (!available.includes(state)) {\n\t\t\t\t\t\tthrow new KaboomError(`Cannot transition state from \"${oldState}\" to \"${state}\". Available transitions: ${available.map((s) => `\"${s}\"`).join(\", \")}`)\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttrigger(\"end\", oldState, ...args)\n\t\t\t\tthis.state = state\n\t\t\t\ttrigger(\"enter\", state, ...args)\n\t\t\t\ttrigger(\"enter\", `${oldState} -> ${state}`, ...args)\n\n\t\t\t},\n\n\t\t\tonStateTransition(from: string, to: string, action: () => void): EventController {\n\t\t\t\treturn on(\"enter\", `${from} -> ${to}`, action)\n\t\t\t},\n\n\t\t\tonStateEnter(state: string, action: () => void): EventController {\n\t\t\t\treturn on(\"enter\", state, action)\n\t\t\t},\n\n\t\t\tonStateUpdate(state: string, action: () => void): EventController {\n\t\t\t\treturn on(\"update\", state, action)\n\t\t\t},\n\n\t\t\tonStateDraw(state: string, action: () => void): EventController {\n\t\t\t\treturn on(\"draw\", state, action)\n\t\t\t},\n\n\t\t\tonStateEnd(state: string, action: () => void): EventController {\n\t\t\t\treturn on(\"end\", state, action)\n\t\t\t},\n\n\t\t\tupdate() {\n\t\t\t\t// execute the enter event for initState\n\t\t\t\tif (!didFirstEnter) {\n\t\t\t\t\ttrigger(\"enter\", initState)\n\t\t\t\t\tdidFirstEnter = true\n\t\t\t\t}\n\t\t\t\ttrigger(\"update\", this.state)\n\t\t\t},\n\n\t\t\tdraw() {\n\t\t\t\ttrigger(\"draw\", this.state)\n\t\t\t},\n\n\t\t\tinspect() {\n\t\t\t\treturn this.state\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction fadeIn(time: number = 1): Comp {\n\t\tlet t = 0\n\t\tlet done = false\n\t\treturn {\n\t\t\trequire: [ \"opacity\" ],\n\t\t\tadd(this: GameObj<OpacityComp>) {\n\t\t\t\tthis.opacity = 0\n\t\t\t},\n\t\t\tupdate(this: GameObj<OpacityComp>) {\n\t\t\t\tif (done) return\n\t\t\t\tt += dt()\n\t\t\t\tthis.opacity = map(t, 0, time, 0, 1)\n\t\t\t\tif (t >= time) {\n\t\t\t\t\tthis.opacity = 1\n\t\t\t\t\tdone = true\n\t\t\t\t}\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction mask(m: Mask = \"intersect\"): MaskComp {\n\t\treturn {\n\t\t\tid: \"mask\",\n\t\t\tmask: m,\n\t\t}\n\t}\n\n\tfunction onLoad(cb: () => void): void {\n\t\tif (assets.loaded) {\n\t\t\tcb()\n\t\t} else {\n\t\t\tgame.events.on(\"load\", cb)\n\t\t}\n\t}\n\n\tfunction scene(id: SceneName, def: SceneDef) {\n\t\tgame.scenes[id] = def\n\t}\n\n\tfunction go(name: SceneName, ...args) {\n\n\t\tif (!game.scenes[name]) {\n\t\t\tthrow new KaboomError(`Scene not found: ${name}`)\n\t\t}\n\n\t\tgame.events.onOnce(\"frameEnd\", () => {\n\n\t\t\tgame.events.trigger(\"sceneLeave\", name)\n\t\t\tapp.events.clear()\n\t\t\tgame.events.clear()\n\t\t\tgame.objEvents.clear()\n\n\t\t\t;[...game.root.children].forEach((obj) => {\n\t\t\t\tif (\n\t\t\t\t\t!obj.stay\n\t\t\t\t\t|| (obj.scenesToStay && !obj.scenesToStay.includes(name))\n\t\t\t\t) {\n\t\t\t\t\tgame.root.remove(obj)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\tgame.root.clearEvents()\n\t\t\tinitEvents()\n\n\t\t\t// cam\n\t\t\tgame.cam = {\n\t\t\t\tpos: null,\n\t\t\t\tscale: vec2(1),\n\t\t\t\tangle: 0,\n\t\t\t\tshake: 0,\n\t\t\t\ttransform: new Mat4(),\n\t\t\t}\n\n\t\t\tgame.scenes[name](...args)\n\n\t\t})\n\n\t}\n\n\tfunction onSceneLeave(action: (newScene?: string) => void): EventController {\n\t\treturn game.events.on(\"sceneLeave\", action)\n\t}\n\n\tfunction getData<T>(key: string, def?: T): T {\n\t\ttry {\n\t\t\treturn JSON.parse(window.localStorage[key])\n\t\t} catch {\n\t\t\tif (def) {\n\t\t\t\tsetData(key, def)\n\t\t\t\treturn def\n\t\t\t} else {\n\t\t\t\treturn null\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction setData(key: string, data: any) {\n\t\twindow.localStorage[key] = JSON.stringify(data)\n\t}\n\n\tfunction plug<T extends Record<string, any>>(plugin: KaboomPlugin<T>, ...args: any): KaboomCtx & T {\n\t\tconst funcs = plugin(ctx)\n\t\tlet funcsObj: T\n\t\tif (typeof funcs === \"function\") {\n\t\t\tconst plugWithOptions = funcs(...args)\n\t\t\tfuncsObj = plugWithOptions(ctx)\n\t\t}\n\t\telse {\n\t\t\tfuncsObj = funcs\n\t\t}\n\t\tfor (const k in funcsObj) {\n\t\t\t// @ts-ignore\n\t\t\tctx[k] = funcsObj[k]\n\t\t\tif (gopt.global !== false) {\n\t\t\t\t// @ts-ignore\n\t\t\t\twindow[k] = funcsObj[k]\n\t\t\t}\n\t\t}\n\t\treturn ctx as KaboomCtx & T\n\t}\n\n\tfunction center(): Vec2 {\n\t\treturn vec2(width() / 2, height() / 2)\n\t}\n\n\tenum EdgeMask {\n\t\tNone = 0,\n\t\tLeft = 1,\n\t\tTop = 2,\n\t\tLeftTop = 3,\n\t\tRight = 4,\n\t\tHorizontal = 5,\n\t\tRightTop = 6,\n\t\tHorizontalTop = 7,\n\t\tBottom = 8,\n\t\tLeftBottom = 9,\n\t\tVertical = 10,\n\t\tLeftVertical = 11,\n\t\tRightBottom = 12,\n\t\tHorizontalBottom = 13,\n\t\tRightVertical = 14,\n\t\tAll = 15,\n\t}\n\n\tfunction tile(opts: TileCompOpt = {}): TileComp {\n\n\t\tlet tilePos = vec2(0)\n\t\tlet isObstacle = opts.isObstacle ?? false\n\t\tlet cost = opts.cost ?? 0\n\t\tlet edges = opts.edges ?? []\n\n\t\tconst getEdgeMask = () => {\n\t\t\tconst loopup = {\n\t\t\t\t\"left\": EdgeMask.Left,\n\t\t\t\t\"top\": EdgeMask.Top,\n\t\t\t\t\"right\": EdgeMask.Right,\n\t\t\t\t\"bottom\": EdgeMask.Bottom,\n\t\t\t}\n\t\t\treturn edges.map(s => loopup[s] || 0).reduce((mask, dir) => mask | dir, 0)\n\t\t}\n\n\t\tlet edgeMask = getEdgeMask()\n\n\t\treturn {\n\n\t\t\tid: \"tile\",\n\t\t\ttilePosOffset: opts.offset ?? vec2(0),\n\n\t\t\tset tilePos(p: Vec2) {\n\t\t\t\tconst level = this.getLevel()\n\t\t\t\ttilePos = p.clone()\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.pos = vec2(\n\t\t\t\t\tthis.tilePos.x * level.tileWidth(),\n\t\t\t\t\tthis.tilePos.y * level.tileHeight(),\n\t\t\t\t).add(this.tilePosOffset)\n\t\t\t},\n\n\t\t\tget tilePos() {\n\t\t\t\treturn tilePos\n\t\t\t},\n\n\t\t\tset isObstacle(is: boolean) {\n\t\t\t\tif (isObstacle === is) return\n\t\t\t\tisObstacle = is\n\t\t\t\tthis.getLevel().invalidateNavigationMap()\n\t\t\t},\n\n\t\t\tget isObstacle() {\n\t\t\t\treturn isObstacle\n\t\t\t},\n\n\t\t\tset cost(n: number) {\n\t\t\t\tif (cost === n) return\n\t\t\t\tcost = n\n\t\t\t\tthis.getLevel().invalidateNavigationMap()\n\t\t\t},\n\n\t\t\tget cost() {\n\t\t\t\treturn cost\n\t\t\t},\n\n\t\t\tset edges(e: Edge[]) {\n\t\t\t\tedges = e\n\t\t\t\tedgeMask = getEdgeMask()\n\t\t\t\tthis.getLevel().invalidateNavigationMap()\n\t\t\t},\n\n\t\t\tget edges() {\n\t\t\t\treturn edges\n\t\t\t},\n\n\t\t\tget edgeMask() {\n\t\t\t\treturn edgeMask\n\t\t\t},\n\n\t\t\tgetLevel(this: GameObj) {\n\t\t\t\treturn this.parent as GameObj<LevelComp>\n\t\t\t},\n\n\t\t\tmoveLeft() {\n\t\t\t\tthis.tilePos = this.tilePos.add(vec2(-1, 0))\n\t\t\t},\n\n\t\t\tmoveRight() {\n\t\t\t\tthis.tilePos = this.tilePos.add(vec2(1, 0))\n\t\t\t},\n\n\t\t\tmoveUp() {\n\t\t\t\tthis.tilePos = this.tilePos.add(vec2(0, -1))\n\t\t\t},\n\n\t\t\tmoveDown() {\n\t\t\t\tthis.tilePos = this.tilePos.add(vec2(0, 1))\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction addLevel(map: string[], opt: LevelOpt): GameObj<PosComp | LevelComp> {\n\n\t\tif (!opt.tileWidth || !opt.tileHeight) {\n\t\t\tthrow new KaboomError(\"Must provide tileWidth and tileHeight.\")\n\t\t}\n\n\t\t// TODO: custom parent\n\t\tconst level = add([\n\t\t\tpos(opt.pos ?? vec2(0)),\n\t\t]) as GameObj<PosComp | LevelComp>\n\n\t\tconst numRows = map.length\n\t\tlet numColumns = 0\n\n\t\t// The spatial map keeps track of the objects at each location\n\t\tlet spatialMap: GameObj[][] | null = null\n\t\tlet costMap: number[] | null = null\n\t\tlet edgeMap: number[] | null = null\n\t\tlet connectivityMap: number[] | null = null\n\n\t\tconst tile2Hash = (tilePos: Vec2) => tilePos.x + tilePos.y * numColumns\n\t\tconst hash2Tile = (hash: number) => vec2(\n\t\t\tMath.floor(hash % numColumns),\n\t\t\tMath.floor(hash / numColumns),\n\t\t)\n\n\t\tconst createSpatialMap = () => {\n\t\t\tspatialMap = []\n\t\t\tfor (const child of level.children) {\n\t\t\t\tinsertIntoSpatialMap(child)\n\t\t\t}\n\t\t}\n\n\t\tconst insertIntoSpatialMap = (obj: GameObj) => {\n\t\t\tconst i = tile2Hash(obj.tilePos)\n\t\t\tif (spatialMap[i]) {\n\t\t\t\tspatialMap[i].push(obj)\n\t\t\t} else {\n\t\t\t\tspatialMap[i] = [obj]\n\t\t\t}\n\t\t}\n\n\t\tconst removeFromSpatialMap = (obj: GameObj) => {\n\t\t\tconst i = tile2Hash(obj.tilePos)\n\t\t\tif (spatialMap[i]) {\n\t\t\t\tconst index = spatialMap[i].indexOf(obj)\n\t\t\t\tif (index >= 0) {\n\t\t\t\t\tspatialMap[i].splice(index, 1)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst updateSpatialMap = () => {\n\t\t\tlet spatialMapChanged = false\n\t\t\tfor (const child of level.children) {\n\t\t\t\tconst tilePos = level.pos2Tile(child.pos)\n\t\t\t\tif (child.tilePos.x != tilePos.x || child.tilePos.y != tilePos.y) {\n\t\t\t\t\tspatialMapChanged = true\n\t\t\t\t\tremoveFromSpatialMap(child)\n\t\t\t\t\tchild.tilePos.x = tilePos.x\n\t\t\t\t\tchild.tilePos.y = tilePos.y\n\t\t\t\t\tinsertIntoSpatialMap(child)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (spatialMapChanged) {\n\t\t\t\tlevel.trigger(\"spatial_map_changed\")\n\t\t\t}\n\t\t}\n\n\t\t// The obstacle map tells which tiles are accessible\n\t\t// Cost: accessible with cost\n\t\t// Infinite: inaccessible\n\t\tconst createCostMap = () => {\n\t\t\tconst spatialMap = level.getSpatialMap()\n\t\t\tconst size = level.numRows() * level.numColumns()\n\t\t\tif (!costMap) {\n\t\t\t\tcostMap = new Array<number>(size)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcostMap.length = size\n\t\t\t}\n\t\t\tcostMap.fill(1, 0, size)\n\t\t\tfor (let i = 0; i < spatialMap.length; i++) {\n\t\t\t\tconst objects = spatialMap[i]\n\t\t\t\tif (objects) {\n\t\t\t\t\tlet cost = 0\n\t\t\t\t\tfor (const obj of objects) {\n\t\t\t\t\t\tif (obj.isObstacle) {\n\t\t\t\t\t\t\tcost = Infinity\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcost += obj.cost\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcostMap[i] = cost || 1\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// The edge map tells which edges between nodes are walkable\n\t\tconst createEdgeMap = () => {\n\t\t\tconst spatialMap = level.getSpatialMap()\n\t\t\tconst size = level.numRows() * level.numColumns()\n\t\t\tif (!edgeMap) {\n\t\t\t\tedgeMap = new Array<number>(size)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedgeMap.length = size\n\t\t\t}\n\t\t\tedgeMap.fill(EdgeMask.All, 0, size)\n\t\t\tfor (let i = 0; i < spatialMap.length; i++) {\n\t\t\t\tconst objects = spatialMap[i]\n\t\t\t\tif (objects) {\n\t\t\t\t\tconst len = objects.length\n\t\t\t\t\tlet mask = EdgeMask.All\n\t\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\t\tmask |= objects[j].edgeMask\n\t\t\t\t\t}\n\t\t\t\t\tedgeMap[i] = mask\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// The connectivity map is used to see whether two locations are connected\n\t\t// -1: inaccesible n: connectivity group\n\t\tconst createConnectivityMap = () => {\n\t\t\tconst size = level.numRows() * level.numColumns()\n\t\t\tconst traverse = (i: number, index: number) => {\n\t\t\t\tconst frontier: number[] = []\n\t\t\t\tfrontier.push(i)\n\t\t\t\twhile (frontier.length > 0) {\n\t\t\t\t\tconst i = frontier.pop()\n\t\t\t\t\tgetNeighbours(i).forEach((i) => {\n\t\t\t\t\t\tif (connectivityMap[i] < 0) {\n\t\t\t\t\t\t\tconnectivityMap[i] = index\n\t\t\t\t\t\t\tfrontier.push(i)\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!connectivityMap) {\n\t\t\t\tconnectivityMap = new Array<number>(size)\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconnectivityMap.length = size\n\t\t\t}\n\t\t\tconnectivityMap.fill(-1, 0, size)\n\t\t\tlet index = 0\n\t\t\tfor (let i = 0; i < costMap.length; i++) {\n\t\t\t\tif (connectivityMap[i] >= 0) { index++; continue }\n\t\t\t\ttraverse(i, index)\n\t\t\t\tindex++\n\t\t\t}\n\t\t}\n\n\t\tconst getCost = (node: number, neighbour: number) => {\n\t\t\t// Cost of destination tile\n\t\t\treturn costMap[neighbour]\n\t\t}\n\n\t\tconst getHeuristic = (node: number, goal: number) => {\n\t\t\t// Euclidian distance to target\n\t\t\tconst p1 = hash2Tile(node)\n\t\t\tconst p2 = hash2Tile(goal)\n\t\t\treturn p1.dist(p2)\n\t\t}\n\n\t\tconst getNeighbours = (node: number, diagonals?: boolean) => {\n\t\t\tconst n = []\n\t\t\tconst x = Math.floor(node % numColumns)\n\t\t\tconst left = x > 0 &&\n\t\t\t\t(edgeMap[node] & EdgeMask.Left) &&\n\t\t\t\tcostMap[node - 1] !== Infinity\n\t\t\tconst top = node >= numColumns &&\n\t\t\t\t(edgeMap[node] & EdgeMask.Top) &&\n\t\t\t\tcostMap[node - numColumns] !== Infinity\n\t\t\tconst right = x < numColumns - 1 &&\n\t\t\t\t(edgeMap[node] & EdgeMask.Right) &&\n\t\t\t\tcostMap[node + 1] !== Infinity\n\t\t\tconst bottom = node < numColumns * numRows - numColumns - 1 &&\n\t\t\t\t(edgeMap[node] & EdgeMask.Bottom) &&\n\t\t\t\tcostMap[node + numColumns] !== Infinity\n\t\t\tif (diagonals) {\n\t\t\t\tif (left) {\n\t\t\t\t\tif (top) { n.push(node - numColumns - 1) }\n\t\t\t\t\tn.push(node - 1)\n\t\t\t\t\tif (bottom) { n.push(node + numColumns - 1) }\n\t\t\t\t}\n\t\t\t\tif (top) {\n\t\t\t\t\tn.push(node - numColumns)\n\t\t\t\t}\n\t\t\t\tif (right) {\n\t\t\t\t\tif (top) { n.push(node - numColumns + 1) }\n\t\t\t\t\tn.push(node + 1)\n\t\t\t\t\tif (bottom) { n.push(node + numColumns + 1) }\n\t\t\t\t}\n\t\t\t\tif (bottom) {\n\t\t\t\t\tn.push(node + numColumns)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (left) {\n\t\t\t\t\tn.push(node - 1)\n\t\t\t\t}\n\t\t\t\tif (top) {\n\t\t\t\t\tn.push(node - numColumns)\n\t\t\t\t}\n\t\t\t\tif (right) {\n\t\t\t\t\tn.push(node + 1)\n\t\t\t\t}\n\t\t\t\tif (bottom) {\n\t\t\t\t\tn.push(node + numColumns)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n\n\t\t}\n\n\t\tconst levelComp: LevelComp = {\n\n\t\t\tid: \"level\",\n\n\t\t\ttileWidth() {\n\t\t\t\treturn opt.tileWidth\n\t\t\t},\n\n\t\t\ttileHeight() {\n\t\t\t\treturn opt.tileHeight\n\t\t\t},\n\n\t\t\tspawn(this: GameObj<LevelComp>, key: string | CompList<any>, ...args: Vec2Args): GameObj | null {\n\n\t\t\t\tconst p = vec2(...args)\n\n\t\t\t\tconst comps = (() => {\n\t\t\t\t\tif (typeof key === \"string\") {\n\t\t\t\t\t\tif (opt.tiles[key]) {\n\t\t\t\t\t\t\tif (typeof opt.tiles[key] !== \"function\") {\n\t\t\t\t\t\t\t\tthrow new KaboomError(\"Level symbol def must be a function returning a component list\")\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn opt.tiles[key](p)\n\t\t\t\t\t\t} else if (opt.wildcardTile) {\n\t\t\t\t\t\t\treturn opt.wildcardTile(key, p)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (Array.isArray(key)) {\n\t\t\t\t\t\treturn key\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new KaboomError(\"Expected a symbol or a component list\")\n\t\t\t\t\t}\n\t\t\t\t})()\n\n\t\t\t\t// empty tile\n\t\t\t\tif (!comps) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tlet hasPos = false\n\t\t\t\tlet hasTile = false\n\n\t\t\t\tfor (const comp of comps) {\n\t\t\t\t\tif (comp.id === \"tile\") hasTile = true\n\t\t\t\t\tif (comp.id === \"pos\") hasPos = true\n\t\t\t\t}\n\n\t\t\t\tif (!hasPos) comps.push(pos())\n\t\t\t\tif (!hasTile) comps.push(tile())\n\n\t\t\t\tconst obj = level.add(comps)\n\n\t\t\t\tif (hasPos) {\n\t\t\t\t\tobj.tilePosOffset = obj.pos.clone()\n\t\t\t\t}\n\n\t\t\t\tobj.tilePos = p\n\n\t\t\t\tif (spatialMap) {\n\t\t\t\t\tinsertIntoSpatialMap(obj)\n\t\t\t\t\tthis.trigger(\"spatial_map_changed\")\n\t\t\t\t\tthis.trigger(\"navigation_map_invalid\")\n\t\t\t\t}\n\n\t\t\t\treturn obj\n\n\t\t\t},\n\n\t\t\tnumColumns() {\n\t\t\t\treturn numColumns\n\t\t\t},\n\n\t\t\tnumRows() {\n\t\t\t\treturn numRows\n\t\t\t},\n\n\t\t\tlevelWidth() {\n\t\t\t\treturn numColumns * this.tileWidth()\n\t\t\t},\n\n\t\t\tlevelHeight() {\n\t\t\t\treturn numRows * this.tileHeight()\n\t\t\t},\n\n\t\t\ttile2Pos(...args: Vec2Args) {\n\t\t\t\treturn vec2(...args).scale(this.tileWidth(), this.tileHeight())\n\t\t\t},\n\n\t\t\tpos2Tile(...args: Vec2Args) {\n\t\t\t\tconst p = vec2(...args)\n\t\t\t\treturn vec2(\n\t\t\t\t\tMath.floor(p.x / this.tileWidth()),\n\t\t\t\t\tMath.floor(p.y / this.tileHeight()),\n\t\t\t\t)\n\t\t\t},\n\n\t\t\tgetSpatialMap() {\n\t\t\t\tif (!spatialMap) {\n\t\t\t\t\tcreateSpatialMap()\n\t\t\t\t}\n\t\t\t\treturn spatialMap\n\t\t\t},\n\n\t\t\tonSpatialMapChanged(this: GameObj<LevelComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"spatial_map_changed\", cb)\n\t\t\t},\n\n\t\t\tonNavigationMapInvalid(this: GameObj<LevelComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"navigation_map_invalid\", cb)\n\t\t\t},\n\n\t\t\tgetAt(tilePos: Vec2) {\n\t\t\t\tif (!spatialMap) {\n\t\t\t\t\tcreateSpatialMap()\n\t\t\t\t}\n\t\t\t\tconst hash = tile2Hash(tilePos)\n\t\t\t\treturn spatialMap[hash] || []\n\t\t\t},\n\n\t\t\tupdate() {\n\t\t\t\tif (spatialMap) {\n\t\t\t\t\tupdateSpatialMap()\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tinvalidateNavigationMap() {\n\t\t\t\tcostMap = null\n\t\t\t\tedgeMap = null\n\t\t\t\tconnectivityMap = null\n\t\t\t},\n\n\t\t\tonNavigationMapChanged(this: GameObj<LevelComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"navigation_map_changed\", cb)\n\t\t\t},\n\n\t\t\tgetTilePath(this: GameObj<LevelComp>, from: Vec2, to: Vec2, opts: PathFindOpt = {}) {\n\t\t\t\tif (!costMap) {\n\t\t\t\t\tcreateCostMap()\n\t\t\t\t}\n\t\t\t\tif (!edgeMap) {\n\t\t\t\t\tcreateEdgeMap()\n\t\t\t\t}\n\t\t\t\tif (!connectivityMap) {\n\t\t\t\t\tcreateConnectivityMap()\n\t\t\t\t}\n\n\t\t\t\t// Tiles are outside the grid\n\t\t\t\tif (from.x < 0 || from.x >= numColumns ||\n\t\t\t\t\tfrom.y < 0 || from.y >= numRows) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t\tif (to.x < 0 || to.x >= numColumns ||\n\t\t\t\t\tto.y < 0 || to.y >= numRows) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\tconst start = tile2Hash(from)\n\t\t\t\tconst goal = tile2Hash(to)\n\n\t\t\t\t// Tiles are not accessible\n\t\t\t\t// If we test the start tile, we may get stuck\n\t\t\t\t/*if (costMap[start] === Infinity) {\n\t\t\t\t\treturn null\n\t\t\t\t}*/\n\t\t\t\tif (costMap[goal] === Infinity) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\t// Same Tile, no waypoints needed\n\t\t\t\tif (start === goal) {\n\t\t\t\t\treturn []\n\t\t\t\t}\n\n\t\t\t\t// Tiles are not within the same section\n\t\t\t\t// If we test the start tile when invalid, we may get stuck\n\t\t\t\tif (connectivityMap[start] != -1 && connectivityMap[start] !== connectivityMap[goal]) {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\n\t\t\t\t// Find a path\n\t\t\t\tinterface CostNode { cost: number, node: number }\n\t\t\t\tconst frontier = new BinaryHeap<CostNode>((a, b) => a.cost < b.cost)\n\t\t\t\tfrontier.insert({ cost: 0, node: start })\n\n\t\t\t\tconst cameFrom = new Map<number, number>()\n\t\t\t\tcameFrom.set(start, start)\n\t\t\t\tconst costSoFar = new Map<number, number>()\n\t\t\t\tcostSoFar.set(start, 0)\n\n\t\t\t\twhile (frontier.length !== 0) {\n\t\t\t\t\tconst current = frontier.remove()?.node\n\n\t\t\t\t\tif (current === goal)\n\t\t\t\t\t\tbreak\n\n\t\t\t\t\tconst neighbours = getNeighbours(current, opts.allowDiagonals)\n\t\t\t\t\tfor (const next of neighbours) {\n\t\t\t\t\t\tconst newCost = (costSoFar.get(current) || 0) +\n\t\t\t\t\t\t\tgetCost(current, next) +\n\t\t\t\t\t\t\tgetHeuristic(next, goal)\n\t\t\t\t\t\tif (!costSoFar.has(next) || newCost < costSoFar.get(next)) {\n\t\t\t\t\t\t\tcostSoFar.set(next, newCost)\n\t\t\t\t\t\t\tfrontier.insert({ cost: newCost, node: next })\n\t\t\t\t\t\t\tcameFrom.set(next, current)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst path = []\n\t\t\t\tlet node = goal\n\t\t\t\tconst p = hash2Tile(node)\n\t\t\t\tpath.push(p)\n\t\t\t\twhile (node !== start) {\n\t\t\t\t\tnode = cameFrom.get(node)\n\t\t\t\t\tconst p = hash2Tile(node)\n\t\t\t\t\tpath.push(p)\n\t\t\t\t}\n\t\t\t\treturn path.reverse()\n\t\t\t},\n\n\t\t\tgetPath(this: GameObj<LevelComp>, from: Vec2, to: Vec2, opts: PathFindOpt = {}) {\n\t\t\t\tconst tw = this.tileWidth()\n\t\t\t\tconst th = this.tileHeight()\n\t\t\t\tconst path = this.getTilePath(\n\t\t\t\t\tthis.pos2Tile(from),\n\t\t\t\t\tthis.pos2Tile(to),\n\t\t\t\t\topts,\n\t\t\t\t)\n\t\t\t\tif (path) {\n\t\t\t\t\treturn [\n\t\t\t\t\t\tfrom,\n\t\t\t\t\t\t...path\n\t\t\t\t\t\t\t.slice(1, -1)\n\t\t\t\t\t\t\t.map((tilePos) => tilePos.scale(tw, th).add(tw / 2, th / 2)),\n\t\t\t\t\t\tto,\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn null\n\t\t\t\t}\n\t\t\t},\n\n\t\t}\n\n\t\tlevel.use(levelComp)\n\n\t\tlevel.onNavigationMapInvalid(() => {\n\t\t\tlevel.invalidateNavigationMap()\n\t\t\tlevel.trigger(\"navigation_map_changed\")\n\t\t})\n\n\t\tmap.forEach((row, i) => {\n\t\t\tconst keys = row.split(\"\")\n\t\t\tnumColumns = Math.max(keys.length, numColumns)\n\t\t\tkeys.forEach((key, j) => {\n\t\t\t\tlevel.spawn(key, vec2(j, i))\n\t\t\t})\n\t\t})\n\n\t\treturn level\n\n\t}\n\n\tfunction agent(opts: AgentCompOpt = {}) : AgentComp {\n\t\tlet target: Vec2 | null = null\n\t\tlet path: Vec2[] | null = null\n\t\tlet index: number | null = null\n\t\tlet navMapChangedEvent: EventController | null = null\n\t\treturn {\n\t\t\tid: \"agent\",\n\t\t\trequire: [\"pos\", \"tile\"],\n\t\t\tagentSpeed: opts.speed ?? 100,\n\t\t\tallowDiagonals: opts.allowDiagonals ?? true,\n\t\t\tgetDistanceToTarget(this: GameObj<AgentComp | PosComp>) {\n\t\t\t\treturn target ? this.pos.dist(target) : 0\n\t\t\t},\n\t\t\tgetNextLocation() {\n\t\t\t\treturn path && index ? path[index] : null\n\t\t\t},\n\t\t\tgetPath() {\n\t\t\t\treturn path ? path.slice() : null\n\t\t\t},\n\t\t\tgetTarget() {\n\t\t\t\treturn target\n\t\t\t},\n\t\t\tisNavigationFinished() {\n\t\t\t\treturn path ? index === null : true\n\t\t\t},\n\t\t\tisTargetReachable() {\n\t\t\t\treturn path !== null\n\t\t\t},\n\t\t\tisTargetReached(this: GameObj<AgentComp | PosComp>) {\n\t\t\t\treturn target ? this.pos.eq(target) : true\n\t\t\t},\n\t\t\tsetTarget(this: GameObj<AgentComp | TileComp | PosComp>, p: Vec2) {\n\t\t\t\ttarget = p\n\t\t\t\tpath = this.getLevel().getPath(this.pos, target, {\n\t\t\t\t\tallowDiagonals: this.allowDiagonals,\n\t\t\t\t})\n\t\t\t\tindex = path ? 0 : null\n\t\t\t\tif (path) {\n\t\t\t\t\tif (!navMapChangedEvent) {\n\t\t\t\t\t\tnavMapChangedEvent = this.getLevel().onNavigationMapChanged(() => {\n\t\t\t\t\t\t\tif (path && index !== null) {\n\t\t\t\t\t\t\t\tpath = this.getLevel().getPath(this.pos, target, {\n\t\t\t\t\t\t\t\t\tallowDiagonals: this.allowDiagonals,\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\tindex = path ? 0 : null\n\t\t\t\t\t\t\t\tif (path) {\n\t\t\t\t\t\t\t\t\tthis.trigger(\"navigation-next\", this, path[index])\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthis.trigger(\"navigation-ended\", this)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.onDestroy(() => navMapChangedEvent.cancel())\n\t\t\t\t\t}\n\t\t\t\t\tthis.trigger(\"navigation-started\", this)\n\t\t\t\t\tthis.trigger(\"navigation-next\", this, path[index])\n\t\t\t\t} else {\n\t\t\t\t\tthis.trigger(\"navigation-ended\", this)\n\t\t\t\t}\n\t\t\t},\n\t\t\tupdate(this: GameObj<AgentComp | PosComp>) {\n\t\t\t\tif (path && index !== null) {\n\t\t\t\t\tif (this.pos.sdist(path[index]) < 2) {\n\t\t\t\t\t\tif (index === path.length - 1) {\n\t\t\t\t\t\t\tthis.pos = target.clone()\n\t\t\t\t\t\t\tindex = null\n\t\t\t\t\t\t\tthis.trigger(\"navigation-ended\", this)\n\t\t\t\t\t\t\tthis.trigger(\"target-reached\", this)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex++\n\t\t\t\t\t\t\tthis.trigger(\"navigation-next\", this, path[index])\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\tthis.moveTo(path[index], this.agentSpeed)\n\t\t\t\t}\n\t\t\t},\n\t\t\tonNavigationStarted(this: GameObj<AgentComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"navigation-started\", cb)\n\t\t\t},\n\t\t\tonNavigationNext(this: GameObj<AgentComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"navigation-next\", cb)\n\t\t\t},\n\t\t\tonNavigationEnded(this: GameObj<AgentComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"navigation-ended\", cb)\n\t\t\t},\n\t\t\tonTargetReached(this: GameObj<AgentComp>, cb: () => void) {\n\t\t\t\treturn this.on(\"target-reached\", cb)\n\t\t\t},\n\t\t\tinspect() {\n\t\t\t\treturn JSON.stringify({\n\t\t\t\t\ttarget: JSON.stringify(target),\n\t\t\t\t\tpath: JSON.stringify(path),\n\t\t\t\t})\n\t\t\t},\n\t\t}\n\t}\n\n\tfunction record(frameRate?): Recording {\n\n\t\tconst stream = app.canvas().captureStream(frameRate)\n\t\tconst audioDest = audio.ctx.createMediaStreamDestination()\n\n\t\taudio.masterNode.connect(audioDest)\n\n\t\t// TODO: Enabling audio results in empty video if no audio received\n\t\t// const audioStream = audioDest.stream\n\t\t// const [firstAudioTrack] = audioStream.getAudioTracks()\n\n\t\t// stream.addTrack(firstAudioTrack);\n\n\t\tconst recorder = new MediaRecorder(stream)\n\t\tconst chunks = []\n\n\t\trecorder.ondataavailable = (e) => {\n\t\t\tif (e.data.size > 0) {\n\t\t\t\tchunks.push(e.data)\n\t\t\t}\n\t\t}\n\n\t\trecorder.onerror = () => {\n\t\t\taudio.masterNode.disconnect(audioDest)\n\t\t\tstream.getTracks().forEach(t => t.stop())\n\t\t}\n\n\t\trecorder.start()\n\n\t\treturn {\n\n\t\t\tresume() {\n\t\t\t\trecorder.resume()\n\t\t\t},\n\n\t\t\tpause() {\n\t\t\t\trecorder.pause()\n\t\t\t},\n\n\t\t\tstop(): Promise<Blob> {\n\t\t\t\trecorder.stop()\n\t\t\t\t// cleanup\n\t\t\t\taudio.masterNode.disconnect(audioDest)\n\t\t\t\tstream.getTracks().forEach(t => t.stop())\n\t\t\t\treturn new Promise((resolve) => {\n\t\t\t\t\trecorder.onstop = () => {\n\t\t\t\t\t\tresolve(new Blob(chunks, {\n\t\t\t\t\t\t\ttype: \"video/mp4\",\n\t\t\t\t\t\t}))\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t},\n\n\t\t\tdownload(filename = \"kaboom.mp4\") {\n\t\t\t\tthis.stop().then((blob) => downloadBlob(filename, blob))\n\t\t\t},\n\n\t\t}\n\n\t}\n\n\tfunction isFocused(): boolean {\n\t\treturn document.activeElement === app.canvas()\n\t}\n\n\tfunction destroy(obj: GameObj) {\n\t\tobj.destroy()\n\t}\n\n\t// aliases for root game obj operations\n\tconst add: KaboomCtx[\"add\"] = game.root.add.bind(game.root)\n\tconst readd: KaboomCtx[\"readd\"] = game.root.readd.bind(game.root)\n\tconst destroyAll: KaboomCtx[\"destroyAll\"] = game.root.removeAll.bind(game.root)\n\tconst get: KaboomCtx[\"get\"] = game.root.get.bind(game.root)\n\n\tfunction boom(speed: number = 2, size: number = 1): Comp {\n\t\tlet time = 0\n\t\treturn {\n\t\t\tid: \"boom\",\n\t\t\trequire: [ \"scale\" ],\n\t\t\tupdate(this: GameObj<ScaleComp>) {\n\t\t\t\tconst s = Math.sin(time * speed) * size\n\t\t\t\tif (s < 0) {\n\t\t\t\t\tthis.destroy()\n\t\t\t\t}\n\t\t\t\tthis.scale = vec2(s)\n\t\t\t\ttime += dt()\n\t\t\t},\n\t\t}\n\t}\n\n\tconst kaSprite = loadSprite(null, kaSpriteSrc)\n\tconst boomSprite = loadSprite(null, boomSpriteSrc)\n\n\tfunction addKaboom(p: Vec2, opt: BoomOpt = {}): GameObj {\n\n\t\tconst kaboom = add([\n\t\t\tpos(p),\n\t\t\tstay(),\n\t\t])\n\n\t\tconst speed = (opt.speed || 1) * 5\n\t\tconst s = opt.scale || 1\n\n\t\tkaboom.add([\n\t\t\tsprite(boomSprite),\n\t\t\tscale(0),\n\t\t\tanchor(\"center\"),\n\t\t\tboom(speed, s),\n\t\t\t...opt.comps ?? [],\n\t\t])\n\n\t\tconst ka = kaboom.add([\n\t\t\tsprite(kaSprite),\n\t\t\tscale(0),\n\t\t\tanchor(\"center\"),\n\t\t\ttimer(),\n\t\t\t...opt.comps ?? [],\n\t\t])\n\n\t\tka.wait(0.4 / speed, () => ka.use(boom(speed, s)))\n\t\tka.onDestroy(() => kaboom.destroy())\n\n\t\treturn kaboom\n\n\t}\n\n\tfunction updateFrame() {\n\t\t// update every obj\n\t\tgame.root.update()\n\t}\n\n\tclass Collision {\n\t\tsource: GameObj\n\t\ttarget: GameObj\n\t\tdisplacement: Vec2\n\t\tresolved: boolean = false\n\t\tconstructor(source: GameObj, target: GameObj, dis: Vec2, resolved = false) {\n\t\t\tthis.source = source\n\t\t\tthis.target = target\n\t\t\tthis.displacement = dis\n\t\t\tthis.resolved = resolved\n\t\t}\n\t\treverse() {\n\t\t\treturn new Collision(\n\t\t\t\tthis.target,\n\t\t\t\tthis.source,\n\t\t\t\tthis.displacement.scale(-1),\n\t\t\t\tthis.resolved,\n\t\t\t)\n\t\t}\n\t\thasOverlap() {\n\t\t\treturn !this.displacement.isZero()\n\t\t}\n\t\tisLeft() {\n\t\t\treturn this.displacement.x > 0\n\t\t}\n\t\tisRight() {\n\t\t\treturn this.displacement.x < 0\n\t\t}\n\t\tisTop() {\n\t\t\treturn this.displacement.y > 0\n\t\t}\n\t\tisBottom() {\n\t\t\treturn this.displacement.y < 0\n\t\t}\n\t\tpreventResolution() {\n\t\t\tthis.resolved = true\n\t\t}\n\t}\n\n\tfunction checkFrame() {\n\n\t\t// TODO: persistent grid?\n\t\t// start a spatial hash grid for more efficient collision detection\n\t\tconst grid: Record<number, Record<number, GameObj<AreaComp>[]>> = {}\n\t\tconst cellSize = gopt.hashGridSize || DEF_HASH_GRID_SIZE\n\n\t\t// current transform\n\t\tlet tr = new Mat4()\n\n\t\t// a local transform stack\n\t\tconst stack = []\n\n\t\tfunction checkObj(obj: GameObj) {\n\n\t\t\tstack.push(tr.clone())\n\n\t\t\t// Update object transform here. This will be the transform later used in rendering.\n\t\t\tif (obj.pos) tr.translate(obj.pos)\n\t\t\tif (obj.scale) tr.scale(obj.scale)\n\t\t\tif (obj.angle) tr.rotate(obj.angle)\n\t\t\tobj.transform = tr.clone()\n\n\t\t\tif (obj.c(\"area\") && !obj.paused) {\n\n\t\t\t\t// TODO: only update worldArea if transform changed\n\t\t\t\tconst aobj = obj as GameObj<AreaComp>\n\t\t\t\tconst area = aobj.worldArea()\n\t\t\t\tconst bbox = area.bbox()\n\n\t\t\t\t// Get spatial hash grid coverage\n\t\t\t\tconst xmin = Math.floor(bbox.pos.x / cellSize)\n\t\t\t\tconst ymin = Math.floor(bbox.pos.y / cellSize)\n\t\t\t\tconst xmax = Math.ceil((bbox.pos.x + bbox.width) / cellSize)\n\t\t\t\tconst ymax = Math.ceil((bbox.pos.y + bbox.height) / cellSize)\n\n\t\t\t\t// Cache objs that are already checked\n\t\t\t\tconst checked = new Set()\n\n\t\t\t\t// insert & check against all covered grids\n\t\t\t\tfor (let x = xmin; x <= xmax; x++) {\n\t\t\t\t\tfor (let y = ymin; y <= ymax; y++) {\n\t\t\t\t\t\tif(!grid[x]) {\n\t\t\t\t\t\t\tgrid[x] = {}\n\t\t\t\t\t\t\tgrid[x][y] = [aobj]\n\t\t\t\t\t\t} else if(!grid[x][y]) {\n\t\t\t\t\t\t\tgrid[x][y] = [aobj]\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst cell = grid[x][y]\n\t\t\t\t\t\t\tcheck: for (const other of cell) {\n\t\t\t\t\t\t\t\tif (other.paused) continue\n\t\t\t\t\t\t\t\tif (!other.exists()) continue\n\t\t\t\t\t\t\t\tif (checked.has(other.id)) continue\n\t\t\t\t\t\t\t\tfor (const tag of aobj.collisionIgnore) {\n\t\t\t\t\t\t\t\t\tif (other.is(tag)) {\n\t\t\t\t\t\t\t\t\t\tcontinue check\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfor (const tag of other.collisionIgnore) {\n\t\t\t\t\t\t\t\t\tif (aobj.is(tag)) {\n\t\t\t\t\t\t\t\t\t\tcontinue check\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// TODO: cache the world area here\n\t\t\t\t\t\t\t\tconst res = sat(aobj.worldArea(), other.worldArea())\n\t\t\t\t\t\t\t\tif (res) {\n\t\t\t\t\t\t\t\t\t// TODO: rehash if the object position is changed after resolution?\n\t\t\t\t\t\t\t\t\tconst col1 = new Collision(aobj, other, res)\n\t\t\t\t\t\t\t\t\taobj.trigger(\"collideUpdate\", other, col1)\n\t\t\t\t\t\t\t\t\tconst col2 = col1.reverse()\n\t\t\t\t\t\t\t\t\t// resolution only has to happen once\n\t\t\t\t\t\t\t\t\tcol2.resolved = col1.resolved\n\t\t\t\t\t\t\t\t\tother.trigger(\"collideUpdate\", aobj, col2)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchecked.add(other.id)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcell.push(aobj)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tobj.children.forEach(checkObj)\n\t\t\ttr = stack.pop()\n\n\t\t}\n\n\t\tcheckObj(game.root)\n\n\t}\n\n\tfunction drawFrame() {\n\n\t\t// calculate camera matrix\n\t\tconst cam = game.cam\n\t\tconst shake = Vec2.fromAngle(rand(0, 360)).scale(cam.shake)\n\n\t\tcam.shake = lerp(cam.shake, 0, 5 * dt())\n\t\tcam.transform = new Mat4()\n\t\t\t.translate(center())\n\t\t\t.scale(cam.scale)\n\t\t\t.rotate(cam.angle)\n\t\t\t.translate((cam.pos ?? center()).scale(-1).add(shake))\n\n\t\tgame.root.draw()\n\t\tflush()\n\n\t}\n\n\tfunction drawLoadScreen() {\n\n\t\tconst progress = loadProgress()\n\n\t\tif (game.events.numListeners(\"loading\") > 0) {\n\t\t\tgame.events.trigger(\"loading\", progress)\n\t\t} else {\n\t\t\tdrawUnscaled(() => {\n\t\t\t\tconst w = width() / 2\n\t\t\t\tconst h = 24\n\t\t\t\tconst pos = vec2(width() / 2, height() / 2).sub(vec2(w / 2, h / 2))\n\t\t\t\tdrawRect({\n\t\t\t\t\tpos: vec2(0),\n\t\t\t\t\twidth: width(),\n\t\t\t\t\theight: height(),\n\t\t\t\t\tcolor: rgb(0, 0, 0),\n\t\t\t\t})\n\t\t\t\tdrawRect({\n\t\t\t\t\tpos: pos,\n\t\t\t\t\twidth: w,\n\t\t\t\t\theight: h,\n\t\t\t\t\tfill: false,\n\t\t\t\t\toutline: {\n\t\t\t\t\t\twidth: 4,\n\t\t\t\t\t},\n\t\t\t\t})\n\t\t\t\tdrawRect({\n\t\t\t\t\tpos: pos,\n\t\t\t\t\twidth: w * progress,\n\t\t\t\t\theight: h,\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\n\t}\n\n\tfunction drawInspectText(pos, txt) {\n\n\t\tdrawUnscaled(() => {\n\n\t\t\tconst pad = vec2(8)\n\n\t\t\tpushTransform()\n\t\t\tpushTranslate(pos)\n\n\t\t\tconst ftxt = formatText({\n\t\t\t\ttext: txt,\n\t\t\t\tfont: DBG_FONT,\n\t\t\t\tsize: 16,\n\t\t\t\tpos: pad,\n\t\t\t\tcolor: rgb(255, 255, 255),\n\t\t\t\tfixed: true,\n\t\t\t})\n\n\t\t\tconst bw = ftxt.width + pad.x * 2\n\t\t\tconst bh = ftxt.height + pad.x * 2\n\n\t\t\tif (pos.x + bw >= width()) {\n\t\t\t\tpushTranslate(vec2(-bw, 0))\n\t\t\t}\n\n\t\t\tif (pos.y + bh >= height()) {\n\t\t\t\tpushTranslate(vec2(0, -bh))\n\t\t\t}\n\n\t\t\tdrawRect({\n\t\t\t\twidth: bw,\n\t\t\t\theight: bh,\n\t\t\t\tcolor: rgb(0, 0, 0),\n\t\t\t\tradius: 4,\n\t\t\t\topacity: 0.8,\n\t\t\t\tfixed: true,\n\t\t\t})\n\n\t\t\tdrawFormattedText(ftxt)\n\t\t\tpopTransform()\n\n\t\t})\n\n\t}\n\n\tfunction drawDebug() {\n\n\t\tif (debug.inspect) {\n\n\t\t\tlet inspecting = null\n\n\t\t\tfor (const obj of game.root.get(\"*\", { recursive: true })) {\n\t\t\t\tif (obj.c(\"area\") && obj.isHovering()) {\n\t\t\t\t\tinspecting = obj\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tgame.root.drawInspect()\n\n\t\t\tif (inspecting) {\n\n\t\t\t\tconst lines = []\n\t\t\t\tconst data = inspecting.inspect()\n\n\t\t\t\tfor (const tag in data) {\n\t\t\t\t\tif (data[tag]) {\n\t\t\t\t\t\tlines.push(`${tag}: ${data[tag]}`)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlines.push(`${tag}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdrawInspectText(contentToView(mousePos()), lines.join(\"\\n\"))\n\n\t\t\t}\n\n\t\t\tdrawInspectText(vec2(8), `FPS: ${debug.fps()}`)\n\n\t\t}\n\n\t\tif (debug.paused) {\n\n\t\t\tdrawUnscaled(() => {\n\n\t\t\t\t// top right corner\n\t\t\t\tpushTransform()\n\t\t\t\tpushTranslate(width(), 0)\n\t\t\t\tpushTranslate(-8, 8)\n\n\t\t\t\tconst size = 32\n\n\t\t\t\t// bg\n\t\t\t\tdrawRect({\n\t\t\t\t\twidth: size,\n\t\t\t\t\theight: size,\n\t\t\t\t\tanchor: \"topright\",\n\t\t\t\t\tcolor: rgb(0, 0, 0),\n\t\t\t\t\topacity: 0.8,\n\t\t\t\t\tradius: 4,\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\t// pause icon\n\t\t\t\tfor (let i = 1; i <= 2; i++) {\n\t\t\t\t\tdrawRect({\n\t\t\t\t\t\twidth: 4,\n\t\t\t\t\t\theight: size * 0.6,\n\t\t\t\t\t\tanchor: \"center\",\n\t\t\t\t\t\tpos: vec2(-size / 3 * i, size * 0.5),\n\t\t\t\t\t\tcolor: rgb(255, 255, 255),\n\t\t\t\t\t\tradius: 2,\n\t\t\t\t\t\tfixed: true,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\tpopTransform()\n\n\t\t\t})\n\n\t\t}\n\n\t\tif (debug.timeScale !== 1) {\n\n\t\t\tdrawUnscaled(() => {\n\n\t\t\t\t// bottom right corner\n\t\t\t\tpushTransform()\n\t\t\t\tpushTranslate(width(), height())\n\t\t\t\tpushTranslate(-8, -8)\n\n\t\t\t\tconst pad = 8\n\n\t\t\t\t// format text first to get text size\n\t\t\t\tconst ftxt = formatText({\n\t\t\t\t\ttext: debug.timeScale.toFixed(1),\n\t\t\t\t\tfont: DBG_FONT,\n\t\t\t\t\tsize: 16,\n\t\t\t\t\tcolor: rgb(255, 255, 255),\n\t\t\t\t\tpos: vec2(-pad),\n\t\t\t\t\tanchor: \"botright\",\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\t// bg\n\t\t\t\tdrawRect({\n\t\t\t\t\twidth: ftxt.width + pad * 2 + pad * 4,\n\t\t\t\t\theight: ftxt.height + pad * 2,\n\t\t\t\t\tanchor: \"botright\",\n\t\t\t\t\tcolor: rgb(0, 0, 0),\n\t\t\t\t\topacity: 0.8,\n\t\t\t\t\tradius: 4,\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\t// fast forward / slow down icon\n\t\t\t\tfor (let i = 0; i < 2; i++) {\n\t\t\t\t\tconst flipped = debug.timeScale < 1\n\t\t\t\t\tdrawTriangle({\n\t\t\t\t\t\tp1: vec2(-ftxt.width - pad * (flipped ? 2 : 3.5), -pad),\n\t\t\t\t\t\tp2: vec2(-ftxt.width - pad * (flipped ? 2 : 3.5), -pad - ftxt.height),\n\t\t\t\t\t\tp3: vec2(-ftxt.width - pad * (flipped ? 3.5 : 2), -pad - ftxt.height / 2),\n\t\t\t\t\t\tpos: vec2(-i * pad * 1 + (flipped ? -pad * 0.5 : 0), 0),\n\t\t\t\t\t\tcolor: rgb(255, 255, 255),\n\t\t\t\t\t\tfixed: true,\n\t\t\t\t\t})\n\t\t\t\t}\n\n\t\t\t\t// text\n\t\t\t\tdrawFormattedText(ftxt)\n\n\t\t\t\tpopTransform()\n\n\t\t\t})\n\n\t\t}\n\n\t\tif (debug.curRecording) {\n\n\t\t\tdrawUnscaled(() => {\n\n\t\t\t\tpushTransform()\n\t\t\t\tpushTranslate(0, height())\n\t\t\t\tpushTranslate(24, -24)\n\n\t\t\t\tdrawCircle({\n\t\t\t\t\tradius: 12,\n\t\t\t\t\tcolor: rgb(255, 0, 0),\n\t\t\t\t\topacity: wave(0, 1, app.time() * 4),\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\tpopTransform()\n\n\t\t\t})\n\n\t\t}\n\n\t\tif (debug.showLog && game.logs.length > 0) {\n\n\t\t\tdrawUnscaled(() => {\n\n\t\t\t\tpushTransform()\n\t\t\t\tpushTranslate(0, height())\n\t\t\t\tpushTranslate(8, -8)\n\n\t\t\t\tconst pad = 8\n\t\t\t\tconst logs = []\n\n\t\t\t\tfor (const log of game.logs) {\n\t\t\t\t\tlet str = \"\"\n\t\t\t\t\tconst style = log.msg instanceof Error ? \"error\" : \"info\"\n\t\t\t\t\tstr += `[time]${log.time.toFixed(2)}[/time]`\n\t\t\t\t\tstr += \" \"\n\t\t\t\t\tstr += `[${style}]${log.msg?.toString ? log.msg.toString() : log.msg}[/${style}]`\n\t\t\t\t\tlogs.push(str)\n\t\t\t\t}\n\n\t\t\t\tgame.logs = game.logs\n\t\t\t\t\t.filter((log) => app.time() - log.time < (gopt.logTime || LOG_TIME))\n\n\t\t\t\tconst ftext = formatText({\n\t\t\t\t\ttext: logs.join(\"\\n\"),\n\t\t\t\t\tfont: DBG_FONT,\n\t\t\t\t\tpos: vec2(pad, -pad),\n\t\t\t\t\tanchor: \"botleft\",\n\t\t\t\t\tsize: 16,\n\t\t\t\t\twidth: width() * 0.6,\n\t\t\t\t\tlineSpacing: pad / 2,\n\t\t\t\t\tfixed: true,\n\t\t\t\t\tstyles: {\n\t\t\t\t\t\t\"time\": { color: rgb(127, 127, 127) },\n\t\t\t\t\t\t\"info\": { color: rgb(255, 255, 255) },\n\t\t\t\t\t\t\"error\": { color: rgb(255, 0, 127) },\n\t\t\t\t\t},\n\t\t\t\t})\n\n\t\t\t\tdrawRect({\n\t\t\t\t\twidth: ftext.width + pad * 2,\n\t\t\t\t\theight: ftext.height + pad * 2,\n\t\t\t\t\tanchor: \"botleft\",\n\t\t\t\t\tcolor: rgb(0, 0, 0),\n\t\t\t\t\tradius: 4,\n\t\t\t\t\topacity: 0.8,\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\tdrawFormattedText(ftext)\n\t\t\t\tpopTransform()\n\n\t\t\t})\n\n\t\t}\n\n\t}\n\n\tfunction onLoading(action: (progress: number) => void) {\n\t\tgame.events.on(\"loading\", action)\n\t}\n\n\tfunction onResize(action: () => void) {\n\t\tapp.onResize(action)\n\t}\n\n\tfunction onError(action: (err: Error) => void) {\n\t\tgame.events.on(\"error\", action)\n\t}\n\n\tfunction handleErr(err: Error) {\n\n\t\taudio.ctx.suspend()\n\n\t\t// TODO: this should only run once\n\t\tapp.run(() => {\n\n\t\t\tdrawUnscaled(() => {\n\n\t\t\t\tconst pad = 32\n\t\t\t\tconst gap = 16\n\t\t\t\tconst gw = width()\n\t\t\t\tconst gh = height()\n\n\t\t\t\tconst textStyle = {\n\t\t\t\t\tsize: 36,\n\t\t\t\t\twidth: gw - pad * 2,\n\t\t\t\t\tletterSpacing: 4,\n\t\t\t\t\tlineSpacing: 4,\n\t\t\t\t\tfont: DBG_FONT,\n\t\t\t\t\tfixed: true,\n\t\t\t\t}\n\n\t\t\t\tdrawRect({\n\t\t\t\t\twidth: gw,\n\t\t\t\t\theight: gh,\n\t\t\t\t\tcolor: rgb(0, 0, 255),\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\tconst title = formatText({\n\t\t\t\t\t...textStyle,\n\t\t\t\t\ttext: \"Error\",\n\t\t\t\t\tpos: vec2(pad),\n\t\t\t\t\tcolor: rgb(255, 128, 0),\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\tdrawFormattedText(title)\n\n\t\t\t\tdrawText({\n\t\t\t\t\t...textStyle,\n\t\t\t\t\ttext: err.message,\n\t\t\t\t\tpos: vec2(pad, pad + title.height + gap),\n\t\t\t\t\tfixed: true,\n\t\t\t\t})\n\n\t\t\t\tpopTransform()\n\t\t\t\tgame.events.trigger(\"error\", err)\n\n\t\t\t})\n\n\t\t})\n\n\t}\n\n\tfunction onCleanup(action: () => void) {\n\t\tgc.push(action)\n\t}\n\n\tfunction quit() {\n\n\t\tgame.events.onOnce(\"frameEnd\", () => {\n\n\t\t\tapp.quit()\n\n\t\t\tfor (const name in winEvents) {\n\t\t\t\twindow.removeEventListener(name, winEvents[name])\n\t\t\t}\n\n\t\t\t// clear canvas\n\t\t\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT)\n\n\t\t\t// unbind everything\n\t\t\tconst numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS)\n\n\t\t\tfor (let unit = 0; unit < numTextureUnits; unit++) {\n\t\t\t\tgl.activeTexture(gl.TEXTURE0 + unit)\n\t\t\t\tgl.bindTexture(gl.TEXTURE_2D, null)\n\t\t\t\tgl.bindTexture(gl.TEXTURE_CUBE_MAP, null)\n\t\t\t}\n\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null)\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null)\n\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, null)\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, null)\n\n\t\t\t// run all scattered gc events\n\t\t\tgc.forEach((f) => f())\n\n\t\t\t// delete webgl buffers\n\t\t\tgl.deleteBuffer(gfx.vbuf)\n\t\t\tgl.deleteBuffer(gfx.ibuf)\n\n\t\t})\n\n\t}\n\n\tfunction tween<V extends LerpValue>(\n\t\tfrom: V,\n\t\tto: V,\n\t\tduration: number,\n\t\tsetValue: (value: V) => void,\n\t\teaseFunc = easings.linear,\n\t): TweenController {\n\t\tlet curTime = 0\n\t\tconst onEndEvents: Array<() => void> = []\n\t\tconst ev = onUpdate(() => {\n\t\t\tcurTime += dt()\n\t\t\tconst t = Math.min(curTime / duration, 1)\n\t\t\tsetValue(lerp(from, to, easeFunc(t)))\n\t\t\tif (t === 1) {\n\t\t\t\tev.cancel()\n\t\t\t\tsetValue(to)\n\t\t\t\tonEndEvents.forEach((action) => action())\n\t\t\t}\n\t\t})\n\t\treturn {\n\t\t\tget paused() {\n\t\t\t\treturn ev.paused\n\t\t\t},\n\t\t\tset paused(p) {\n\t\t\t\tev.paused = p\n\t\t\t},\n\t\t\tonEnd(action: () => void) {\n\t\t\t\tonEndEvents.push(action)\n\t\t\t},\n\t\t\tthen(action: () => void) {\n\t\t\t\tthis.onEnd(action)\n\t\t\t\treturn this\n\t\t\t},\n\t\t\tcancel() {\n\t\t\t\tev.cancel()\n\t\t\t},\n\t\t\tfinish() {\n\t\t\t\tev.cancel()\n\t\t\t\tsetValue(to)\n\t\t\t\tonEndEvents.forEach((action) => action())\n\t\t\t},\n\t\t}\n\t}\n\n\tlet isFirstFrame = true\n\n\t// main game loop\n\tapp.run(() => {\n\n\t\tif (!assets.loaded) {\n\t\t\tif (loadProgress() === 1 && !isFirstFrame) {\n\t\t\t\tassets.loaded = true\n\t\t\t\tgame.events.trigger(\"load\")\n\t\t\t}\n\t\t}\n\n\t\tif (!assets.loaded && gopt.loadingScreen !== false || isFirstFrame) {\n\t\t\tframeStart()\n\t\t\t// TODO: Currently if assets are not initially loaded no updates or timers will be run, however they will run if loadingScreen is set to false. What's the desired behavior or should we make them consistent?\n\t\t\tdrawLoadScreen()\n\t\t\tframeEnd()\n\t\t} else {\n\t\t\tif (!debug.paused) updateFrame()\n\t\t\tcheckFrame()\n\t\t\tframeStart()\n\t\t\tdrawFrame()\n\t\t\tif (gopt.debug !== false) drawDebug()\n\t\t\tframeEnd()\n\t\t}\n\n\t\tif (isFirstFrame) {\n\t\t\tisFirstFrame = false\n\t\t}\n\n\t\tgame.events.trigger(\"frameEnd\")\n\n\t})\n\n\t// update viewport based on user setting and fullscreen state\n\tfunction updateViewport() {\n\n\t\t// content size (scaled content size, with scale, stretch and letterbox)\n\t\t// view size (unscaled viewport size)\n\t\t// window size (will be the same as view size except letterbox mode)\n\n\t\t// canvas size\n\t\tconst pd = pixelDensity\n\t\tconst cw = gl.drawingBufferWidth / pd\n\t\tconst ch = gl.drawingBufferHeight / pd\n\n\t\tif (gopt.letterbox) {\n\n\t\t\tif (!gopt.width || !gopt.height) {\n\t\t\t\tthrow new KaboomError(\"Letterboxing requires width and height defined.\")\n\t\t\t}\n\n\t\t\tconst rc = cw / ch\n\t\t\tconst rg = gopt.width / gopt.height\n\n\t\t\tif (rc > rg) {\n\t\t\t\tconst sw = ch * rg\n\t\t\t\tconst x = (cw - sw) / 2\n\t\t\t\tgfx.viewport = {\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: 0,\n\t\t\t\t\twidth: sw,\n\t\t\t\t\theight: ch,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst sh = cw / rg\n\t\t\t\tconst y = (ch - sh) / 2\n\t\t\t\tgfx.viewport = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: y,\n\t\t\t\t\twidth: cw,\n\t\t\t\t\theight: sh,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn\n\n\t\t}\n\n\t\tif (gopt.stretch) {\n\t\t\tif (!gopt.width || !gopt.height) {\n\t\t\t\tthrow new KaboomError(\"Stretching requires width and height defined.\")\n\t\t\t}\n\t\t}\n\n\t\tgfx.viewport = {\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: cw,\n\t\t\theight: ch,\n\t\t}\n\n\t}\n\n\tfunction initEvents() {\n\n\t\tapp.onHide(() => {\n\t\t\tif (!gopt.backgroundAudio) {\n\t\t\t\taudio.ctx.suspend()\n\t\t\t}\n\t\t})\n\n\t\tapp.onShow(() => {\n\t\t\tif (!gopt.backgroundAudio) {\n\t\t\t\taudio.ctx.resume()\n\t\t\t}\n\t\t})\n\n\t\tapp.onResize(() => {\n\t\t\tif (app.isFullscreen()) return\n\t\t\tconst fixedSize = gopt.width && gopt.height\n\t\t\tif (fixedSize && !gopt.stretch && !gopt.letterbox) return\n\t\t\tcanvas.width = canvas.offsetWidth * pixelDensity\n\t\t\tcanvas.height = canvas.offsetHeight * pixelDensity\n\t\t\tupdateViewport()\n\t\t\tif (!fixedSize) {\n\t\t\t\tgfx.frameBuffer.free()\n\t\t\t\tgfx.frameBuffer = new FrameBuffer(gl.drawingBufferWidth, gl.drawingBufferHeight)\n\t\t\t\tgfx.width = gl.drawingBufferWidth / pixelDensity\n\t\t\t\tgfx.height = gl.drawingBufferHeight / pixelDensity\n\t\t\t}\n\t\t})\n\n\t\tif (gopt.debug !== false) {\n\t\t\tenterDebugMode()\n\t\t}\n\n\t\tif (gopt.burp) {\n\t\t\tenterBurpMode()\n\t\t}\n\n\t}\n\n\tupdateViewport()\n\tinitEvents()\n\n\t// the exported ctx handle\n\tconst ctx: KaboomCtx = {\n\t\tVERSION,\n\t\t// asset load\n\t\tloadRoot,\n\t\tloadProgress,\n\t\tloadSprite,\n\t\tloadSpriteAtlas,\n\t\tloadSound,\n\t\tloadBitmapFont,\n\t\tloadFont,\n\t\tloadShader,\n\t\tloadShaderURL,\n\t\tloadAseprite,\n\t\tloadPedit,\n\t\tloadBean,\n\t\tloadJSON,\n\t\tload,\n\t\tgetSprite,\n\t\tgetSound,\n\t\tgetFont,\n\t\tgetBitmapFont,\n\t\tgetShader,\n\t\tgetAsset,\n\t\tAsset,\n\t\tSpriteData,\n\t\tSoundData,\n\t\t// query\n\t\twidth,\n\t\theight,\n\t\tcenter,\n\t\tdt,\n\t\ttime: app.time,\n\t\tscreenshot: app.screenshot,\n\t\trecord,\n\t\tisFocused,\n\t\tsetCursor: app.setCursor,\n\t\tgetCursor: app.getCursor,\n\t\tsetCursorLocked: app.setCursorLocked,\n\t\tisCursorLocked: app.isCursorLocked,\n\t\tsetFullscreen: app.setFullscreen,\n\t\tisFullscreen: app.isFullscreen,\n\t\tisTouchscreen: app.isTouchscreen,\n\t\tonLoad,\n\t\tonLoading,\n\t\tonResize,\n\t\tonGamepadConnect: app.onGamepadConnect,\n\t\tonGamepadDisconnect: app.onGamepadDisconnect,\n\t\tonError,\n\t\tonCleanup,\n\t\t// misc\n\t\tcamPos,\n\t\tcamScale,\n\t\tcamRot,\n\t\tshake,\n\t\ttoScreen,\n\t\ttoWorld,\n\t\tsetGravity,\n\t\tgetGravity,\n\t\tsetBackground,\n\t\tgetBackground,\n\t\tgetGamepads: app.getGamepads,\n\t\t// obj\n\t\tadd,\n\t\tmake,\n\t\tdestroy,\n\t\tdestroyAll,\n\t\tget,\n\t\treadd,\n\t\t// comps\n\t\tpos,\n\t\tscale,\n\t\trotate,\n\t\tcolor,\n\t\topacity,\n\t\tanchor,\n\t\tarea,\n\t\tsprite,\n\t\ttext,\n\t\trect,\n\t\tcircle,\n\t\tuvquad,\n\t\toutline,\n\t\tbody,\n\t\tdoubleJump,\n\t\tshader,\n\t\ttimer,\n\t\tfixed,\n\t\tstay,\n\t\thealth,\n\t\tlifespan,\n\t\tz,\n\t\tmove,\n\t\toffscreen,\n\t\tfollow,\n\t\tstate,\n\t\tfadeIn,\n\t\tmask,\n\t\ttile,\n\t\tagent,\n\t\t// group events\n\t\ton,\n\t\tonUpdate,\n\t\tonDraw,\n\t\tonAdd,\n\t\tonDestroy,\n\t\tonClick,\n\t\tonCollide,\n\t\tonCollideUpdate,\n\t\tonCollideEnd,\n\t\tonHover,\n\t\tonHoverUpdate,\n\t\tonHoverEnd,\n\t\t// input\n\t\tonKeyDown: app.onKeyDown,\n\t\tonKeyPress: app.onKeyPress,\n\t\tonKeyPressRepeat: app.onKeyPressRepeat,\n\t\tonKeyRelease: app.onKeyRelease,\n\t\tonMouseDown: app.onMouseDown,\n\t\tonMousePress: app.onMousePress,\n\t\tonMouseRelease: app.onMouseRelease,\n\t\tonMouseMove: app.onMouseMove,\n\t\tonCharInput: app.onCharInput,\n\t\tonTouchStart: app.onTouchStart,\n\t\tonTouchMove: app.onTouchMove,\n\t\tonTouchEnd: app.onTouchEnd,\n\t\tonScroll: app.onScroll,\n\t\tonHide: app.onHide,\n\t\tonShow: app.onShow,\n\t\tonGamepadButtonDown: app.onGamepadButtonDown,\n\t\tonGamepadButtonPress: app.onGamepadButtonPress,\n\t\tonGamepadButtonRelease: app.onGamepadButtonRelease,\n\t\tonGamepadStick: app.onGamepadStick,\n\t\tmousePos: mousePos,\n\t\tmouseDeltaPos: app.mouseDeltaPos,\n\t\tisKeyDown: app.isKeyDown,\n\t\tisKeyPressed: app.isKeyPressed,\n\t\tisKeyPressedRepeat: app.isKeyPressedRepeat,\n\t\tisKeyReleased: app.isKeyReleased,\n\t\tisMouseDown: app.isMouseDown,\n\t\tisMousePressed: app.isMousePressed,\n\t\tisMouseReleased: app.isMouseReleased,\n\t\tisMouseMoved: app.isMouseMoved,\n\t\tisGamepadButtonPressed: app.isGamepadButtonPressed,\n\t\tisGamepadButtonDown: app.isGamepadButtonDown,\n\t\tisGamepadButtonReleased: app.isGamepadButtonReleased,\n\t\t// getGamepadStick,\n\t\tcharInputted: app.charInputted,\n\t\t// timer\n\t\tloop,\n\t\twait,\n\t\t// audio\n\t\tplay,\n\t\tvolume,\n\t\tburp,\n\t\taudioCtx: audio.ctx,\n\t\t// math\n\t\tTimer,\n\t\tLine,\n\t\tRect,\n\t\tCircle,\n\t\tPolygon,\n\t\tVec2,\n\t\tColor,\n\t\tMat4,\n\t\tQuad,\n\t\tRNG,\n\t\trand,\n\t\trandi,\n\t\trandSeed,\n\t\tvec2,\n\t\trgb,\n\t\thsl2rgb,\n\t\tquad,\n\t\tchoose,\n\t\tchance,\n\t\tlerp,\n\t\ttween,\n\t\teasings,\n\t\tmap,\n\t\tmapc,\n\t\twave,\n\t\tdeg2rad,\n\t\trad2deg,\n\t\tclamp,\n\t\ttestLineLine,\n\t\ttestRectRect,\n\t\ttestRectLine,\n\t\ttestRectPoint,\n\t\ttestCirclePolygon,\n\t\ttestLinePoint,\n\t\ttestLineCircle,\n\t\t// raw draw\n\t\tdrawSprite,\n\t\tdrawText,\n\t\tformatText,\n\t\tdrawRect,\n\t\tdrawLine,\n\t\tdrawLines,\n\t\tdrawTriangle,\n\t\tdrawCircle,\n\t\tdrawEllipse,\n\t\tdrawUVQuad,\n\t\tdrawPolygon,\n\t\tdrawFormattedText,\n\t\tdrawMasked,\n\t\tdrawSubtracted,\n\t\tpushTransform,\n\t\tpopTransform,\n\t\tpushTranslate,\n\t\tpushScale,\n\t\tpushRotate,\n\t\tpushMatrix,\n\t\tusePostEffect,\n\t\t// debug\n\t\tdebug,\n\t\t// scene\n\t\tscene,\n\t\tgo,\n\t\tonSceneLeave,\n\t\t// level\n\t\taddLevel,\n\t\t// storage\n\t\tgetData,\n\t\tsetData,\n\t\tdownload,\n\t\tdownloadJSON,\n\t\tdownloadText,\n\t\tdownloadBlob,\n\t\t// plugin\n\t\tplug,\n\t\t// char sets\n\t\tASCII_CHARS,\n\t\t// dom\n\t\tcanvas: app.canvas(),\n\t\t// misc\n\t\taddKaboom,\n\t\t// dirs\n\t\tLEFT: Vec2.LEFT,\n\t\tRIGHT: Vec2.RIGHT,\n\t\tUP: Vec2.UP,\n\t\tDOWN: Vec2.DOWN,\n\t\t// colors\n\t\tRED: Color.RED,\n\t\tGREEN: Color.GREEN,\n\t\tBLUE: Color.BLUE,\n\t\tYELLOW: Color.YELLOW,\n\t\tMAGENTA: Color.MAGENTA,\n\t\tCYAN: Color.CYAN,\n\t\tWHITE: Color.WHITE,\n\t\tBLACK: Color.BLACK,\n\t\tquit,\n\t\t// helpers\n\t\tEvent,\n\t\tEventHandler,\n\t\tEventController,\n\t\tKaboomError,\n\t}\n\n\tif (gopt.plugins) {\n\t\tgopt.plugins.forEach(plug)\n\t}\n\n\t// export everything to window if global is set\n\tif (gopt.global !== false) {\n\t\tfor (const k in ctx) {\n\t\t\twindow[k] = ctx[k]\n\t\t}\n\t}\n\n\tif (gopt.focus !== false) {\n\t\tapp.canvas().focus()\n\t}\n\n\treturn ctx\n\n}\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n", "/** @internal */\nexport const options = function<T>(input: T, defaults: object): T {\n  if (input === null || typeof input === 'undefined') {\n    // tslint:disable-next-line:no-object-literal-type-assertion\n    input = {} as T;\n  }\n\n  const output = {...input};\n\n  // tslint:disable-next-line:no-for-in\n  for (const key in defaults) {\n    if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {\n      output[key] = defaults[key];\n    }\n  }\n\n  if (typeof Object.getOwnPropertySymbols === 'function') {\n    const symbols = Object.getOwnPropertySymbols(defaults);\n    for (let i = 0; i < symbols.length; i++) {\n      const symbol = symbols[i];\n      if (defaults.propertyIsEnumerable(symbol) && typeof input[symbol] === 'undefined') {\n        output[symbol] = defaults[symbol];\n      }\n    }\n  }\n\n  return output;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/** @internal */ const math_random = Math.random;\n\n\nexport const EPSILON = 1e-9;\n\n/** @internal @deprecated */\nexport const isFinite = Number.isFinite;\n\n/**\n * @deprecated\n * Next Largest Power of 2 Given a binary integer value x, the next largest\n * power of 2 can be computed by a SWAR algorithm that recursively \"folds\" the\n * upper bits into the lower bits. This process yields a bit vector with the\n * same most significant 1 as x, but all 1's below it. Adding 1 to that value\n * yields the next largest power of 2. For a 32-bit value:\n */\nexport function nextPowerOfTwo(x: number): number {\n  x |= (x >> 1);\n  x |= (x >> 2);\n  x |= (x >> 4);\n  x |= (x >> 8);\n  x |= (x >> 16);\n  return x + 1;\n}\n\n/** @deprecated */\nexport function isPowerOfTwo(x: number): boolean {\n  return x > 0 && (x & (x - 1)) === 0;\n}\n\n/** @deprecated */\nexport function mod(num: number, min?: number, max?: number): number {\n  if (typeof min === 'undefined') {\n    max = 1;\n    min = 0;\n  } else if (typeof max === 'undefined') {\n    max = min;\n    min = 0;\n  }\n  if (max > min) {\n    num = (num - min) % (max - min);\n    return num + (num < 0 ? max : min);\n  } else {\n    num = (num - max) % (min - max);\n    return num + (num <= 0 ? min : max);\n  }\n}\n\n/**\n * @deprecated\n * Returns a min if num is less than min, and max if more than max, otherwise returns num.\n */\nexport function clamp(num: number, min: number, max: number): number {\n  if (num < min) {\n    return min;\n  } else if (num > max) {\n    return max;\n  } else {\n    return num;\n  }\n}\n\n/**\n * @deprecated\n * Returns a random number between min and max when two arguments are provided.\n * If one arg is provided between 0 to max.\n * If one arg is passed between 0 to 1.\n */\nexport function random(min?: number, max?: number): number {\n  if (typeof min === 'undefined') {\n    max = 1;\n    min = 0;\n  } else if (typeof max === 'undefined') {\n    max = min;\n    min = 0;\n  }\n  return min === max ? min : math_random() * (max - min) + min;\n}\n\n/** @ignore */\nexport const math = Object.create(Math);\nmath.EPSILON = EPSILON;\nmath.isFinite = isFinite;\nmath.nextPowerOfTwo = nextPowerOfTwo;\nmath.isPowerOfTwo = isPowerOfTwo;\nmath.mod = mod;\nmath.clamp = clamp;\nmath.random = random;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { EPSILON } from \"./Math\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_sqrt = Math.sqrt;\n/** @internal */ const math_max = Math.max;\n/** @internal */ const math_min = Math.min;\n\n\nexport interface Vec2Value {\n  x: number;\n  y: number;\n}\n\nexport class Vec2 {\n  x: number;\n  y: number;\n\n  constructor(x: number, y: number);\n  constructor(obj: { x: number, y: number });\n  constructor();\n  // tslint:disable-next-line:typedef\n  constructor(x?, y?) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Vec2)) {\n      return new Vec2(x, y);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      this.x = x;\n      this.y = y;\n    }\n    _ASSERT && Vec2.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    return obj;\n  }\n\n  static zero(): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number): Vec2 {\n    const obj = Object.create(Vec2.prototype);\n    obj.x = x;\n    obj.y = y;\n    return obj;\n  }\n\n  static clone(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(v.x, v.y);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /**\n   * Does this vector contain finite coordinates?\n   */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Number.isFinite(obj.x) && Number.isFinite(obj.y);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Vec2.isValid(o), 'Invalid Vec2!', o);\n  }\n\n  clone(): Vec2 {\n    return Vec2.clone(this);\n  }\n\n  /**\n   * Set this vector to all zeros.\n   *\n   * @returns this\n   */\n  setZero(): Vec2 {\n    this.x = 0.0;\n    this.y = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number): Vec2;\n  set(value: Vec2Value): Vec2;\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  // tslint:disable-next-line:typedef\n  set(x, y?) {\n    if (typeof x === 'object') {\n      _ASSERT && Vec2.assert(x);\n      this.x = x.x;\n      this.y = x.y;\n    } else {\n      _ASSERT && console.assert(Number.isFinite(x));\n      _ASSERT && console.assert(Number.isFinite(y));\n      this.x = x;\n      this.y = y;\n    }\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n   setNum(x: number, y: number) {\n    _ASSERT && console.assert(Number.isFinite(x));\n    _ASSERT && console.assert(Number.isFinite(y));\n    this.x = x;\n    this.y = y;\n\n    return this;\n  }\n\n  /**\n   * Set this vector to some specified coordinates.\n   *\n   * @returns this\n   */\n  setVec2(value: Vec2Value) {\n    _ASSERT && Vec2.assert(value);\n    this.x = value.x;\n    this.y = value.y;\n\n    return this;\n  }\n\n  /** @internal @deprecated Use setCombine or setMul */\n  wSet(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.setCombine(a, v, b, w);\n    } else {\n      return this.setMul(a, v);\n    }\n  }\n\n  /**\n   * Set linear combination of v and w: `a * v + b * w`\n   */\n  setCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && console.assert(Number.isFinite(b));\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  /**\n   * Add a vector to this vector.\n   *\n   * @returns this\n   */\n  add(w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x += w.x;\n    this.y += w.y;\n    return this;\n  }\n\n  /** @internal @deprecated Use addCombine or addMul */\n  wAdd(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.addCombine(a, v, b, w);\n    } else {\n      return this.addMul(a, v);\n    }\n  }\n\n  /**\n   * Add linear combination of v and w: `a * v + b * w`\n   */\n  addCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && console.assert(Number.isFinite(b));\n    _ASSERT && Vec2.assert(w);\n\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  addMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n\n  /**\n   * @deprecated Use subCombine or subMul\n   */\n  wSub(a: number, v: Vec2Value, b?: number, w?: Vec2Value): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return this.subCombine(a, v, b, w);\n    } else {\n      return this.subMul(a, v);\n    }}\n\n  /**\n   * Subtract linear combination of v and w: `a * v + b * w`\n   */\n  subCombine(a: number, v: Vec2Value, b: number, w: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && console.assert(Number.isFinite(b));\n    _ASSERT && Vec2.assert(w);\n    const x = a * v.x + b * w.x;\n    const y = a * v.y + b * w.y;\n\n    // `this` may be `w`\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  subMul(a: number, v: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(v);\n    const x = a * v.x;\n    const y = a * v.y;\n\n    this.x -= x;\n    this.y -= y;\n    return this;\n  }\n\n  /**\n   * Subtract a vector from this vector\n   *\n   * @returns this\n   */\n  sub(w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(w);\n    this.x -= w.x;\n    this.y -= w.y;\n    return this;\n  }\n\n  /**\n   * Multiply this vector by a scalar.\n   *\n   * @returns this\n   */\n  mul(m: number): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(m));\n    this.x *= m;\n    this.y *= m;\n    return this;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  length(): number {\n    return Vec2.lengthOf(this);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  lengthSquared(): number {\n    return Vec2.lengthSquared(this);\n  }\n\n  /**\n   * Convert this vector into a unit vector.\n   *\n   * @returns old length\n   */\n  normalize(): number {\n    const length = this.length();\n    if (length < EPSILON) {\n      return 0.0;\n    }\n    const invLength = 1.0 / length;\n    this.x *= invLength;\n    this.y *= invLength;\n    return length;\n  }\n\n  /**\n   * Get the length of this vector (the norm).\n   *\n   * For performance, use this instead of lengthSquared (if possible).\n   */\n  static lengthOf(v: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    return math_sqrt(v.x * v.x + v.y * v.y);\n  }\n\n  /**\n   * Get the length squared.\n   */\n  static lengthSquared(v: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    return v.x * v.x + v.y * v.y;\n  }\n\n  static distance(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return math_sqrt(dx * dx + dy * dy);\n  }\n\n  static distanceSquared(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    const dx = v.x - w.x;\n    const dy = v.y - w.y;\n    return dx * dx + dy * dy;\n  }\n\n  static areEqual(v: Vec2Value, w: Vec2Value): boolean {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v === w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;\n  }\n\n  /**\n   * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)\n   */\n  static skew(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.y, v.x);\n  }\n\n  /** Dot product on two vectors */\n  static dot(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.x + v.y * w.y;\n  }\n\n  /** Cross product between two vectors */\n  static cross(v: Vec2Value, w: Vec2Value): number;\n  /** Cross product between a vector and a scalar */\n  static cross(v: Vec2Value, w: number): Vec2;\n  /** Cross product between a scalar and a vector */\n  static cross(v: number, w: Vec2Value): Vec2;\n  static cross(v: any, w: any): any {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && console.assert(Number.isFinite(w));\n      return Vec2.neo(w * v.y, -w * v.x);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && console.assert(Number.isFinite(v));\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y, v * w.x);\n\n    } else {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && Vec2.assert(w);\n      return v.x * w.y - v.y * w.x;\n    }\n  }\n\n  /** Cross product on two vectors */\n  static crossVec2Vec2(v: Vec2Value, w: Vec2Value): number {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return v.x * w.y - v.y * w.x;\n  }\n\n  /** Cross product on a vector and a scalar */\n  static crossVec2Num(v: Vec2Value, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && console.assert(Number.isFinite(w));\n    return Vec2.neo(w * v.y, -w * v.x);\n  }\n\n  /** Cross product on a vector and a scalar */\n  static crossNumVec2(v: number, w: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(v));\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y, v * w.x);\n  }\n\n  /** Returns `a + (v x w)` */\n  static addCross(a: Vec2Value, v: Vec2Value, w: number): Vec2;\n  /** Returns `a + (v x w)` */\n  static addCross(a: Vec2Value, v: number, w: Vec2Value): Vec2;\n  static addCross(a: Vec2Value, v: any, w: any): Vec2 {\n    if (typeof w === 'number') {\n      _ASSERT && Vec2.assert(v);\n      _ASSERT && console.assert(Number.isFinite(w));\n      return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n\n    } else if (typeof v === 'number') {\n      _ASSERT && console.assert(Number.isFinite(v));\n      _ASSERT && Vec2.assert(w);\n      return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossVec2Num(a: Vec2Value, v: Vec2Value, w: number): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && console.assert(Number.isFinite(w));\n    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);\n  }\n\n  /**\n   * Returns `a + (v x w)`\n   */\n  static addCrossNumVec2(a: Vec2Value, v: number, w: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(v));\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);\n  }\n\n  static add(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x + w.x, v.y + w.y);\n  }\n\n  /** @internal @deprecated */\n  static wAdd(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    if (typeof b !== 'undefined' || typeof w !== 'undefined') {\n      return Vec2.combine(a, v, b, w);\n    } else {\n      return Vec2.mulNumVec2(a, v);\n    }\n  }\n\n  static combine(a: number, v: Vec2, b: number, w: Vec2): Vec2 {\n    return Vec2.zero().setCombine(a, v, b, w);\n  }\n\n  static sub(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(v.x - w.x, v.y - w.y);\n  }\n\n  static mul(a: Vec2Value, b: number): Vec2;\n  static mul(a: number, b: Vec2Value): Vec2;\n  static mul(a: any, b: any): Vec2 {\n    if (typeof a === 'object') {\n      _ASSERT && Vec2.assert(a);\n      _ASSERT && console.assert(Number.isFinite(b));\n      return Vec2.neo(a.x * b, a.y * b);\n\n    } else if (typeof b === 'object') {\n      _ASSERT && console.assert(Number.isFinite(a));\n      _ASSERT && Vec2.assert(b);\n      return Vec2.neo(a * b.x, a * b.y);\n    }\n  }\n\n  static mulVec2Num(a: Vec2Value, b: number): Vec2 {\n    _ASSERT && Vec2.assert(a);\n    _ASSERT && console.assert(Number.isFinite(b));\n    return Vec2.neo(a.x * b, a.y * b);\n  }\n\n  static mulNumVec2(a: number, b: Vec2Value): Vec2 {\n    _ASSERT && console.assert(Number.isFinite(a));\n    _ASSERT && Vec2.assert(b);\n    return Vec2.neo(a * b.x, a * b.y);\n  }\n\n  neg(): Vec2 {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  static neg(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(-v.x, -v.y);\n  }\n\n  static abs(v: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(math_abs(v.x), math_abs(v.y));\n  }\n\n  static mid(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);\n  }\n\n  static upper(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(math_max(v.x, w.x), math_max(v.y, w.y));\n  }\n\n  static lower(v: Vec2Value, w: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    _ASSERT && Vec2.assert(w);\n    return Vec2.neo(math_min(v.x, w.x), math_min(v.y, w.y));\n  }\n\n  clamp(max: number): Vec2 {\n    const lengthSqr = this.x * this.x + this.y * this.y;\n    if (lengthSqr > max * max) {\n      const scale = max / math_sqrt(lengthSqr);\n      this.x *= scale;\n      this.y *= scale;\n    }\n    return this;\n  }\n\n  static clamp(v: Vec2Value, max: number): Vec2 {\n    const r = Vec2.neo(v.x, v.y);\n    r.clamp(max);\n    return r;\n  }\n\n  /**  @internal @deprecated */\n  static scaleFn(x: number, y: number) {\n    // todo: this was used in examples, remove in the future\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x * x, v.y * y);\n    };\n  }\n\n  /**  @internal @deprecated */\n  static translateFn(x: number, y: number) {\n    // todo: this was used in examples, remove in the future\n    return function(v: Vec2): Vec2 {\n      return Vec2.neo(v.x + x, v.y + y);\n    };\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { EPSILON } from '../common/Math';\nimport { Vec2, Vec2Value } from '../common/Vec2';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_max = Math.max;\n/** @internal */ const math_min = Math.min;\n\n/**\n * Ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n */\nexport interface RayCastInput {\n  p1: Vec2;\n  p2: Vec2;\n  maxFraction: number;\n}\n\nexport type RayCastCallback = (subInput: RayCastInput, id: number) => number;\n\n/**\n * Ray-cast output data. The ray hits at `p1 + fraction * (p2 - p1)`,\n * where `p1` and `p2` come from RayCastInput.\n */\nexport interface RayCastOutput {\n  normal: Vec2;\n  fraction: number;\n}\n\nexport interface AABBValue {\n  lowerBound: Vec2Value;\n  upperBound: Vec2Value;\n}\n\nexport class AABB {\n  lowerBound: Vec2;\n  upperBound: Vec2;\n\n  constructor(lower?: Vec2Value, upper?: Vec2Value) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof AABB)) {\n      return new AABB(lower, upper);\n    }\n\n    this.lowerBound = Vec2.zero();\n    this.upperBound = Vec2.zero();\n\n    if (typeof lower === 'object') {\n      this.lowerBound.setVec2(lower);\n    }\n    if (typeof upper === 'object') {\n      this.upperBound.setVec2(upper);\n    } else if (typeof lower === 'object') {\n      this.upperBound.setVec2(lower);\n    }\n  }\n\n  /**\n   * Verify that the bounds are sorted.\n   */\n  isValid(): boolean {\n    return AABB.isValid(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!AABB.isValid(o), 'Invalid AABB!', o);\n  }\n\n  /**\n   * Get the center of the AABB.\n   */\n  getCenter(): Vec2 {\n    return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n  }\n\n  /**\n   * Get the extents of the AABB (half-widths).\n   */\n  getExtents(): Vec2 {\n    return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n  }\n\n  /**\n   * Get the perimeter length.\n   */\n  getPerimeter(): number {\n    return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n  }\n\n  /**\n   * Combine one or two AABB into this one.\n   */\n  combine(a: AABBValue, b?: AABBValue): void {\n    b = b || this;\n\n    const lowerA = a.lowerBound;\n    const upperA = a.upperBound;\n    const lowerB = b.lowerBound;\n    const upperB = b.upperBound;\n\n    const lowerX = math_min(lowerA.x, lowerB.x);\n    const lowerY = math_min(lowerA.y, lowerB.y);\n    const upperX = math_max(upperB.x, upperA.x);\n    const upperY = math_max(upperB.y, upperA.y);\n\n    this.lowerBound.setNum(lowerX, lowerY);\n    this.upperBound.setNum(upperX, upperY);\n  }\n\n  combinePoints(a: Vec2Value, b: Vec2Value): void {\n    this.lowerBound.setNum(math_min(a.x, b.x), math_min(a.y, b.y));\n    this.upperBound.setNum(math_max(a.x, b.x), math_max(a.y, b.y));\n  }\n\n  set(aabb: AABBValue): void {\n    this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n    this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n  }\n\n  contains(aabb: AABBValue): boolean {\n    let result = true;\n    result = result && this.lowerBound.x <= aabb.lowerBound.x;\n    result = result && this.lowerBound.y <= aabb.lowerBound.y;\n    result = result && aabb.upperBound.x <= this.upperBound.x;\n    result = result && aabb.upperBound.y <= this.upperBound.y;\n    return result;\n  }\n\n  extend(value: number): AABB {\n    AABB.extend(this, value);\n    return this;\n  }\n\n  static extend(out: AABBValue, value: number): AABBValue {\n    out.lowerBound.x -= value;\n    out.lowerBound.y -= value;\n    out.upperBound.x += value;\n    out.upperBound.y += value;\n    return out;\n  }\n\n  static testOverlap(a: AABBValue, b: AABBValue): boolean {\n    const d1x = b.lowerBound.x - a.upperBound.x;\n    const d2x = a.lowerBound.x - b.upperBound.x;\n\n    const d1y = b.lowerBound.y - a.upperBound.y;\n    const d2y = a.lowerBound.y - b.upperBound.y;\n\n    if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n      return false;\n    }\n    return true;\n  }\n\n  static areEqual(a: AABBValue, b: AABBValue): boolean {\n    return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);\n  }\n\n  static diff(a: AABBValue, b: AABBValue): number {\n    const wD = math_max(0, math_min(a.upperBound.x, b.upperBound.x) - math_max(b.lowerBound.x, a.lowerBound.x));\n    const hD = math_max(0, math_min(a.upperBound.y, b.upperBound.y) - math_max(b.lowerBound.y, a.lowerBound.y));\n\n    const wA = a.upperBound.x - a.lowerBound.x;\n    const hA = a.upperBound.y - a.lowerBound.y;\n\n    const wB = b.upperBound.x - b.lowerBound.x;\n    const hB = b.upperBound.y - b.lowerBound.y;\n\n    return wA * hA + wB * hB - wD * hD;\n  }\n\n  rayCast(output: RayCastOutput, input: RayCastInput): boolean {\n    // From Real-time Collision Detection, p179.\n\n    let tmin = -Infinity;\n    let tmax = Infinity;\n\n    const p = input.p1;\n    const d = Vec2.sub(input.p2, input.p1);\n    const absD = Vec2.abs(d);\n\n    const normal = Vec2.zero();\n\n    for (let f: 'x' | 'y' = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {\n      if (absD.x < EPSILON) {\n        // Parallel.\n        if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n          return false;\n        }\n      } else {\n        const inv_d = 1.0 / d[f];\n        let t1 = (this.lowerBound[f] - p[f]) * inv_d;\n        let t2 = (this.upperBound[f] - p[f]) * inv_d;\n\n        // Sign of the normal vector.\n        let s = -1.0;\n\n        if (t1 > t2) {\n          const temp = t1;\n          t1 = t2;\n          t2 = temp;\n          s = 1.0;\n        }\n\n        // Push the min up\n        if (t1 > tmin) {\n          normal.setZero();\n          normal[f] = s;\n          tmin = t1;\n        }\n\n        // Pull the max down\n        tmax = math_min(tmax, t2);\n\n        if (tmin > tmax) {\n          return false;\n        }\n      }\n    }\n\n    // Does the ray start inside the box?\n    // Does the ray intersect beyond the max fraction?\n    if (tmin < 0.0 || input.maxFraction < tmin) {\n      return false;\n    }\n\n    // Intersection.\n    output.fraction = tmin;\n    output.normal = normal;\n    return true;\n  }\n\n  /** @internal */ toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static combinePoints(out: AABBValue, a: Vec2Value, b: Vec2Value): AABBValue {\n    out.lowerBound.x = math_min(a.x, b.x);\n    out.lowerBound.y = math_min(a.y, b.y);\n    out.upperBound.x = math_max(a.x, b.x);\n    out.upperBound.y = math_max(a.y, b.y);\n    return out;\n  }\n\n  static combinedPerimeter(a: AABBValue, b: AABBValue) {\n    const lx = math_min(a.lowerBound.x, b.lowerBound.x);\n    const ly = math_min(a.lowerBound.y, b.lowerBound.y);\n    const ux = math_max(a.upperBound.x, b.upperBound.x);\n    const uy = math_max(a.upperBound.y, b.upperBound.y);\n    return 2.0 * (ux - lx + uy - ly);  \n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/** @internal */ const math_PI = Math.PI;\n\n\n/**\n * Tuning constants based on meters-kilograms-seconds (MKS) units.\n * \n * Some tolerances are absolute and some are relative. Absolute tolerances use MKS units.\n */\nexport class Settings {\n  /**\n   * You can use this to change the length scale used by your game.\n   * \n   * For example for inches you could use 39.4.\n   */\n  static lengthUnitsPerMeter = 1.0;\n  \n  // Collision\n  /**\n   * The maximum number of contact points between two convex shapes. Do not change\n   * this value.\n   */\n  static maxManifoldPoints: number = 2;\n\n  /**\n   * The maximum number of vertices on a convex polygon. You cannot increase this\n   * too much because BlockAllocator has a maximum object size.\n   */\n  static maxPolygonVertices: number = 12;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This allows proxies to move\n   * by a small amount without triggering a tree adjustment. This is in meters.\n   */\n  static aabbExtension: number = 0.1;\n\n  /**\n   * This is used to fatten AABBs in the dynamic tree. This is used to predict the\n   * future position based on the current displacement. This is a dimensionless\n   * multiplier.\n   */\n  static aabbMultiplier: number = 2.0;\n\n  /**\n   * A small length used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static linearSlop: number = 0.005;\n\n  /**\n   * A small angle used as a collision and constraint tolerance. Usually it is\n   * chosen to be numerically significant, but visually insignificant.\n   */\n  static angularSlop: number = (2.0 / 180.0 * math_PI);\n\n  /**\n   * The radius of the polygon/edge shape skin. This should not be modified.\n   * Making this smaller means polygons will have an insufficient buffer for\n   * continuous collision. Making it larger may create artifacts for vertex\n   * collision.\n   */\n  static get polygonRadius(): number { return 2.0 * Settings.linearSlop; }\n\n  /**\n   * Maximum number of sub-steps per contact in continuous physics simulation.\n   */\n  static maxSubSteps: number = 8;\n\n  // Dynamics\n\n  /**\n   * Maximum number of contacts to be handled to solve a TOI impact.\n   */\n  static maxTOIContacts: number = 32;\n\n  /**\n   * Maximum iterations to solve a TOI.\n   */\n  static maxTOIIterations: number = 20;\n\n  /**\n   * Maximum iterations to find Distance.\n   */\n  static maxDistanceIterations: number = 20;\n\n  /**\n   * A velocity threshold for elastic collisions. Any collision with a relative\n   * linear velocity below this threshold will be treated as inelastic.\n   */\n  static velocityThreshold: number = 1.0;\n\n  /**\n   * The maximum linear position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxLinearCorrection: number = 0.2;\n\n  /**\n   * The maximum angular position correction used when solving constraints. This\n   * helps to prevent overshoot.\n   */\n  static maxAngularCorrection: number = (8.0 / 180.0 * math_PI);\n\n  /**\n   * The maximum linear velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxTranslation: number = 2.0;\n\n  /**\n   * The maximum angular velocity of a body. This limit is very large and is used\n   * to prevent numerical problems. You shouldn't need to adjust Settings.\n   */\n  static maxRotation: number = (0.5 * math_PI);\n\n  /**\n   * This scale factor controls how fast overlap is resolved. Ideally this would\n   * be 1 so that overlap is removed in one time step. However using values close\n   * to 1 often lead to overshoot.\n   */\n  static baumgarte: number = 0.2;\n  static toiBaugarte: number = 0.75;\n\n  // Sleep\n\n  /**\n   * The time that a body must be still before it will go to sleep.\n   */\n  static timeToSleep: number = 0.5;\n\n  /**\n   * A body cannot sleep if its linear velocity is above this tolerance.\n   */\n  static linearSleepTolerance: number = 0.01;\n\n  /**\n   * A body cannot sleep if its angular velocity is above this tolerance.\n   */\n  static angularSleepTolerance: number = (2.0 / 180.0 * math_PI);\n}\n\n/** @internal */\nexport class SettingsInternal {\n  static get maxManifoldPoints() {\n    return Settings.maxManifoldPoints;\n  }\n  static get maxPolygonVertices() {\n    return Settings.maxPolygonVertices;\n  }\n  static get aabbExtension() {\n    return Settings.aabbExtension * Settings.lengthUnitsPerMeter;\n  }\n  static get aabbMultiplier() {\n    return Settings.aabbMultiplier;\n  }\n  static get linearSlop() {\n    return Settings.linearSlop * Settings.lengthUnitsPerMeter;\n  }\n  static get linearSlopSquared() {\n    return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;\n  }\n  static get angularSlop() {\n    return Settings.angularSlop;\n  }\n  static get polygonRadius() {\n    return 2.0 * Settings.linearSlop;\n  }\n  static get maxSubSteps() {\n    return Settings.maxSubSteps;\n  }\n  static get maxTOIContacts() {\n    return Settings.maxTOIContacts;\n  }\n  static get maxTOIIterations() {\n    return Settings.maxTOIIterations;\n  }\n  static get maxDistanceIterations() {\n    return Settings.maxDistanceIterations;\n  }\n  static get velocityThreshold() {\n    return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;\n  }\n  static get maxLinearCorrection() {\n    return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;\n  }\n  static get maxAngularCorrection() {\n    return Settings.maxAngularCorrection;\n  }\n  static get maxTranslation() {\n    return Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n  }\n  static get maxTranslationSquared() {\n    return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n  }\n  static get maxRotation() {\n    return Settings.maxRotation;\n  }\n  static get maxRotationSquared() {\n    return Settings.maxRotation * Settings.maxRotation;\n  }\n  static get baumgarte() {\n    return Settings.baumgarte;\n  }\n  static get toiBaugarte() {\n    return Settings.toiBaugarte;\n  }\n  static get timeToSleep() {\n    return Settings.timeToSleep;\n  }\n  static get linearSleepTolerance() {\n    return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n  }\n  static get linearSleepToleranceSqr() {\n    return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n  }\n  static get angularSleepTolerance() {\n    return Settings.angularSleepTolerance;\n  }\n  static get angularSleepToleranceSqr() {\n    return Settings.angularSleepTolerance * Settings.angularSleepTolerance;\n  }\n}\n", "/*\n * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js\n *\n * This software is provided 'as-is', without any express or implied\n * warranty.  In no event will the authors be held liable for any damages\n * arising from the use of this software.\n * Permission is granted to anyone to use this software for any purpose,\n * including commercial applications, and to alter it and redistribute it\n * freely, subject to the following restrictions:\n * 1. The origin of this software must not be misrepresented; you must not\n * claim that you wrote the original software. If you use this software\n * in a product, an acknowledgment in the product documentation would be\n * appreciated but is not required.\n * 2. Altered source versions must be plainly marked as such, and must not be\n * misrepresented as being the original software.\n * 3. This notice may not be removed or altered from any source distribution.\n */\n\n/** @internal */\nexport interface PoolOptions<T> {\n  max?: number,\n  create?: () => T,\n  /** Called when an object is being re-allocated. */\n  allocate?: (item: T) => void,\n  /** Called when an object is returned to pool. */\n  release?: (item: T) => void,\n  /** Called when an object is returned to the pool but will be disposed from pool. */\n  dispose?: (item: T) => T,\n}\n\n/** @internal */\nexport class Pool<T> {\n  _list: T[] = [];\n  _max: number = Infinity;\n\n  _createFn: () => T;\n  _hasCreateFn: boolean = false;\n  _createCount: number = 0;\n\n  _allocateFn: (item: T) => void;\n  _hasAllocateFn: boolean = false;\n  _allocateCount: number = 0;\n\n  _releaseFn: (item: T) => void;\n  _hasReleaseFn: boolean = false;\n  _releaseCount: number = 0;\n\n  _disposeFn: (item: T) => T;\n  _hasDisposeFn: boolean = false;\n  _disposeCount: number = 0;\n\n  constructor(opts: PoolOptions<T>) {\n    this._list = [];\n    this._max = opts.max || this._max;\n\n    this._createFn = opts.create;\n    this._hasCreateFn = typeof this._createFn === 'function';\n    this._allocateFn = opts.allocate;\n    this._hasAllocateFn = typeof this._allocateFn === 'function';\n    this._releaseFn = opts.release;\n    this._hasReleaseFn = typeof this._releaseFn === 'function';\n    this._disposeFn = opts.dispose;\n    this._hasDisposeFn = typeof this._disposeFn === 'function';\n  }\n\n  max(n?: number): number | Pool<T> {\n    if (typeof n === 'number') {\n      this._max = n;\n      return this;\n    }\n    return this._max;\n  }\n\n  size(): number {\n    return this._list.length;\n  }\n\n  allocate(): T {\n    let item: T;\n    if (this._list.length > 0) {\n      item = this._list.shift();\n    } else {\n      this._createCount++;\n      if (this._hasCreateFn) {\n        item = this._createFn();\n      } else {\n        // tslint:disable-next-line:no-object-literal-type-assertion\n        item = {} as T;\n      }\n    }\n    this._allocateCount++;\n    if (this._hasAllocateFn) {\n      this._allocateFn(item);\n    }\n    return item;\n  }\n\n  release(item: T): void {\n    if (this._list.length < this._max) {\n      this._releaseCount++;\n      if (this._hasReleaseFn) {\n        this._releaseFn(item);\n      }\n      this._list.push(item);\n    } else {\n      this._disposeCount++;\n      if (this._hasDisposeFn) {\n        item = this._disposeFn(item);\n      }\n    }\n  }\n\n  toString(): string {\n    return \" +\" + this._createCount + \" >\" + this._allocateCount + \" <\" + this._releaseCount + \" -\"\n      + this._disposeCount + \" =\" + this._list.length + \"/\" + this._max;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../Settings';\nimport { Pool } from '../util/Pool';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { AABB, AABBValue, RayCastCallback, RayCastInput } from './AABB';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_max = Math.max;\n\n\nexport type DynamicTreeQueryCallback = (nodeId: number) => boolean;\n\n/**\n * A node in the dynamic tree. The client does not interact with this directly.\n */\nexport class TreeNode<T> {\n  id: number;\n  /** Enlarged AABB */\n  aabb: AABB = new AABB();\n  userData: T = null;\n  parent: TreeNode<T> = null;\n  child1: TreeNode<T> = null;\n  child2: TreeNode<T> = null;\n  /** 0: leaf, -1: free node */\n  height: number = -1;\n\n  constructor(id?: number) {\n    this.id = id;\n  }\n\n  /** @internal */\n  toString(): string {\n    return this.id + \": \" + this.userData;\n  }\n\n  isLeaf(): boolean {\n    return this.child1 == null;\n  }\n}\n\n/** @internal */ const poolTreeNode = new Pool<TreeNode<any>>({\n  create(): TreeNode<any> {\n    return new TreeNode();\n  },\n  release(node: TreeNode<any>) {\n    node.userData = null;\n    node.parent = null;\n    node.child1 = null;\n    node.child2 = null;\n    node.height = -1;\n    node.id = undefined;\n  }\n});\n\n/**\n * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A\n * dynamic tree arranges data in a binary tree to accelerate queries such as\n * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we\n * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger\n * than the client object. This allows the client object to move by small\n * amounts without triggering a tree update.\n *\n * Nodes are pooled and relocatable, so we use node indices rather than\n * pointers.\n */\nexport class DynamicTree<T> {\n  m_root: TreeNode<T>;\n  m_lastProxyId: number;\n  m_nodes: {\n    [id: number]: TreeNode<T>\n  };\n\n  constructor() {\n    this.m_root = null;\n    this.m_nodes = {};\n    this.m_lastProxyId = 0;\n  }\n\n  /**\n   * Get proxy user data.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getUserData(id: number): T {\n    const node = this.m_nodes[id];\n    _ASSERT && console.assert(!!node);\n    return node.userData;\n  }\n\n  /**\n   * Get the fat AABB for a node id.\n   *\n   * @return the proxy user data or 0 if the id is invalid.\n   */\n  getFatAABB(id: number): AABB {\n    const node = this.m_nodes[id];\n    _ASSERT && console.assert(!!node);\n    return node.aabb;\n  }\n\n  allocateNode(): TreeNode<T> {\n    const node = poolTreeNode.allocate();\n    node.id = ++this.m_lastProxyId;\n    this.m_nodes[node.id] = node;\n    return node;\n  }\n\n  freeNode(node: TreeNode<T>): void {\n    // tslint:disable-next-line:no-dynamic-delete\n    delete this.m_nodes[node.id];\n    poolTreeNode.release(node);\n  }\n\n  /**\n   * Create a proxy in the tree as a leaf node. We return the index of the node\n   * instead of a pointer so that we can grow the node pool.\n   *\n   * Create a proxy. Provide a tight fitting AABB and a userData pointer.\n   */\n  createProxy(aabb: AABBValue, userData: T): number {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n\n    const node = this.allocateNode();\n\n    node.aabb.set(aabb);\n\n    // Fatten the aabb.\n    AABB.extend(node.aabb, Settings.aabbExtension);\n\n    node.userData = userData;\n    node.height = 0;\n\n    this.insertLeaf(node);\n\n    return node.id;\n  }\n\n  /**\n   * Destroy a proxy. This asserts if the id is invalid.\n   */\n  destroyProxy(id: number): void {\n    const node = this.m_nodes[id];\n\n    _ASSERT && console.assert(!!node);\n    _ASSERT && console.assert(node.isLeaf());\n\n    this.removeLeaf(node);\n    this.freeNode(node);\n  }\n\n  /**\n   * Move a proxy with a swepted AABB. If the proxy has moved outside of its\n   * fattened AABB, then the proxy is removed from the tree and re-inserted.\n   * Otherwise the function returns immediately.\n   *\n   * @param d Displacement\n   *\n   * @return true if the proxy was re-inserted.\n   */\n  moveProxy(id: number, aabb: AABBValue, d: Vec2Value): boolean {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    _ASSERT && console.assert(!d || Vec2.isValid(d));\n\n    const node = this.m_nodes[id];\n\n    _ASSERT && console.assert(!!node);\n    _ASSERT && console.assert(node.isLeaf());\n\n    if (node.aabb.contains(aabb)) {\n      return false;\n    }\n\n    this.removeLeaf(node);\n\n    node.aabb.set(aabb);\n\n    // Extend AABB.\n    aabb = node.aabb;\n    AABB.extend(aabb, Settings.aabbExtension);\n\n    // Predict AABB displacement.\n    // const d = Vec2.mul(Settings.aabbMultiplier, displacement);\n\n    if (d.x < 0.0) {\n      aabb.lowerBound.x += d.x * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.x += d.x * Settings.aabbMultiplier;\n    }\n\n    if (d.y < 0.0) {\n      aabb.lowerBound.y += d.y * Settings.aabbMultiplier;\n    } else {\n      aabb.upperBound.y += d.y * Settings.aabbMultiplier;\n    }\n\n    this.insertLeaf(node);\n\n    return true;\n  }\n\n  insertLeaf(leaf: TreeNode<T>): void {\n    _ASSERT && console.assert(AABB.isValid(leaf.aabb));\n\n    if (this.m_root == null) {\n      this.m_root = leaf;\n      this.m_root.parent = null;\n      return;\n    }\n\n    // Find the best sibling for this node\n    const leafAABB = leaf.aabb;\n    let index = this.m_root;\n    while (!index.isLeaf()) {\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      const area = index.aabb.getPerimeter();\n\n      const combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);\n\n      // Cost of creating a new parent for this node and the new leaf\n      const cost = 2.0 * combinedArea;\n\n      // Minimum cost of pushing the leaf further down the tree\n      const inheritanceCost = 2.0 * (combinedArea - area);\n\n      // Cost of descending into child1\n      const newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);\n      let cost1 = newArea1 + inheritanceCost;\n      if (!child1.isLeaf()) {\n        const oldArea = child1.aabb.getPerimeter();\n        cost1 -= oldArea;\n      }\n\n      // Cost of descending into child2\n      const newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);\n      let cost2 = newArea2 + inheritanceCost;\n      if (!child2.isLeaf()) {\n        const oldArea = child2.aabb.getPerimeter();\n        cost2 -= oldArea;\n      }\n\n      // Descend according to the minimum cost.\n      if (cost < cost1 && cost < cost2) {\n        break;\n      }\n\n      // Descend\n      if (cost1 < cost2) {\n        index = child1;\n      } else {\n        index = child2;\n      }\n    }\n\n    const sibling = index;\n\n    // Create a new parent.\n    const oldParent = sibling.parent;\n    const newParent = this.allocateNode();\n    newParent.parent = oldParent;\n    newParent.userData = null;\n    newParent.aabb.combine(leafAABB, sibling.aabb);\n    newParent.height = sibling.height + 1;\n\n    if (oldParent != null) {\n      // The sibling was not the root.\n      if (oldParent.child1 === sibling) {\n        oldParent.child1 = newParent;\n      } else {\n        oldParent.child2 = newParent;\n      }\n\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n    } else {\n      // The sibling was the root.\n      newParent.child1 = sibling;\n      newParent.child2 = leaf;\n      sibling.parent = newParent;\n      leaf.parent = newParent;\n      this.m_root = newParent;\n    }\n\n    // Walk back up the tree fixing heights and AABBs\n    index = leaf.parent;\n    while (index != null) {\n      index = this.balance(index);\n\n      const child1 = index.child1;\n      const child2 = index.child2;\n\n      _ASSERT && console.assert(child1 != null);\n      _ASSERT && console.assert(child2 != null);\n\n      index.height = 1 + math_max(child1.height, child2.height);\n      index.aabb.combine(child1.aabb, child2.aabb);\n\n      index = index.parent;\n    }\n\n    // validate();\n  }\n\n  removeLeaf(leaf: TreeNode<T>): void {\n    if (leaf === this.m_root) {\n      this.m_root = null;\n      return;\n    }\n\n    const parent = leaf.parent;\n    const grandParent = parent.parent;\n    let sibling;\n    if (parent.child1 === leaf) {\n      sibling = parent.child2;\n    } else {\n      sibling = parent.child1;\n    }\n\n    if (grandParent != null) {\n      // Destroy parent and connect sibling to grandParent.\n      if (grandParent.child1 === parent) {\n        grandParent.child1 = sibling;\n      } else {\n        grandParent.child2 = sibling;\n      }\n      sibling.parent = grandParent;\n      this.freeNode(parent);\n\n      // Adjust ancestor bounds.\n      let index = grandParent;\n      while (index != null) {\n        index = this.balance(index);\n\n        const child1 = index.child1;\n        const child2 = index.child2;\n\n        index.aabb.combine(child1.aabb, child2.aabb);\n        index.height = 1 + math_max(child1.height, child2.height);\n\n        index = index.parent;\n      }\n    } else {\n      this.m_root = sibling;\n      sibling.parent = null;\n      this.freeNode(parent);\n    }\n\n    // validate();\n  }\n\n  /**\n   * Perform a left or right rotation if node A is imbalanced. Returns the new\n   * root index.\n   */\n  balance(iA: TreeNode<T>): TreeNode<T> {\n    _ASSERT && console.assert(iA != null);\n\n    const A = iA;\n    if (A.isLeaf() || A.height < 2) {\n      return iA;\n    }\n\n    const B = A.child1;\n    const C = A.child2;\n\n    const balance = C.height - B.height;\n\n    // Rotate C up\n    if (balance > 1) {\n      const F = C.child1;\n      const G = C.child2;\n\n      // Swap A and C\n      C.child1 = A;\n      C.parent = A.parent;\n      A.parent = C;\n\n      // A's old parent should point to C\n      if (C.parent != null) {\n        if (C.parent.child1 === iA) {\n          C.parent.child1 = C;\n        } else {\n          C.parent.child2 = C;\n        }\n      } else {\n        this.m_root = C;\n      }\n\n      // Rotate\n      if (F.height > G.height) {\n        C.child2 = F;\n        A.child2 = G;\n        G.parent = A;\n        A.aabb.combine(B.aabb, G.aabb);\n        C.aabb.combine(A.aabb, F.aabb);\n\n        A.height = 1 + math_max(B.height, G.height);\n        C.height = 1 + math_max(A.height, F.height);\n      } else {\n        C.child2 = G;\n        A.child2 = F;\n        F.parent = A;\n        A.aabb.combine(B.aabb, F.aabb);\n        C.aabb.combine(A.aabb, G.aabb);\n\n        A.height = 1 + math_max(B.height, F.height);\n        C.height = 1 + math_max(A.height, G.height);\n      }\n\n      return C;\n    }\n\n    // Rotate B up\n    if (balance < -1) {\n      const D = B.child1;\n      const E = B.child2;\n\n      // Swap A and B\n      B.child1 = A;\n      B.parent = A.parent;\n      A.parent = B;\n\n      // A's old parent should point to B\n      if (B.parent != null) {\n        if (B.parent.child1 === A) {\n          B.parent.child1 = B;\n        } else {\n          B.parent.child2 = B;\n        }\n      } else {\n        this.m_root = B;\n      }\n\n      // Rotate\n      if (D.height > E.height) {\n        B.child2 = D;\n        A.child1 = E;\n        E.parent = A;\n        A.aabb.combine(C.aabb, E.aabb);\n        B.aabb.combine(A.aabb, D.aabb);\n\n        A.height = 1 + math_max(C.height, E.height);\n        B.height = 1 + math_max(A.height, D.height);\n      } else {\n        B.child2 = E;\n        A.child1 = D;\n        D.parent = A;\n        A.aabb.combine(C.aabb, D.aabb);\n        B.aabb.combine(A.aabb, E.aabb);\n\n        A.height = 1 + math_max(C.height, D.height);\n        B.height = 1 + math_max(A.height, E.height);\n      }\n\n      return B;\n    }\n\n    return A;\n  }\n\n  /**\n   * Compute the height of the binary tree in O(N) time. Should not be called\n   * often.\n   */\n  getHeight(): number {\n    if (this.m_root == null) {\n      return 0;\n    }\n\n    return this.m_root.height;\n  }\n\n  /**\n   * Get the ratio of the sum of the node areas to the root area.\n   */\n  getAreaRatio(): number {\n    if (this.m_root == null) {\n      return 0.0;\n    }\n\n    const root = this.m_root;\n    const rootArea = root.aabb.getPerimeter();\n\n    let totalArea = 0.0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // Free node in pool\n        continue;\n      }\n\n      totalArea += node.aabb.getPerimeter();\n    }\n\n    this.iteratorPool.release(it);\n\n    return totalArea / rootArea;\n  }\n\n  /**\n   * Compute the height of a sub-tree.\n   */\n  computeHeight(id?: number): number {\n    let node;\n    if (typeof id !== 'undefined') {\n      node = this.m_nodes[id];\n    } else {\n      node = this.m_root;\n    }\n\n    // _ASSERT && console.assert(0 <= id && id < this.m_nodeCapacity);\n\n    if (node.isLeaf()) {\n      return 0;\n    }\n\n    const height1 = this.computeHeight(node.child1.id);\n    const height2 = this.computeHeight(node.child2.id);\n    return 1 + math_max(height1, height2);\n  }\n\n  validateStructure(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    if (node === this.m_root) {\n      _ASSERT && console.assert(node.parent == null);\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && console.assert(child1 == null);\n      _ASSERT && console.assert(child2 == null);\n      _ASSERT && console.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    _ASSERT && console.assert(child1.parent === node);\n    _ASSERT && console.assert(child2.parent === node);\n\n    this.validateStructure(child1);\n    this.validateStructure(child2);\n  }\n\n  validateMetrics(node: TreeNode<T>): void {\n    if (node == null) {\n      return;\n    }\n\n    const child1 = node.child1;\n    const child2 = node.child2;\n\n    if (node.isLeaf()) {\n      _ASSERT && console.assert(child1 == null);\n      _ASSERT && console.assert(child2 == null);\n      _ASSERT && console.assert(node.height === 0);\n      return;\n    }\n\n    // _ASSERT && console.assert(0 <= child1 && child1 < this.m_nodeCapacity);\n    // _ASSERT && console.assert(0 <= child2 && child2 < this.m_nodeCapacity);\n\n    const height1 = child1.height;\n    const height2 = child2.height;\n    const height = 1 + math_max(height1, height2);\n    _ASSERT && console.assert(node.height === height);\n\n    const aabb = new AABB();\n    aabb.combine(child1.aabb, child2.aabb);\n\n    _ASSERT && console.assert(AABB.areEqual(aabb, node.aabb));\n\n    this.validateMetrics(child1);\n    this.validateMetrics(child2);\n  }\n\n  /**\n   * Validate this tree. For testing.\n   */\n  validate(): void {\n    if (!_ASSERT) return;\n    this.validateStructure(this.m_root);\n    this.validateMetrics(this.m_root);\n\n    console.assert(this.getHeight() === this.computeHeight());\n  }\n\n  /**\n   * Get the maximum balance of an node in the tree. The balance is the difference\n   * in height of the two children of a node.\n   */\n  getMaxBalance(): number {\n    let maxBalance = 0;\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height <= 1) {\n        continue;\n      }\n\n      _ASSERT && console.assert(!node.isLeaf());\n\n      const balance = math_abs(node.child2.height - node.child1.height);\n      maxBalance = math_max(maxBalance, balance);\n    }\n    this.iteratorPool.release(it);\n\n    return maxBalance;\n  }\n\n  /**\n   * Build an optimal tree. Very expensive. For testing.\n   */\n  rebuildBottomUp(): void {\n    const nodes = [];\n    let count = 0;\n\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      if (node.height < 0) {\n        // free node in pool\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        node.parent = null;\n        nodes[count] = node;\n        ++count;\n      } else {\n        this.freeNode(node);\n      }\n    }\n    this.iteratorPool.release(it);\n\n    while (count > 1) {\n      let minCost = Infinity;\n      let iMin = -1;\n      let jMin = -1;\n      for (let i = 0; i < count; ++i) {\n        const aabbi = nodes[i].aabb;\n        for (let j = i + 1; j < count; ++j) {\n          const aabbj = nodes[j].aabb;\n          const cost = AABB.combinedPerimeter(aabbi, aabbj);\n          if (cost < minCost) {\n            iMin = i;\n            jMin = j;\n            minCost = cost;\n          }\n        }\n      }\n\n      const child1 = nodes[iMin];\n      const child2 = nodes[jMin];\n\n      const parent = this.allocateNode();\n      parent.child1 = child1;\n      parent.child2 = child2;\n      parent.height = 1 + math_max(child1.height, child2.height);\n      parent.aabb.combine(child1.aabb, child2.aabb);\n      parent.parent = null;\n\n      child1.parent = parent;\n      child2.parent = parent;\n\n      nodes[jMin] = nodes[count - 1];\n      nodes[iMin] = parent;\n      --count;\n    }\n\n    this.m_root = nodes[0];\n\n    _ASSERT && this.validate();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    // Build array of leaves. Free the rest.\n    let node;\n    const it = this.iteratorPool.allocate().preorder(this.m_root);\n    while (node = it.next()) {\n      const aabb = node.aabb;\n      aabb.lowerBound.x -= newOrigin.x;\n      aabb.lowerBound.y -= newOrigin.y;\n      aabb.upperBound.x -= newOrigin.x;\n      aabb.upperBound.y -= newOrigin.y;\n    }\n    this.iteratorPool.release(it);\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query(aabb: AABBValue, queryCallback: DynamicTreeQueryCallback): void {\n    _ASSERT && console.assert(typeof queryCallback === 'function');\n    const stack = this.stackPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, aabb)) {\n        if (node.isLeaf()) {\n          const proceed = queryCallback(node.id);\n          if (proceed === false) {\n            return;\n          }\n        } else {\n          stack.push(node.child1);\n          stack.push(node.child2);\n        }\n      }\n    }\n\n    this.stackPool.release(stack);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    // TODO: GC\n    _ASSERT && console.assert(typeof rayCastCallback === 'function');\n    const p1 = input.p1;\n    const p2 = input.p2;\n    const r = Vec2.sub(p2, p1);\n    _ASSERT && console.assert(r.lengthSquared() > 0.0);\n    r.normalize();\n\n    // v is perpendicular to the segment.\n    const v = Vec2.crossNumVec2(1.0, r);\n    const abs_v = Vec2.abs(v);\n\n    // Separating axis for segment (Gino, p80).\n    // |dot(v, p1 - c)| > dot(|v|, h)\n\n    let maxFraction = input.maxFraction;\n\n    // Build a bounding box for the segment.\n    const segmentAABB = new AABB();\n    let t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n    segmentAABB.combinePoints(p1, t);\n\n    const stack = this.stackPool.allocate();\n    const subInput = this.inputPool.allocate();\n\n    stack.push(this.m_root);\n    while (stack.length > 0) {\n      const node = stack.pop();\n      if (node == null) {\n        continue;\n      }\n\n      if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n        continue;\n      }\n\n      // Separating axis for segment (Gino, p80).\n      // |dot(v, p1 - c)| > dot(|v|, h)\n      const c = node.aabb.getCenter();\n      const h = node.aabb.getExtents();\n      const separation = math_abs(Vec2.dot(v, Vec2.sub(p1, c))) - Vec2.dot(abs_v, h);\n      if (separation > 0.0) {\n        continue;\n      }\n\n      if (node.isLeaf()) {\n        subInput.p1 = Vec2.clone(input.p1);\n        subInput.p2 = Vec2.clone(input.p2);\n        subInput.maxFraction = maxFraction;\n\n        const value = rayCastCallback(subInput, node.id);\n\n        if (value === 0.0) {\n          // The client has terminated the ray cast.\n          return;\n        }\n\n        if (value > 0.0) {\n          // update segment bounding box.\n          maxFraction = value;\n          t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);\n          segmentAABB.combinePoints(p1, t);\n        }\n      } else {\n        stack.push(node.child1);\n        stack.push(node.child2);\n      }\n    }\n    this.stackPool.release(stack);\n    this.inputPool.release(subInput);\n  }\n\n  private inputPool: Pool<RayCastInput> = new Pool<RayCastInput>({\n    create(): RayCastInput {\n      // tslint:disable-next-line:no-object-literal-type-assertion\n      return {} as RayCastInput;\n    },\n    release(stack: RayCastInput): void {\n    }\n  });\n\n  private stackPool: Pool<Array<TreeNode<T>>> = new Pool<Array<TreeNode<T>>>({\n    create(): Array<TreeNode<T>> {\n      return [];\n    },\n    release(stack: Array<TreeNode<T>>): void {\n      stack.length = 0;\n    }\n  });\n\n  private iteratorPool: Pool<Iterator<T>> = new Pool<Iterator<T>>({\n    create(): Iterator<T> {\n      return new Iterator();\n    },\n    release(iterator: Iterator<T>): void {\n      iterator.close();\n    }\n  });\n\n}\n\n/** @internal */\nclass Iterator<T> {\n  parents: Array<TreeNode<T>> = [];\n  states: number[] = [];\n  preorder(root: TreeNode<T>): Iterator<T> {\n    this.parents.length = 0;\n    this.parents.push(root);\n    this.states.length = 0;\n    this.states.push(0);\n    return this;\n  }\n  next(): TreeNode<T> {\n    while (this.parents.length > 0) {\n      const i = this.parents.length - 1;\n      const node = this.parents[i];\n      if (this.states[i] === 0) {\n        this.states[i] = 1;\n        return node;\n      }\n      if (this.states[i] === 1) {\n        this.states[i] = 2;\n        if (node.child1) {\n          this.parents.push(node.child1);\n          this.states.push(1);\n          return node.child1;\n        }\n      }\n      if (this.states[i] === 2) {\n        this.states[i] = 3;\n        if (node.child2) {\n          this.parents.push(node.child2);\n          this.states.push(1);\n          return node.child2;\n        }\n      }\n      this.parents.pop();\n      this.states.pop();\n    }\n  }\n  close(): void {\n    this.parents.length = 0;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2Value } from '../common/Vec2';\nimport { AABB, AABBValue, RayCastCallback, RayCastInput } from './AABB';\nimport { DynamicTree, DynamicTreeQueryCallback } from './DynamicTree';\nimport { FixtureProxy } from \"../dynamics/Fixture\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_max = Math.max;\n/** @internal */ const math_min = Math.min;\n\n\n/**\n * The broad-phase wraps and extends a dynamic-tree to keep track of moved\n * objects and query them on update.\n */\nexport class BroadPhase {\n  m_tree: DynamicTree<FixtureProxy> = new DynamicTree<FixtureProxy>();\n  m_moveBuffer: number[] = [];\n\n  m_callback: (userDataA: any, userDataB: any) => void;\n  m_queryProxyId: number;\n\n  /**\n   * Get user data from a proxy. Returns null if the id is invalid.\n   */\n  getUserData(proxyId: number): FixtureProxy {\n    return this.m_tree.getUserData(proxyId);\n  }\n\n  /**\n   * Test overlap of fat AABBs.\n   */\n  testOverlap(proxyIdA: number, proxyIdB: number): boolean {\n    const aabbA = this.m_tree.getFatAABB(proxyIdA);\n    const aabbB = this.m_tree.getFatAABB(proxyIdB);\n    return AABB.testOverlap(aabbA, aabbB);\n  }\n\n  /**\n   * Get the fat AABB for a proxy.\n   */\n  getFatAABB(proxyId: number): AABB {\n    return this.m_tree.getFatAABB(proxyId);\n  }\n\n  /**\n   * Get the number of proxies.\n   */\n  getProxyCount(): number {\n    return this.m_moveBuffer.length;\n  }\n\n  /**\n   * Get the height of the embedded tree.\n   */\n  getTreeHeight(): number {\n    return this.m_tree.getHeight();\n  }\n\n  /**\n   * Get the balance (integer) of the embedded tree.\n   */\n  getTreeBalance(): number {\n    return this.m_tree.getMaxBalance();\n  }\n\n  /**\n   * Get the quality metric of the embedded tree.\n   */\n  getTreeQuality(): number {\n    return this.m_tree.getAreaRatio();\n  }\n\n  /**\n   * Query an AABB for overlapping proxies. The callback class is called for each\n   * proxy that overlaps the supplied AABB.\n   */\n  query = (aabb: AABBValue, queryCallback: DynamicTreeQueryCallback): void => {\n    this.m_tree.query(aabb, queryCallback);\n  }\n\n  /**\n   * Ray-cast against the proxies in the tree. This relies on the callback to\n   * perform a exact ray-cast in the case were the proxy contains a shape. The\n   * callback also performs the any collision filtering. This has performance\n   * roughly equal to k * log(n), where k is the number of collisions and n is the\n   * number of proxies in the tree.\n   *\n   * @param input The ray-cast input data. The ray extends from `p1` to `p1 + maxFraction * (p2 - p1)`.\n   * @param rayCastCallback A function that is called for each proxy that is hit by the ray.\n   */\n  rayCast(input: RayCastInput, rayCastCallback: RayCastCallback): void {\n    this.m_tree.rayCast(input, rayCastCallback);\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_tree.shiftOrigin(newOrigin);\n  }\n\n  /**\n   * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs\n   * is called.\n   */\n  createProxy(aabb: AABBValue, userData: FixtureProxy): number {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    const proxyId = this.m_tree.createProxy(aabb, userData);\n    this.bufferMove(proxyId);\n    return proxyId;\n  }\n\n  /**\n   * Destroy a proxy. It is up to the client to remove any pairs.\n   */\n  destroyProxy(proxyId: number): void {\n    this.unbufferMove(proxyId);\n    this.m_tree.destroyProxy(proxyId);\n  }\n\n  /**\n   * Call moveProxy as many times as you like, then when you are done call\n   * UpdatePairs to finalized the proxy pairs (for your time step).\n   */\n  moveProxy(proxyId: number, aabb: AABB, displacement: Vec2Value): void {\n    _ASSERT && console.assert(AABB.isValid(aabb));\n    const changed = this.m_tree.moveProxy(proxyId, aabb, displacement);\n    if (changed) {\n      this.bufferMove(proxyId);\n    }\n  }\n\n  /**\n   * Call to trigger a re-processing of it's pairs on the next call to\n   * UpdatePairs.\n   */\n  touchProxy(proxyId: number): void {\n    this.bufferMove(proxyId);\n  }\n\n  bufferMove(proxyId: number): void {\n    this.m_moveBuffer.push(proxyId);\n  }\n\n  unbufferMove(proxyId: number): void {\n    for (let i = 0; i < this.m_moveBuffer.length; ++i) {\n      if (this.m_moveBuffer[i] === proxyId) {\n        this.m_moveBuffer[i] = null;\n      }\n    }\n  }\n\n  /**\n   * Update the pairs. This results in pair callbacks. This can only add pairs.\n   */\n  updatePairs(addPairCallback: (userDataA: FixtureProxy, userDataB: FixtureProxy) => void): void {\n    _ASSERT && console.assert(typeof addPairCallback === 'function');\n    this.m_callback = addPairCallback;\n\n    // Perform tree queries for all moving proxies.\n    while (this.m_moveBuffer.length > 0) {\n      this.m_queryProxyId = this.m_moveBuffer.pop();\n      if (this.m_queryProxyId === null) {\n        continue;\n      }\n\n      // We have to query the tree with the fat AABB so that\n      // we don't fail to create a pair that may touch later.\n      const fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n\n      // Query tree, create pairs and add them pair buffer.\n      this.m_tree.query(fatAABB, this.queryCallback);\n    }\n\n    // Try to keep the tree balanced.\n    // this.m_tree.rebalance(4);\n  }\n\n  queryCallback = (proxyId: number): boolean => {\n    // A proxy cannot form a pair with itself.\n    if (proxyId === this.m_queryProxyId) {\n      return true;\n    }\n\n    const proxyIdA = math_min(proxyId, this.m_queryProxyId);\n    const proxyIdB = math_max(proxyId, this.m_queryProxyId);\n\n    // TODO: Skip any duplicate pairs.\n\n    const userDataA = this.m_tree.getUserData(proxyIdA);\n    const userDataB = this.m_tree.getUserData(proxyIdB);\n\n    // Send the pairs back to the client.\n    this.m_callback(userDataA, userDataB);\n\n    return true;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2023 Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n/** @internal */ const math_sin = Math.sin;\n/** @internal */ const math_cos = Math.cos;\n/** @internal */ const math_sqrt = Math.sqrt;\n\n\nimport { RotValue } from \"./Rot\";\nimport { TransformValue } from \"./Transform\";\nimport { Vec2Value } from \"./Vec2\";\nimport { Vec3Value } from \"./Vec3\";\n\nexport function vec2(x: number, y: number): Vec2Value {\n  return { x, y };\n}\n\nexport function vec3(x: number, y: number, z: number): Vec3Value {\n  return { x, y, z };\n}\n\nexport function rotation(angle: number): RotValue {\n  return { s: math_sin(angle), c: math_cos(angle) };\n}\n\nexport function setVec2(out: Vec2Value, x: number, y: number): Vec2Value {\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function copyVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = w.x;\n  out.y = w.y;\n  return out;\n}\n\nexport function zeroVec2(out: Vec2Value): Vec2Value {\n  out.x = 0;\n  out.y = 0;\n  return out;\n}\n\nexport function negVec2(out: Vec2Value): Vec2Value {\n  out.x = -out.x;\n  out.y = -out.y;\n  return out;\n}\n\nexport function addVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x += w.x;\n  out.y += w.y;\n  return out;\n}\n\nexport function sumVec2(out: Vec2Value, v: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = v.x + w.x;\n  out.y = v.x + w.y;\n  return out;\n}\n\nexport function subVec2(out: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x -= w.x;\n  out.y -= w.y;\n  return out;\n}\n\nexport function diffVec2(out: Vec2Value, v: Vec2Value, w: Vec2Value): Vec2Value {\n  out.x = v.x - w.x;\n  out.y = v.y - w.y;\n  return out;\n}\n\nexport function scaleVec2(out: Vec2Value, m: number): Vec2Value {\n  out.x *= m;\n  out.y *= m;\n  return out;\n}\n\nexport function setMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x = m * w.x;\n  out.y = m * w.y;\n  return out;\n}\n\nexport function addMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x += m * w.x;\n  out.y += m * w.y;\n  return out;\n}\n\nexport function subMulVec2(out: Vec2Value, m: number, w: Vec2Value): Vec2Value {\n  out.x -= m * w.x;\n  out.y -= m * w.y;\n  return out;\n}\n\nexport function combineVec2(out: Vec2Value, am: number, a: Vec2Value, bm: number, b: Vec2Value): Vec2Value {\n  out.x = am * a.x + bm * b.x;\n  out.y = am * a.y + bm * b.y;\n  return out;\n}\n\nexport function normalizeVec2Length(out: Vec2Value): number {\n  const length = math_sqrt(out.x * out.x + out.y * out.y);\n  if (length !== 0) {\n    const invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return length;\n}\n\nexport function normalizeVec2(out: Vec2Value): Vec2Value {\n  const length = math_sqrt(out.x * out.x + out.y * out.y);\n  if (length > 0) {\n    const invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return out;\n}\n\nexport function crossVec2Num(out: Vec2Value, v: Vec2Value, w: number): Vec2Value {\n  const x = w * v.y;\n  const y = -w * v.x;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function crossNumVec2(out: Vec2Value, w: number, v: Vec2Value): Vec2Value {\n  const x = -w * v.y;\n  const y = w * v.x;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function crossVec2Vec2(a: Vec2Value, b: Vec2Value): number {\n  return a.x * b.y - a.y * b.x;\n}\n\nexport function dotVec2(a: Vec2Value, b: Vec2Value): number {\n  return a.x * b.x + a.y * b.y;\n}\n\nexport function lengthVec2(a: Vec2Value): number {\n  return math_sqrt(a.x * a.x + a.y * a.y);\n}\n\nexport function lengthSqrVec2(a: Vec2Value): number {\n  return a.x * a.x + a.y * a.y;\n}\n\nexport function distVec2(a: Vec2Value, b: Vec2Value): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return math_sqrt(dx * dx + dy * dy);\n}\n\nexport function distSqrVec2(a: Vec2Value, b: Vec2Value): number {\n  const dx = a.x - b.x;\n  const dy = a.y - b.y;\n  return dx * dx + dy * dy;\n}\n\nexport function dotVec3(v: Vec3Value, w: Vec3Value): number {\n  return v.x * w.x + v.y * w.y + v.z * w.z;\n}\n\nexport function setRotAngle(out: RotValue, a: number): RotValue {\n  out.c = math_cos(a);\n  out.s = math_sin(a);\n  return out;\n}\n\nexport function rotVec2(out: Vec2Value, q: RotValue, v: Vec2Value): Vec2Value {\n  out.x = q.c * v.x - q.s * v.y;\n  out.y = q.s * v.x + q.c * v.y;\n  return out;\n}\n\nexport function invRotVec2(out: Vec2Value, q: RotValue, v: Vec2Value): Vec2Value {\n  const x = q.c * v.x + q.s * v.y;\n  const y = -q.s * v.x + q.c * v.y;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function rerotVec2(out: Vec2Value, before: RotValue, after: RotValue, v: Vec2Value): Vec2Value {\n  const x0 = before.c * v.x + before.s * v.y;\n  const y0 = -before.s * v.x + before.c * v.y;\n  const x = after.c * x0 - after.s * y0;\n  const y = after.s * x0 + after.c * y0;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function transform(x: number, y: number, a: number): TransformValue {\n  return { p: vec2(x, y), q: rotation(a) };\n}\n\nexport function copyTransform(out: TransformValue, transform: TransformValue): TransformValue {\n  out.p.x = transform.p.x;\n  out.p.y = transform.p.y;\n  out.q.s = transform.q.s;\n  out.q.c = transform.q.c;\n  return out;\n}\n\nexport function transformVec2(out: Vec2Value, xf: TransformValue, v: Vec2Value): Vec2Value {\n  const x = xf.q.c * v.x - xf.q.s * v.y + xf.p.x;\n  const y = xf.q.s * v.x + xf.q.c * v.y + xf.p.y;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function invTransformVec2(out: Vec2Value, xf: TransformValue, v: Vec2Value): Vec2Value {\n  const px = v.x - xf.p.x;\n  const py = v.y - xf.p.y;\n  const x = (xf.q.c * px + xf.q.s * py);\n  const y = (-xf.q.s * px + xf.q.c * py);\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function retransformVec2(out: Vec2Value, from: TransformValue, to: TransformValue, v: Vec2Value): Vec2Value {\n  const x0 = from.q.c * v.x - from.q.s * v.y + from.p.x;\n  const y0 = from.q.s * v.x + from.q.c * v.y + from.p.y;\n  const px = x0 - to.p.x;\n  const py = y0 - to.p.y;\n  const x = to.q.c * px + to.q.s * py;\n  const y = -to.q.s * px + to.q.c * py;\n  out.x = x;\n  out.y = y;\n  return out;\n}\n\nexport function invTransformTransform(out: TransformValue, a: TransformValue, b: TransformValue): TransformValue {\n  const c = a.q.c * b.q.c + a.q.s * b.q.s;\n  const s = a.q.c * b.q.s - a.q.s * b.q.c;\n  const x = a.q.c * (b.p.x - a.p.x) + a.q.s * (b.p.y - a.p.y);\n  const y = -a.q.s * (b.p.x - a.p.x) + a.q.c * (b.p.y - a.p.y);\n  out.q.c = c;\n  out.q.s = s;\n  out.p.x = x;\n  out.p.y = y;\n  return out;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_sin = Math.sin;\n/** @internal */ const math_cos = Math.cos;\n/** @internal */ const math_atan2 = Math.atan2;\n\nexport interface RotValue {\n  /** sin(angle) */\n  s: number;\n  /** cos(angle) */\n  c: number;\n}\n\nexport class Rot {\n  /** sin(angle) */\n  s: number;\n  /** cos(angle) */\n  c: number;\n\n  /** Initialize from an angle in radians. */\n  constructor(angle?: number | RotValue) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Rot)) {\n      return new Rot(angle);\n    }\n    if (typeof angle === 'number') {\n      this.setAngle(angle);\n    } else if (typeof angle === 'object') {\n      this.setRot(angle);\n    } else {\n      this.setIdentity();\n    }\n  }\n\n  /** @internal */\n  static neo(angle: number): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.setAngle(angle);\n    return obj;\n  }\n\n  static clone(rot: RotValue): Rot {\n    _ASSERT && Rot.assert(rot);\n    const obj = Object.create(Rot.prototype);\n    obj.s = rot.s;\n    obj.c = rot.c;\n    return obj;\n  }\n\n  static identity(): Rot {\n    const obj = Object.create(Rot.prototype);\n    obj.s = 0.0;\n    obj.c = 1.0;\n    return obj;\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Number.isFinite(obj.s) && Number.isFinite(obj.c);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Rot.isValid(o), 'Invalid Rot!', o);\n  }\n\n  /** Set to the identity rotation. */\n  setIdentity(): void {\n    this.s = 0.0;\n    this.c = 1.0;\n  }\n\n  set(angle: number | RotValue): void {\n    if (typeof angle === 'object') {\n      _ASSERT && Rot.assert(angle);\n      this.s = angle.s;\n      this.c = angle.c;\n\n    } else {\n      _ASSERT && console.assert(Number.isFinite(angle));\n      // TODO_ERIN optimize\n      this.s = math_sin(angle);\n      this.c = math_cos(angle);\n    }\n  }\n\n  setRot(angle: RotValue): void {\n    _ASSERT && Rot.assert(angle);\n    this.s = angle.s;\n    this.c = angle.c;\n  }\n\n  /** Set using an angle in radians. */\n  setAngle(angle: number): void {\n    _ASSERT && console.assert(Number.isFinite(angle));\n    // TODO_ERIN optimize\n    this.s = math_sin(angle);\n    this.c = math_cos(angle);\n  }\n\n  /** Get the angle in radians. */\n  getAngle(): number {\n    return math_atan2(this.s, this.c);\n  }\n\n  /** Get the x-axis. */\n  getXAxis(): Vec2 {\n    return Vec2.neo(this.c, this.s);\n  }\n\n  /** Get the y-axis. */\n  getYAxis(): Vec2 {\n    return Vec2.neo(-this.s, this.c);\n  }\n\n  /** Multiply two rotations: q * r */\n  static mul(rot: RotValue, m: RotValue): Rot;\n  /** Rotate a vector */\n  static mul(rot: RotValue, m: Vec2Value): Vec2;\n  static mul(rot, m) {\n    _ASSERT && Rot.assert(rot);\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n      // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n      // s = qs * rc + qc * rs\n      // c = qc * rc - qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.s * m.c + rot.c * m.s;\n      qr.c = rot.c * m.c - rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Multiply two rotations: q * r */\n  static mulRot(rot: RotValue, m: RotValue): Rot {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Rot.assert(m);\n    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]\n    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]\n    // s = qs * rc + qc * rs\n    // c = qc * rc - qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.s * m.c + rot.c * m.s;\n    qr.c = rot.c * m.c - rot.s * m.s;\n    return qr;\n  }\n\n  /** Rotate a vector */\n  static mulVec2(rot: RotValue, m: Vec2Value): Vec2 {\n    _ASSERT && Rot.assert(rot);\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n  }\n\n  static mulSub(rot: RotValue, v: Vec2Value, w: Vec2Value): Vec2 {\n    const x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);\n    const y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);\n    return Vec2.neo(x, y);\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulT(rot: RotValue, m: RotValue): Rot;\n  /** Inverse rotate a vector */\n  static mulT(rot: RotValue, m: Vec2Value): Vec2;\n  static mulT(rot, m) {\n    if ('c' in m && 's' in m) {\n      _ASSERT && Rot.assert(m);\n      // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n      // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n      // s = qc * rs - qs * rc\n      // c = qc * rc + qs * rs\n      const qr = Rot.identity();\n      qr.s = rot.c * m.s - rot.s * m.c;\n      qr.c = rot.c * m.c + rot.s * m.s;\n      return qr;\n\n    } else if ('x' in m && 'y' in m) {\n      _ASSERT && Vec2.assert(m);\n      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n    }\n  }\n\n  /** Transpose multiply two rotations: qT * r */\n  static mulTRot(rot: RotValue, m: RotValue): Rot {\n    _ASSERT && Rot.assert(m);\n    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]\n    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]\n    // s = qc * rs - qs * rc\n    // c = qc * rc + qs * rs\n    const qr = Rot.identity();\n    qr.s = rot.c * m.s - rot.s * m.c;\n    qr.c = rot.c * m.c + rot.s * m.s;\n    return qr;\n  }\n\n  /** Inverse rotate a vector */\n  static mulTVec2(rot: RotValue, m: Vec2Value): Vec2 {\n    _ASSERT && Vec2.assert(m);\n    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from './Matrix';\nimport { mod } from './Math';\nimport { Vec2, Vec2Value } from './Vec2';\nimport { TransformValue } from './Transform';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_atan2 = Math.atan2;\n/** @internal */ const math_PI = Math.PI;\n\n\n/** @internal */ const temp = matrix.vec2(0, 0);\n\n/**\n * This describes the motion of a body/shape for TOI computation. Shapes are\n * defined with respect to the body origin, which may not coincide with the\n * center of mass. However, to support dynamics we must interpolate the center\n * of mass position.\n */\nexport class Sweep {\n  /** Local center of mass position */\n  localCenter = Vec2.zero();\n\n  /** World center position */\n  c = Vec2.zero();\n\n  /** World angle */\n  a = 0;\n\n  /** Fraction of the current time step in the range [0,1], c0 and a0 are c and a at alpha0. */\n  alpha0 = 0;\n\n  c0 = Vec2.zero();\n  a0 = 0;\n\n  /** @internal */\n  recycle() {\n    matrix.zeroVec2(this.localCenter)\n    matrix.zeroVec2(this.c)\n    this.a = 0;\n    this.alpha0 = 0;\n    matrix.zeroVec2(this.c0)\n    this.a0 = 0;\n  }\n\n  setTransform(xf: TransformValue): void {\n    matrix.transformVec2(temp, xf, this.localCenter);\n    matrix.copyVec2(this.c, temp);\n    matrix.copyVec2(this.c0, temp);\n\n    this.a = this.a0 = math_atan2(xf.q.s, xf.q.c);\n  }\n\n  setLocalCenter(localCenter: Vec2Value, xf: TransformValue): void {\n    matrix.copyVec2(this.localCenter, localCenter);\n\n    matrix.transformVec2(temp, xf, this.localCenter);\n    matrix.copyVec2(this.c, temp);\n    matrix.copyVec2(this.c0, temp);\n  }\n\n  /**\n   * Get the interpolated transform at a specific time.\n   *\n   * @param xf\n   * @param beta A factor in [0,1], where 0 indicates alpha0\n   */\n  getTransform(xf: TransformValue, beta: number = 0): void {\n    matrix.setRotAngle(xf.q, (1.0 - beta) * this.a0 + beta * this.a);\n    matrix.combineVec2(xf.p, (1.0 - beta), this.c0, beta, this.c);\n\n    // shift to origin\n    matrix.subVec2(xf.p, matrix.rotVec2(temp, xf.q, this.localCenter));\n  }\n\n  /**\n   * Advance the sweep forward, yielding a new initial state.\n   *\n   * @param alpha The new initial time\n   */\n  advance(alpha: number): void {\n    _ASSERT && console.assert(this.alpha0 < 1.0);\n    const beta = (alpha - this.alpha0) / (1.0 - this.alpha0);\n    matrix.combineVec2(this.c0, beta, this.c, 1 - beta, this.c0);\n    this.a0 = beta * this.a + (1 - beta) * this.a0;\n    this.alpha0 = alpha;\n  }\n\n  forward(): void {\n    this.a0 = this.a;\n    matrix.copyVec2(this.c0, this.c);\n  }\n\n  /**\n   * normalize the angles in radians to be between -pi and pi.\n   */\n  normalize(): void {\n    const a0 = mod(this.a0, -math_PI, +math_PI);\n    this.a -= this.a0 - a0;\n    this.a0 = a0;\n  }\n\n  set(that: Sweep): void {\n    matrix.copyVec2(this.localCenter, that.localCenter);\n    matrix.copyVec2(this.c, that.c);\n    this.a = that.a;\n    this.alpha0 = that.alpha0;\n    matrix.copyVec2(this.c0, that.c0);\n    this.a0 = that.a0;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { Rot, RotValue } from './Rot';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport type TransformValue = {\n  p: Vec2Value;\n  q: RotValue;\n};\n\n/**\n * A transform contains translation and rotation. It is used to represent the\n * position and orientation of rigid frames. Initialize using a position vector\n * and a rotation.\n */\nexport class Transform {\n  /** position */\n  p: Vec2;\n\n  /** rotation */\n  q: Rot;\n\n  constructor(position?: Vec2Value, rotation?: number) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Transform)) {\n      return new Transform(position, rotation);\n    }\n    this.p = Vec2.zero();\n    this.q = Rot.identity();\n    if (typeof position !== 'undefined') {\n      this.p.setVec2(position);\n    }\n    if (typeof rotation !== 'undefined') {\n      this.q.setAngle(rotation);\n    }\n  }\n\n  static clone(xf: Transform): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(xf.p);\n    obj.q = Rot.clone(xf.q);\n    return obj;\n  }\n\n  /** @internal */\n  static neo(position: Vec2Value, rotation: Rot): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.clone(position);\n    obj.q = Rot.clone(rotation);\n    return obj;\n  }\n\n  static identity(): Transform {\n    const obj = Object.create(Transform.prototype);\n    obj.p = Vec2.zero();\n    obj.q = Rot.identity();\n    return obj;\n  }\n\n  /** Set this to the identity transform */\n  setIdentity(): void {\n    this.p.setZero();\n    this.q.setIdentity();\n  }\n\n  /** Set position and angle */\n  set(position: Vec2Value, rotation: number): void;\n  /** Copy from another transform */\n  set(xf: TransformValue): void;\n  set(a: any, b?: any) {\n    if (typeof b === 'undefined') {\n      this.p.set(a.p);\n      this.q.set(a.q);\n    } else {\n      this.p.set(a);\n      this.q.set(b);\n    }\n  }\n\n  /** Set position and angle */\n  setNum(position: Vec2Value, rotation: number) {\n    this.p.setVec2(position);\n    this.q.setAngle(rotation);\n  }\n\n  setTransform(xf: TransformValue): void {\n    this.p.setVec2(xf.p);\n    this.q.setRot(xf.q);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Transform.isValid(o), 'Invalid Transform!', o);\n  }\n\n  static mul(a: TransformValue, b: Vec2Value): Vec2;\n  static mul(a: TransformValue, b: TransformValue): Transform;\n  // static mul(a: Transform, b: Vec2Value[]): Vec2[];\n  // static mul(a: Transform, b: Transform[]): Transform[];\n  static mul(a, b) {\n    if (Array.isArray(b)) {\n        // todo: this was used in examples, remove in the future\n      _ASSERT && Transform.assert(a);\n      const arr = [];\n      for (let i = 0; i < b.length; i++) {\n        arr[i] = Transform.mul(a, b[i]);\n      }\n      return arr;\n\n    } else if ('x' in b && 'y' in b) {\n      return Transform.mulVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulXf(a, b);\n    }\n  }\n\n  static mulAll(a: Transform, b: Vec2Value[]): Vec2[];\n  static mulAll(a: Transform, b: Transform[]): Transform[];\n  static mulAll(a: TransformValue, b) {\n    _ASSERT && Transform.assert(a);\n    const arr = [];\n    for (let i = 0; i < b.length; i++) {\n      arr[i] = Transform.mul(a, b[i]);\n    }\n    return arr;\n  }\n\n  /** @internal @deprecated */\n  static mulFn(a: TransformValue) {\n    // todo: this was used in examples, remove in the future\n    _ASSERT && Transform.assert(a);\n    return function(b: Vec2Value): Vec2 {\n      return Transform.mul(a, b);\n    };\n  }\n\n  static mulVec2(a: TransformValue, b: Vec2Value): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;\n    const y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulXf(a: TransformValue, b: TransformValue): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p\n    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p\n    const xf = Transform.identity();\n    xf.q = Rot.mulRot(a.q, b.q);\n    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);\n    return xf;\n  }\n\n  static mulT(a: TransformValue, b: Vec2Value): Vec2;\n  static mulT(a: TransformValue, b: TransformValue): Transform;\n  static mulT(a, b) {\n    if ('x' in b && 'y' in b) {\n      return Transform.mulTVec2(a, b);\n\n    } else if ('p' in b && 'q' in b) {\n      return Transform.mulTXf(a, b);\n    }\n  }\n\n  static mulTVec2(a: TransformValue, b: Vec2Value): Vec2 {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const px = b.x - a.p.x;\n    const py = b.y - a.p.y;\n    const x = (a.q.c * px + a.q.s * py);\n    const y = (-a.q.s * px + a.q.c * py);\n    return Vec2.neo(x, y);\n  }\n\n  static mulTXf(a: TransformValue, b: TransformValue): Transform {\n    _ASSERT && Transform.assert(a);\n    _ASSERT && Transform.assert(b);\n    // v2 = A.q' * (B.q * v1 + B.p - A.p)\n    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)\n    const xf = Transform.identity();\n    xf.q.setRot(Rot.mulTRot(a.q, b.q));\n    xf.p.setVec2(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));\n    return xf;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from '../common/Vec2';\n\nexport class Velocity {\n  /** linear */\n  v = Vec2.zero();\n\n  /** angular */\n  w = 0;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { TransformValue } from '../common/Transform';\n\n\n/** @internal */ const math_sin = Math.sin;\n/** @internal */ const math_cos = Math.cos;\n\n\nexport class Position {\n  /** location */\n  c = Vec2.zero();\n\n  /** angle */\n  a = 0;\n\n  // todo: cache sin/cos\n  getTransform(xf: TransformValue, p: Vec2Value): TransformValue {\n    // xf.q = rotation(this.a);\n    // xf.p = this.c - xf.q * p\n    xf.q.c = math_cos(this.a);\n    xf.q.s = math_sin(this.a);\n    xf.p.x = this.c.x - (xf.q.c * p.x - xf.q.s * p.y);\n    xf.p.y = this.c.y - (xf.q.s * p.x + xf.q.c * p.y);\n    return xf;\n  }\n}\n\nexport function getTransform(xf: TransformValue, p: Vec2Value, c: Vec2Value, a: number): TransformValue {\n  // xf.q = rotation(a);\n  // xf.p = this.c - xf.q * p\n  xf.q.c = math_cos(a);\n  xf.q.s = math_sin(a);\n  xf.p.x = c.x - (xf.q.c * p.x - xf.q.s * p.y);\n  xf.p.y = c.y - (xf.q.s * p.x + xf.q.c * p.y);\n  return xf;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { MassData } from '../dynamics/Body';\nimport { RayCastOutput, RayCastInput, AABBValue } from './AABB';\nimport { DistanceProxy } from './Distance';\nimport type { Transform, TransformValue }  from '../common/Transform';\nimport type { Vec2Value }  from '../common/Vec2';\n\n// todo make shape an interface\n\n/**\n * A shape is used for collision detection. You can create a shape however you\n * like. Shapes used for simulation in World are created automatically when a\n * Fixture is created. Shapes may encapsulate one or more child shapes.\n */\nexport abstract class Shape {\n  m_type: ShapeType;\n\n  /**\n   * Radius of a shape. For polygonal shapes this must be b2_polygonRadius.\n   * There is no support for making rounded polygons.\n   */\n  m_radius: number;\n\n  /** @internal */\n  abstract _reset(): void;\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return typeof obj.m_type === 'string' && typeof obj.m_radius === 'number';\n  }\n\n  abstract getRadius(): number;\n\n  /**\n   * Get the type of this shape. You can use this to down cast to the concrete\n   * shape.\n   *\n   * @return the shape type.\n   */\n  abstract getType(): ShapeType;\n\n  /**\n   * @internal @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  abstract _clone(): Shape;\n\n  /**\n   * Get the number of child primitives.\n   */\n  abstract getChildCount(): number;\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  abstract testPoint(xf: TransformValue, p: Vec2Value): boolean;\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  abstract rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean;\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  abstract computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void;\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  abstract computeMass(massData: MassData, density?: number): void;\n\n  abstract computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void;\n\n}\n\nexport type ShapeType = \"circle\" | \"edge\" | \"polygon\" | \"chain\";\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { options } from '../util/options';\nimport { Vec2Value } from '../common/Vec2';\nimport { AABB, RayCastInput, RayCastOutput } from '../collision/AABB';\nimport { Shape, ShapeType } from '../collision/Shape';\nimport { Body, MassData } from \"./Body\";\nimport { BroadPhase } from \"../collision/BroadPhase\";\nimport { TransformValue } from \"../common/Transform\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/** @internal */ const synchronize_aabb1 = new AABB();\n/** @internal */ const synchronize_aabb2 = new AABB();\n/** @internal */ const displacement = matrix.vec2(0, 0);\n\n/**\n * A fixture definition is used to create a fixture. This class defines an\n * abstract fixture definition. You can reuse fixture definitions safely.\n */\nexport interface FixtureOpt {\n  userData?: unknown;\n  /**\n   * The friction coefficient, usually in the range [0,1]\n   */\n  friction?: number;\n  /**\n   * The restitution (elasticity) usually in the range [0,1]\n   */\n  restitution?: number;\n  /**\n   * The density, usually in kg/m^2\n   */\n  density?: number;\n  /**\n   * A sensor shape collects contact information but never generates a collision response.\n   */\n  isSensor?: boolean;\n  /**\n   * Zero, positive or negative collision group.\n   * Fixtures with same positive groupIndex always collide and fixtures with same negative groupIndex never collide.\n   */\n  filterGroupIndex?: number;\n  /**\n   * Collision category bit or bits that this fixture belongs to.\n   * If groupIndex is zero or not matching, then at least one bit in this fixture categoryBits should match other fixture maskBits and vice versa.\n   */\n  filterCategoryBits?: number;\n  /**\n   * Collision category bit or bits that this fixture accept for collision.\n   */\n  filterMaskBits?: number;\n}\n\nexport interface FixtureDef extends FixtureOpt {\n  shape: Shape;\n}\n\n/** @internal */ const FixtureDefDefault: FixtureOpt = {\n  userData : null,\n  friction : 0.2,\n  restitution : 0.0,\n  density : 0.0,\n  isSensor : false,\n\n  filterGroupIndex : 0,\n  filterCategoryBits : 0x0001,\n  filterMaskBits : 0xFFFF\n};\n\n/**\n * This proxy is used internally to connect shape children to the broad-phase.\n */\nexport class FixtureProxy {\n  aabb: AABB;\n  fixture: Fixture;\n  childIndex: number;\n  proxyId: number;\n  constructor(fixture: Fixture, childIndex: number) {\n    this.aabb = new AABB();\n    this.fixture = fixture;\n    this.childIndex = childIndex;\n    this.proxyId;\n  }\n}\n\n/**\n * A fixture is used to attach a shape to a body for collision detection. A\n * fixture inherits its transform from its parent. Fixtures hold additional\n * non-geometric data such as friction, collision filters, etc.\n *\n * To create a new Fixture use {@link Body.createFixture}.\n */\nexport class Fixture {\n  /** @internal */ m_body: Body;\n  /** @internal */ m_friction: number;\n  /** @internal */ m_restitution: number;\n  /** @internal */ m_density: number;\n  /** @internal */ m_isSensor: boolean;\n  /** @internal */ m_filterGroupIndex: number;\n  /** @internal */ m_filterCategoryBits: number;\n  /** @internal */ m_filterMaskBits: number;\n  /** @internal */ m_shape: Shape;\n  /** @internal */ m_next: Fixture | null;\n  /** @internal */ m_proxies: FixtureProxy[];\n  // 0 indicates inactive state, this is not the same as m_proxies.length\n  /** @internal */ m_proxyCount: number;\n  /** @internal */ m_userData: unknown;\n\n  constructor(body: Body, def: FixtureDef);\n  constructor(body: Body, shape: Shape, def?: FixtureOpt);\n  constructor(body: Body, shape: Shape, density?: number);\n  /** @internal */\n  constructor(body: Body, shape?, def?) {\n    if (shape.shape) {\n      def = shape;\n      shape = shape.shape;\n\n    } else if (typeof def === 'number') {\n      def = {density : def};\n    }\n\n    def = options(def, FixtureDefDefault);\n\n    this.m_body = body;\n\n    this.m_friction = def.friction;\n    this.m_restitution = def.restitution;\n    this.m_density = def.density;\n    this.m_isSensor = def.isSensor;\n\n    this.m_filterGroupIndex = def.filterGroupIndex;\n    this.m_filterCategoryBits = def.filterCategoryBits;\n    this.m_filterMaskBits = def.filterMaskBits;\n\n    // TODO validate shape\n    this.m_shape = shape; // .clone();\n\n    this.m_next = null;\n\n    this.m_proxies = [];\n    this.m_proxyCount = 0;\n\n    // fixture proxies are created here,\n    // but they are activate in when a fixture is added to body\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n\n    this.m_userData = def.userData;\n  }\n\n  /** @internal Re-setup fixture. */\n  _reset(): void {\n    const body = this.getBody();\n    const broadPhase = body.m_world.m_broadPhase;\n    this.destroyProxies(broadPhase);\n    if (this.m_shape._reset) {\n      this.m_shape._reset();\n    }\n    const childCount = this.m_shape.getChildCount();\n    for (let i = 0; i < childCount; ++i) {\n      this.m_proxies[i] = new FixtureProxy(this, i);\n    }\n    this.createProxies(broadPhase, body.m_xf);\n    body.resetMassData();\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      friction: this.m_friction,\n      restitution: this.m_restitution,\n      density: this.m_density,\n      isSensor: this.m_isSensor,\n\n      filterGroupIndex: this.m_filterGroupIndex,\n      filterCategoryBits: this.m_filterCategoryBits,\n      filterMaskBits: this.m_filterMaskBits,\n\n      shape: this.m_shape,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, body: any, restore: any): Fixture {\n    const shape = restore(Shape, data.shape);\n    const fixture = shape && new Fixture(body, shape, data);\n    return fixture;\n  }\n\n  /**\n   * Get the type of the child shape. You can use this to down cast to the\n   * concrete shape.\n   */\n  getType(): ShapeType {\n    return this.m_shape.m_type;\n  }\n\n  /**\n   * Get the child shape. You can modify the child shape, however you should not\n   * change the number of vertices because this will crash some collision caching\n   * mechanisms. Manipulating the shape may lead to non-physical behavior.\n   */\n  getShape(): Shape {\n    return this.m_shape;\n  }\n\n  /**\n   * A sensor shape collects contact information but never generates a collision\n   * response.\n   */\n  isSensor(): boolean {\n    return this.m_isSensor;\n  }\n\n  /**\n   * Set if this fixture is a sensor.\n   */\n  setSensor(sensor: boolean): void {\n    if (sensor != this.m_isSensor) {\n      this.m_body.setAwake(true);\n      this.m_isSensor = sensor;\n    }\n  }\n\n  // /**\n  //  * Get the contact filtering data.\n  //  */\n  // getFilterData() {\n  //   return this.m_filter;\n  // }\n\n  /**\n   * Get the user data that was assigned in the fixture definition. Use this to\n   * store your application specific data.\n   */\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  /**\n   * Set the user data. Use this to store your application specific data.\n   */\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get the parent body of this fixture. This is null if the fixture is not\n   * attached.\n   */\n  getBody(): Body {\n    return this.m_body;\n  }\n\n  /**\n   * Get the next fixture in the parent body's fixture list.\n   */\n  getNext(): Fixture | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get the density of this fixture.\n   */\n  getDensity(): number {\n    return this.m_density;\n  }\n\n  /**\n   * Set the density of this fixture. This will _not_ automatically adjust the\n   * mass of the body. You must call Body.resetMassData to update the body's mass.\n   */\n  setDensity(density: number): void {\n    _ASSERT && console.assert(Number.isFinite(density) && density >= 0.0);\n    this.m_density = density;\n  }\n\n  /**\n   * Get the coefficient of friction, usually in the range [0,1].\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Set the coefficient of friction. This will not change the friction of\n   * existing contacts.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the coefficient of restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Set the coefficient of restitution. This will not change the restitution of\n   * existing contacts.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Test a point in world coordinates for containment in this fixture.\n   */\n  testPoint(p: Vec2Value): boolean {\n    return this.m_shape.testPoint(this.m_body.getTransform(), p);\n  }\n\n  /**\n   * Cast a ray against this shape.\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, childIndex: number): boolean {\n    return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);\n  }\n\n  /**\n   * Get the mass data for this fixture. The mass data is based on the density and\n   * the shape. The rotational inertia is about the shape's origin. This operation\n   * may be expensive.\n   */\n  getMassData(massData: MassData): void {\n    this.m_shape.computeMass(massData, this.m_density);\n  }\n\n  /**\n   * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a\n   * more accurate AABB, compute it using the shape and the body transform.\n   */\n  getAABB(childIndex: number): AABB {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_proxies.length);\n    return this.m_proxies[childIndex].aabb;\n  }\n\n  /**\n   * These support body activation/deactivation.\n   */\n  createProxies(broadPhase: BroadPhase, xf: TransformValue): void {\n    _ASSERT && console.assert(this.m_proxyCount == 0);\n\n    // Create proxies in the broad-phase.\n    this.m_proxyCount = this.m_shape.getChildCount();\n\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      this.m_shape.computeAABB(proxy.aabb, xf, i);\n      proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n    }\n  }\n\n  destroyProxies(broadPhase: BroadPhase): void {\n    // Destroy proxies in the broad-phase.\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      broadPhase.destroyProxy(proxy.proxyId);\n      proxy.proxyId = null;\n    }\n\n    this.m_proxyCount = 0;\n  }\n\n  /**\n   * Updates this fixture proxy in broad-phase (with combined AABB of current and\n   * next transformation).\n   */\n  synchronize(broadPhase: BroadPhase, xf1: TransformValue, xf2: TransformValue): void {\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      const proxy = this.m_proxies[i];\n      // Compute an AABB that covers the swept shape (may miss some rotation\n      // effect).\n      this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);\n      this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);\n\n      proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);\n\n      matrix.diffVec2(displacement, xf2.p, xf1.p);\n\n      broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n    }\n  }\n\n  /**\n   * Set the contact filtering data. This will not update contacts until the next\n   * time step when either parent body is active and awake. This automatically\n   * calls refilter.\n   */\n  setFilterData(filter: { groupIndex: number, categoryBits: number, maskBits: number }): void {\n    this.m_filterGroupIndex = filter.groupIndex;\n    this.m_filterCategoryBits = filter.categoryBits;\n    this.m_filterMaskBits = filter.maskBits;\n    this.refilter();\n  }\n\n  getFilterGroupIndex(): number {\n    return this.m_filterGroupIndex;\n  }\n\n  setFilterGroupIndex(groupIndex: number): void {\n    this.m_filterGroupIndex = groupIndex;\n    this.refilter();\n  }\n\n  getFilterCategoryBits(): number {\n    return this.m_filterCategoryBits;\n  }\n\n  setFilterCategoryBits(categoryBits: number): void {\n    this.m_filterCategoryBits = categoryBits;\n    this.refilter();\n  }\n\n  getFilterMaskBits(): number {\n    return this.m_filterMaskBits;\n  }\n\n  setFilterMaskBits(maskBits: number): void {\n    this.m_filterMaskBits = maskBits;\n    this.refilter();\n  }\n\n  /**\n   * Call this if you want to establish collision that was previously disabled by\n   * ContactFilter.\n   */\n  refilter(): void {\n    if (this.m_body == null) {\n      return;\n    }\n\n    // Flag associated contacts for filtering.\n    let edge = this.m_body.getContactList();\n    while (edge) {\n      const contact = edge.contact;\n      const fixtureA = contact.getFixtureA();\n      const fixtureB = contact.getFixtureB();\n      if (fixtureA == this || fixtureB == this) {\n        contact.flagForFiltering();\n      }\n\n      edge = edge.next;\n    }\n\n    const world = this.m_body.getWorld();\n\n    if (world == null) {\n      return;\n    }\n\n    // Touch each proxy so that new pairs may be created\n    const broadPhase = world.m_broadPhase;\n    for (let i = 0; i < this.m_proxyCount; ++i) {\n      broadPhase.touchProxy(this.m_proxies[i].proxyId);\n    }\n  }\n\n  /**\n   * Implement this method to provide collision filtering, if you want finer\n   * control over contact creation.\n   *\n   * Return true if contact calculations should be performed between these two\n   * fixtures.\n   *\n   * Warning: for performance reasons this is only called when the AABBs begin to\n   * overlap.\n   */\n  shouldCollide(that: Fixture): boolean {\n\n    if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n      return that.m_filterGroupIndex > 0;\n    }\n\n    const collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n    const collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n    const collide = collideA && collideB;\n    return collide;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { options } from '../util/options';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Velocity } from './Velocity';\nimport { Position } from './Position';\nimport { Fixture, FixtureDef, FixtureOpt } from './Fixture';\nimport { Shape } from '../collision/Shape';\nimport { JointEdge } from \"./Joint\";\nimport { World } from \"./World\";\nimport { ContactEdge } from \"./Contact\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nexport type BodyType = 'static' | 'kinematic' | 'dynamic';\n\n/** @internal */ const STATIC = 'static';\n/** @internal */ const KINEMATIC = 'kinematic';\n/** @internal */ const DYNAMIC = 'dynamic';\n\n/** @internal */ const oldCenter = matrix.vec2(0, 0);\n/** @internal */ const localCenter = matrix.vec2(0, 0);\n/** @internal */ const shift = matrix.vec2(0, 0);\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const xf = matrix.transform(0, 0, 0)\n\nexport interface BodyDef {\n  /**\n   * Body types are static, kinematic, or dynamic. Note: if a dynamic\n   * body would have zero mass, the mass is set to one.\n   */\n  type?: BodyType;\n  /**\n   * The world position of the body. Avoid creating bodies at the\n   * origin since this can lead to many overlapping shapes.\n   */\n  position?: Vec2;\n  /**\n   * The world angle of the body in radians.\n   */\n  angle?: number;\n  /**\n   * The linear velocity of the body's origin in world co-ordinates.\n   */\n  linearVelocity?: Vec2;\n  angularVelocity?: number;\n  /**\n   * Linear damping is use to reduce the linear velocity. The\n   * damping parameter can be larger than 1.0 but the damping effect becomes\n   * sensitive to the time step when the damping parameter is large.\n   * Units are 1/time\n   */\n  linearDamping?: number;\n  /**\n   * Angular damping is use to reduce the angular velocity.\n   * The damping parameter can be larger than 1.0 but the damping effect\n   * becomes sensitive to the time step when the damping parameter is large.\n   * Units are 1/time\n   */\n  angularDamping?: number;\n  /**\n   * Should this body be prevented from rotating? Useful for characters.\n   */\n  fixedRotation?: boolean;\n  /**\n   * Is this a fast moving body that should be prevented from\n   * tunneling through other moving bodies? Note that all bodies are\n   * prevented from tunneling through kinematic and static bodies. This\n   * setting is only considered on dynamic bodies. Warning: You should use\n   * this flag sparingly since it increases processing time.\n   */\n  bullet?: boolean;\n  gravityScale?: number;\n  /**\n   * Set this flag to false if this body should never fall asleep. Note that this increases CPU usage.\n   */\n  allowSleep?: boolean;\n  /**\n   * Is this body initially awake or sleeping?\n   */\n  awake?: boolean;\n  /**\n   * Does this body start out active?\n   */\n  active?: boolean;\n  userData?: any;\n}\n\n/** @internal */ const BodyDefDefault: BodyDef = {\n  type : STATIC,\n  position : Vec2.zero(),\n  angle : 0.0,\n\n  linearVelocity : Vec2.zero(),\n  angularVelocity : 0.0,\n\n  linearDamping : 0.0,\n  angularDamping : 0.0,\n\n  fixedRotation : false,\n  bullet : false,\n  gravityScale : 1.0,\n\n  allowSleep : true,\n  awake : true,\n  active : true,\n\n  userData : null\n};\n\n/**\n * MassData This holds the mass data computed for a shape.\n */\nexport interface MassData {\n  /** The mass of the shape, usually in kilograms. */\n  mass: number;\n  /** The position of the shape's centroid relative to the shape's origin. */\n  center: Vec2Value;\n  /** The rotational inertia of the shape about the local origin. */\n  I: number;\n}\n\n/**\n * A rigid body composed of one or more fixtures.\n *\n * To create a new Body use {@link World.createBody}.\n */\nexport class Body {\n  /**\n   * A static body does not move under simulation and behaves as if it has infinite mass.\n   * Internally, zero is stored for the mass and the inverse mass.\n   * Static bodies can be moved manually by the user.\n   * A static body has zero velocity.\n   * Static bodies do not collide with other static or kinematic bodies.\n   */\n  static readonly STATIC: BodyType = 'static';\n  /**\n   * A kinematic body moves under simulation according to its velocity.\n   * Kinematic bodies do not respond to forces.\n   * They can be moved manually by the user, but normally a kinematic body is moved by setting its velocity.\n   * A kinematic body behaves as if it has infinite mass, however, zero is stored for the mass and the inverse mass.\n   * Kinematic bodies do not collide with other kinematic or static bodies.\n   */\n  static readonly KINEMATIC: BodyType = 'kinematic';\n\n  /**\n   * A dynamic body is fully simulated.\n   * They can be moved manually by the user, but normally they move according to forces.\n   * A dynamic body can collide with all body types.\n   * A dynamic body always has finite, non-zero mass.\n   * If you try to set the mass of a dynamic body to zero, it will automatically acquire a mass of one kilogram and it won't rotate.\n   */\n  static readonly DYNAMIC: BodyType = 'dynamic';\n\n  /** @internal */ m_world: World;\n  /** @internal */ m_awakeFlag: boolean;\n  /** @internal */ m_autoSleepFlag: boolean;\n  /** @internal */ m_bulletFlag: boolean;\n  /** @internal */ m_fixedRotationFlag: boolean;\n  /** @internal */ m_activeFlag: boolean;\n  /** @internal */ m_islandFlag: boolean;\n  /** @internal */ m_toiFlag: boolean;\n  /** @internal */ m_userData: unknown;\n  /** @internal */ m_type: BodyType;\n  /** @internal */ m_mass: number;\n  /** @internal */ m_invMass: number;\n  /** @internal Rotational inertia about the center of mass. */\n  m_I: number;\n  /** @internal */ m_invI: number;\n  /** @internal the body origin transform */\n  m_xf: Transform;\n  /** @internal the swept motion for CCD */\n  m_sweep: Sweep;\n  // position and velocity correction\n  /** @internal */ c_velocity: Velocity;\n  /** @internal */ c_position: Position;\n  /** @internal */ m_force: Vec2;\n  /** @internal */ m_torque: number;\n  /** @internal */ m_linearVelocity: Vec2;\n  /** @internal */ m_angularVelocity: number;\n  /** @internal */ m_linearDamping: number;\n  /** @internal */ m_angularDamping: number;\n  /** @internal */ m_gravityScale: number;\n  /** @internal */ m_sleepTime: number;\n  /** @internal */ m_jointList: JointEdge | null;\n  /** @internal */ m_contactList: ContactEdge | null;\n  /** @internal */ m_fixtureList: Fixture | null;\n  /** @internal */ m_prev: Body | null;\n  /** @internal */ m_next: Body | null;\n  /** @internal */ m_destroyed: boolean;\n\n  /** @internal */\n  constructor(world: World, def: BodyDef) {\n    def = options(def, BodyDefDefault);\n\n    _ASSERT && console.assert(Vec2.isValid(def.position));\n    _ASSERT && console.assert(Vec2.isValid(def.linearVelocity));\n    _ASSERT && console.assert(Number.isFinite(def.angle));\n    _ASSERT && console.assert(Number.isFinite(def.angularVelocity));\n    _ASSERT && console.assert(Number.isFinite(def.angularDamping) && def.angularDamping >= 0.0);\n    _ASSERT && console.assert(Number.isFinite(def.linearDamping) && def.linearDamping >= 0.0);\n\n    this.m_world = world;\n\n    this.m_awakeFlag = def.awake;\n    this.m_autoSleepFlag = def.allowSleep;\n    this.m_bulletFlag = def.bullet;\n    this.m_fixedRotationFlag = def.fixedRotation;\n    this.m_activeFlag = def.active;\n\n    this.m_islandFlag = false;\n    this.m_toiFlag = false;\n\n    this.m_userData = def.userData;\n    this.m_type = def.type;\n\n    if (this.m_type == DYNAMIC) {\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    } else {\n      this.m_mass = 0.0;\n      this.m_invMass = 0.0;\n    }\n\n    // Rotational inertia about the center of mass.\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    // the body origin transform\n    this.m_xf = Transform.identity();\n    this.m_xf.p.setVec2(def.position);\n    this.m_xf.q.setAngle(def.angle);\n\n    // the swept motion for CCD\n    this.m_sweep = new Sweep();\n    this.m_sweep.setTransform(this.m_xf);\n\n    // position and velocity correction\n    this.c_velocity = new Velocity();\n    this.c_position = new Position();\n\n    this.m_force = Vec2.zero();\n    this.m_torque = 0.0;\n\n    this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n    this.m_angularVelocity = def.angularVelocity;\n\n    this.m_linearDamping = def.linearDamping;\n    this.m_angularDamping = def.angularDamping;\n    this.m_gravityScale = def.gravityScale;\n\n    this.m_sleepTime = 0.0;\n\n    this.m_jointList = null;\n    this.m_contactList = null;\n    this.m_fixtureList = null;\n\n    this.m_prev = null;\n    this.m_next = null;\n\n    this.m_destroyed = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const fixtures = [];\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      fixtures.push(f);\n    }\n    return {\n      type: this.m_type,\n      bullet: this.m_bulletFlag,\n      position: this.m_xf.p,\n      angle: this.m_xf.q.getAngle(),\n      linearVelocity: this.m_linearVelocity,\n      angularVelocity: this.m_angularVelocity,\n      fixtures,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): Body {\n    const body = new Body(world, data);\n\n    if (data.fixtures) {\n      for (let i = data.fixtures.length - 1; i >= 0; i--) {\n        const fixture = restore(Fixture, data.fixtures[i], body);\n        body._addFixture(fixture);\n      }\n    }\n    return body;\n  }\n\n  isWorldLocked(): boolean {\n    return this.m_world && this.m_world.isLocked() ? true : false;\n  }\n\n  getWorld(): World {\n    return this.m_world;\n  }\n\n  getNext(): Body | null {\n    return this.m_next;\n  }\n\n  setUserData(data: any): void {\n    this.m_userData = data;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  getFixtureList(): Fixture | null {\n    return this.m_fixtureList;\n  }\n\n  getJointList(): JointEdge | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Warning: this list changes during the time step and you may miss some\n   * collisions if you don't use ContactListener.\n   */\n  getContactList(): ContactEdge | null {\n    return this.m_contactList;\n  }\n\n  isStatic(): boolean {\n    return this.m_type == STATIC;\n  }\n\n  isDynamic(): boolean {\n    return this.m_type == DYNAMIC;\n  }\n\n  isKinematic(): boolean {\n    return this.m_type == KINEMATIC;\n  }\n\n  /**\n   * This will alter the mass and velocity.\n   */\n  setStatic(): Body {\n    this.setType(STATIC);\n    return this;\n  }\n\n  setDynamic(): Body {\n    this.setType(DYNAMIC);\n    return this;\n  }\n\n  setKinematic(): Body {\n    this.setType(KINEMATIC);\n    return this;\n  }\n\n  /**\n   * Get the type of the body.\n   */\n  getType(): BodyType {\n    return this.m_type;\n  }\n\n  /**\n   * Set the type of the body to \"static\", \"kinematic\" or \"dynamic\".\n   * @param type The type of the body.\n   */\n  setType(type: BodyType): void {\n    _ASSERT && console.assert(type === STATIC || type === KINEMATIC || type === DYNAMIC);\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type == type) {\n      return;\n    }\n\n    this.m_type = type;\n\n    this.resetMassData();\n\n    if (this.m_type == STATIC) {\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_sweep.forward();\n      this.synchronizeFixtures();\n    }\n\n    this.setAwake(true);\n\n    this.m_force.setZero();\n    this.m_torque = 0.0;\n\n    // Delete the attached contacts.\n    let ce = this.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n      this.m_world.destroyContact(ce0.contact);\n    }\n    this.m_contactList = null;\n\n    // Touch the proxies so that new contacts will be created (when appropriate)\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      for (let i = 0; i < f.m_proxyCount; ++i) {\n        broadPhase.touchProxy(f.m_proxies[i].proxyId);\n      }\n    }\n  }\n\n  isBullet(): boolean {\n    return this.m_bulletFlag;\n  }\n\n  /**\n   * Should this body be treated like a bullet for continuous collision detection?\n   */\n  setBullet(flag: boolean): void {\n    this.m_bulletFlag = !!flag;\n  }\n\n  isSleepingAllowed(): boolean {\n    return this.m_autoSleepFlag;\n  }\n\n  setSleepingAllowed(flag: boolean): void {\n    this.m_autoSleepFlag = !!flag;\n    if (this.m_autoSleepFlag == false) {\n      this.setAwake(true);\n    }\n  }\n\n  isAwake(): boolean {\n    return this.m_awakeFlag;\n  }\n\n  /**\n   * Set the sleep state of the body. A sleeping body has very low CPU cost.\n   *\n   * @param flag Set to true to wake the body, false to put it to sleep.\n   */\n  setAwake(flag: boolean): void {\n    if (flag) {\n      this.m_awakeFlag = true;\n      this.m_sleepTime = 0.0;\n    } else {\n      this.m_awakeFlag = false;\n      this.m_sleepTime = 0.0;\n      this.m_linearVelocity.setZero();\n      this.m_angularVelocity = 0.0;\n      this.m_force.setZero();\n      this.m_torque = 0.0;\n    }\n  }\n\n  isActive(): boolean {\n    return this.m_activeFlag;\n  }\n\n  /**\n   * Set the active state of the body. An inactive body is not simulated and\n   * cannot be collided with or woken up. If you pass a flag of true, all fixtures\n   * will be added to the broad-phase. If you pass a flag of false, all fixtures\n   * will be removed from the broad-phase and all contacts will be destroyed.\n   * Fixtures and joints are otherwise unaffected.\n   *\n   * You may continue to create/destroy fixtures and joints on inactive bodies.\n   * Fixtures on an inactive body are implicitly inactive and will not participate\n   * in collisions, ray-casts, or queries. Joints connected to an inactive body\n   * are implicitly inactive. An inactive body is still owned by a World object\n   * and remains\n   */\n  setActive(flag: boolean): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (flag == this.m_activeFlag) {\n      return;\n    }\n\n    this.m_activeFlag = !!flag;\n\n    if (this.m_activeFlag) {\n      // Create all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.createProxies(broadPhase, this.m_xf);\n      }\n\t\t  // Contacts are created at the beginning of the next\n\t\t  this.m_world.m_newFixture = true;\n    } else {\n      // Destroy all proxies.\n      const broadPhase = this.m_world.m_broadPhase;\n      for (let f = this.m_fixtureList; f; f = f.m_next) {\n        f.destroyProxies(broadPhase);\n      }\n\n      // Destroy the attached contacts.\n      let ce = this.m_contactList;\n      while (ce) {\n        const ce0 = ce;\n        ce = ce.next;\n        this.m_world.destroyContact(ce0.contact);\n      }\n      this.m_contactList = null;\n    }\n  }\n\n  isFixedRotation(): boolean {\n    return this.m_fixedRotationFlag;\n  }\n\n  /**\n   * Set this body to have fixed rotation. This causes the mass to be reset.\n   */\n  setFixedRotation(flag: boolean): void {\n    if (this.m_fixedRotationFlag == flag) {\n      return;\n    }\n\n    this.m_fixedRotationFlag = !!flag;\n\n    this.m_angularVelocity = 0.0;\n\n    this.resetMassData();\n  }\n\n  /**\n   * Get the world transform for the body's origin.\n   */\n  getTransform(): Transform {\n    return this.m_xf;\n  }\n\n  /**\n   * Set the position of the body's origin and rotation. Manipulating a body's\n   * transform may cause non-physical behavior. Note: contacts are updated on the\n   * next call to World.step.\n   *\n   * @param position The world position of the body's local origin.\n   * @param angle The world rotation in radians.\n   */\n  setTransform(position: Vec2, angle: number): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    this.m_xf.setNum(position, angle);\n    this.m_sweep.setTransform(this.m_xf);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, this.m_xf, this.m_xf);\n    }\n    this.setAwake(true);\n  }\n\n  synchronizeTransform(): void {\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Update fixtures in broad-phase.\n   */\n  synchronizeFixtures(): void {\n    this.m_sweep.getTransform(xf, 0);\n\n    const broadPhase = this.m_world.m_broadPhase;\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      f.synchronize(broadPhase, xf, this.m_xf);\n    }\n  }\n\n  /**\n   * Used in TOI.\n   */\n  advance(alpha: number): void {\n    // Advance to the new safe time. This doesn't sync the broad-phase.\n    this.m_sweep.advance(alpha);\n    matrix.copyVec2(this.m_sweep.c, this.m_sweep.c0);\n    this.m_sweep.a = this.m_sweep.a0;\n    this.m_sweep.getTransform(this.m_xf, 1);\n  }\n\n  /**\n   * Get the world position for the body's origin.\n   */\n  getPosition(): Vec2 {\n    return this.m_xf.p;\n  }\n\n  setPosition(p: Vec2): void {\n    this.setTransform(p, this.m_sweep.a);\n  }\n\n  /**\n   * Get the current world rotation angle in radians.\n   */\n  getAngle(): number {\n    return this.m_sweep.a;\n  }\n\n  setAngle(angle: number): void {\n    this.setTransform(this.m_xf.p, angle);\n  }\n\n  /**\n   * Get the world position of the center of mass.\n   */\n  getWorldCenter(): Vec2 {\n    return this.m_sweep.c;\n  }\n\n  /**\n   * Get the local position of the center of mass.\n   */\n  getLocalCenter(): Vec2 {\n    return this.m_sweep.localCenter;\n  }\n\n  /**\n   * Get the linear velocity of the center of mass.\n   *\n   * @return the linear velocity of the center of mass.\n   */\n  getLinearVelocity(): Vec2 {\n    return this.m_linearVelocity;\n  }\n\n  /**\n   * Get the world linear velocity of a world point attached to this body.\n   *\n   * @param worldPoint A point in world coordinates.\n   */\n  getLinearVelocityFromWorldPoint(worldPoint: Vec2): Vec2 {\n    const localCenter = Vec2.sub(worldPoint, this.m_sweep.c);\n    return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity,\n      localCenter));\n  }\n\n  /**\n   * Get the world velocity of a local point.\n   *\n   * @param localPoint A point in local coordinates.\n   */\n  getLinearVelocityFromLocalPoint(localPoint: Vec2): Vec2 {\n    return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n  }\n\n  /**\n   * Set the linear velocity of the center of mass.\n   *\n   * @param v The new linear velocity of the center of mass.\n   */\n  setLinearVelocity(v: Vec2): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (Vec2.dot(v, v) > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_linearVelocity.setVec2(v);\n  }\n\n  /**\n   * Get the angular velocity.\n   *\n   * @returns the angular velocity in radians/second.\n   */\n  getAngularVelocity(): number {\n    return this.m_angularVelocity;\n  }\n\n  /**\n   * Set the angular velocity.\n   *\n   * @param omega The new angular velocity in radians/second.\n   */\n  setAngularVelocity(w: number): void {\n    if (this.m_type == STATIC) {\n      return;\n    }\n    if (w * w > 0.0) {\n      this.setAwake(true);\n    }\n    this.m_angularVelocity = w;\n  }\n\n  getLinearDamping(): number {\n    return this.m_linearDamping;\n  }\n\n  setLinearDamping(linearDamping: number): void {\n    this.m_linearDamping = linearDamping;\n  }\n\n  getAngularDamping(): number {\n    return this.m_angularDamping;\n  }\n\n  setAngularDamping(angularDamping: number): void {\n    this.m_angularDamping = angularDamping;\n  }\n\n  getGravityScale(): number {\n    return this.m_gravityScale;\n  }\n\n  /**\n   * Scale the gravity applied to this body.\n   */\n  setGravityScale(scale: number): void {\n    this.m_gravityScale = scale;\n  }\n\n  /**\n   * Get the total mass of the body.\n   *\n   * @returns The mass, usually in kilograms (kg).\n   */\n  getMass(): number {\n    return this.m_mass;\n  }\n\n  /**\n   * Get the rotational inertia of the body about the local origin.\n   *\n   * @return the rotational inertia, usually in kg-m^2.\n   */\n  getInertia(): number {\n    return this.m_I + this.m_mass\n      * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n  }\n\n  /**\n   * Copy the mass data of the body to data.\n   */\n  getMassData(data: MassData): void {\n    data.mass = this.m_mass;\n    data.I = this.getInertia();\n    matrix.copyVec2(data.center, this.m_sweep.localCenter);\n  }\n\n  /**\n   * This resets the mass properties to the sum of the mass properties of the\n   * fixtures. This normally does not need to be called unless you called\n   * SetMassData to override the mass and you later want to reset the mass.\n   */\n  resetMassData(): void {\n    // Compute mass data from shapes. Each shape has its own density.\n    this.m_mass = 0.0;\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n    matrix.zeroVec2(this.m_sweep.localCenter);\n\n    // Static and kinematic bodies have zero mass.\n    if (this.isStatic() || this.isKinematic()) {\n      matrix.copyVec2(this.m_sweep.c0, this.m_xf.p);\n      matrix.copyVec2(this.m_sweep.c, this.m_xf.p);\n      this.m_sweep.a0 = this.m_sweep.a;\n      return;\n    }\n\n    _ASSERT && console.assert(this.isDynamic());\n\n    // Accumulate mass over all fixtures.\n    matrix.zeroVec2(localCenter);\n    for (let f = this.m_fixtureList; f; f = f.m_next) {\n      if (f.m_density == 0.0) {\n        continue;\n      }\n\n      const massData: MassData = {\n        mass: 0,\n        center: matrix.vec2(0, 0),\n        I: 0\n      };\n      f.getMassData(massData);\n      this.m_mass += massData.mass;\n      matrix.addMulVec2(localCenter, massData.mass, massData.center)\n      this.m_I += massData.I;\n    }\n\n    // Compute center of mass.\n    if (this.m_mass > 0.0) {\n      this.m_invMass = 1.0 / this.m_mass;\n      matrix.setMulVec2(localCenter, this.m_invMass, localCenter)\n\n    } else {\n      // Force all dynamic bodies to have a positive mass.\n      this.m_mass = 1.0;\n      this.m_invMass = 1.0;\n    }\n\n    if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {\n      // Center the inertia about the center of mass.\n      this.m_I -= this.m_mass * matrix.dotVec2(localCenter, localCenter);\n      _ASSERT && console.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n\n    } else {\n      this.m_I = 0.0;\n      this.m_invI = 0.0;\n    }\n\n    // Move center of mass.\n    matrix.copyVec2(oldCenter, this.m_sweep.c);\n    this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n\n    // Update center of mass velocity.\n    matrix.diffVec2(shift, this.m_sweep.c, oldCenter);\n    matrix.crossNumVec2(temp, this.m_angularVelocity, shift);\n    matrix.addVec2(this.m_linearVelocity, temp);\n  }\n\n  /**\n   * Set the mass properties to override the mass properties of the fixtures. Note\n   * that this changes the center of mass position. Note that creating or\n   * destroying fixtures can also alter the mass. This function has no effect if\n   * the body isn't dynamic.\n   *\n   * @param massData The mass properties.\n   */\n  setMassData(massData: MassData): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    this.m_invMass = 0.0;\n    this.m_I = 0.0;\n    this.m_invI = 0.0;\n\n    this.m_mass = massData.mass;\n    if (this.m_mass <= 0.0) {\n      this.m_mass = 1.0;\n    }\n\n    this.m_invMass = 1.0 / this.m_mass;\n\n    if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {\n      this.m_I = massData.I - this.m_mass * matrix.dotVec2(massData.center, massData.center);\n      _ASSERT && console.assert(this.m_I > 0.0);\n      this.m_invI = 1.0 / this.m_I;\n    }\n\n    // Move center of mass.\n    matrix.copyVec2(oldCenter, this.m_sweep.c);\n    this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n\n    // Update center of mass velocity.\n    matrix.diffVec2(shift, this.m_sweep.c, oldCenter);\n    matrix.crossNumVec2(temp, this.m_angularVelocity, shift);\n    matrix.addVec2(this.m_linearVelocity, temp);\n  }\n\n  /**\n   * Apply a force at a world point. If the force is not applied at the center of\n   * mass, it will generate a torque and affect the angular velocity. This wakes\n   * up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyForce(force: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping.\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n      this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), force);\n    }\n  }\n\n  /**\n   * Apply a force to the center of mass. This wakes up the body.\n   *\n   * @param force The world force vector, usually in Newtons (N).\n   * @param wake Also wake up the body\n   */\n  applyForceToCenter(force: Vec2Value, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_force.add(force);\n    }\n  }\n\n  /**\n   * Apply a torque. This affects the angular velocity without affecting the\n   * linear velocity of the center of mass. This wakes up the body.\n   *\n   * @param torque About the z-axis (out of the screen), usually in N-m.\n   * @param wake Also wake up the body\n   */\n  applyTorque(torque: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate a force if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_torque += torque;\n    }\n  }\n\n  /**\n   * Apply an impulse at a point. This immediately modifies the velocity. It also\n   * modifies the angular velocity if the point of application is not at the\n   * center of mass. This wakes up the body.\n   *\n   * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.\n   * @param point The world position of the point of application.\n   * @param wake Also wake up the body\n   */\n  applyLinearImpulse(impulse: Vec2, point: Vec2, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_linearVelocity.addMul(this.m_invMass, impulse);\n      this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point, this.m_sweep.c), impulse);\n    }\n  }\n\n  /**\n   * Apply an angular impulse.\n   *\n   * @param impulse The angular impulse in units of kg*m*m/s\n   * @param wake Also wake up the body\n   */\n  applyAngularImpulse(impulse: number, wake: boolean = true): void {\n    if (this.m_type != DYNAMIC) {\n      return;\n    }\n\n    if (wake && this.m_awakeFlag == false) {\n      this.setAwake(true);\n    }\n    // Don't accumulate velocity if the body is sleeping\n    if (this.m_awakeFlag) {\n      this.m_angularVelocity += this.m_invI * impulse;\n    }\n  }\n\n  /**\n   * This is used to test if two bodies should collide.\n   * \n   * Bodies do not collide when:\n   * - Neither of them is dynamic\n   * - They are connected by a joint with collideConnected == false\n   */\n  shouldCollide(that: Body): boolean {\n    // At least one body should be dynamic.\n    if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n      return false;\n    }\n    // Does a joint prevent collision?\n    for (let jn = this.m_jointList; jn; jn = jn.next) {\n      if (jn.other == that) {\n        if (jn.joint.m_collideConnected == false) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /** @internal Used for deserialize. */\n  _addFixture(fixture: Fixture): Fixture {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.createProxies(broadPhase, this.m_xf);\n    }\n\n    fixture.m_next = this.m_fixtureList;\n    this.m_fixtureList = fixture;\n\n    // Adjust mass properties if needed.\n    if (fixture.m_density > 0.0) {\n      this.resetMassData();\n    }\n\n    // Let the world know we have a new fixture. This will cause new contacts\n    // to be created at the beginning of the next time step.\n    this.m_world.m_newFixture = true;\n\n    return fixture;\n  }\n\n  /**\n   * Creates a fixture and attach it to this body.\n   *\n   * If the density is non-zero, this function automatically updates the mass of\n   * the body.\n   *\n   * Contacts are not created until the next time step.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createFixture(def: FixtureDef): Fixture;\n  createFixture(shape: Shape, opt?: FixtureOpt): Fixture;\n  createFixture(shape: Shape, density?: number): Fixture;\n  // tslint:disable-next-line:typedef\n  createFixture(shape, fixdef?) {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return null;\n    }\n\n    const fixture = new Fixture(this, shape, fixdef);\n    this._addFixture(fixture);\n    return fixture;\n  }\n\n  /**\n   * Destroy a fixture. This removes the fixture from the broad-phase and destroys\n   * all contacts associated with this fixture. This will automatically adjust the\n   * mass of the body if the body is dynamic and the fixture has positive density.\n   * All fixtures attached to a body are implicitly destroyed when the body is\n   * destroyed.\n   *\n   * Warning: This function is locked during callbacks.\n   *\n   * @param fixture The fixture to be removed.\n   */\n  destroyFixture(fixture: Fixture): void {\n    _ASSERT && console.assert(this.isWorldLocked() == false);\n\n    if (this.isWorldLocked() == true) {\n      return;\n    }\n\n    _ASSERT && console.assert(fixture.m_body == this);\n\n    // Remove the fixture from this body's singly linked list.\n    let found = false;\n    if (this.m_fixtureList === fixture) {\n      this.m_fixtureList = fixture.m_next;\n      found = true;\n\n    } else {\n      let node = this.m_fixtureList;\n      while (node != null) {\n        if (node.m_next === fixture) {\n          node.m_next = fixture.m_next;\n          found = true;\n          break;\n        }\n        node = node.m_next;\n      }\n    }\n\n    // You tried to remove a shape that is not attached to this body.\n    _ASSERT && console.assert(found);\n\n    // Destroy any contacts associated with the fixture.\n    let edge = this.m_contactList;\n    while (edge) {\n      const c = edge.contact;\n      edge = edge.next;\n\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n\n      if (fixture == fixtureA || fixture == fixtureB) {\n        // This destroys the contact and removes it from\n        // this body's contact list.\n        this.m_world.destroyContact(c);\n      }\n    }\n\n    if (this.m_activeFlag) {\n      const broadPhase = this.m_world.m_broadPhase;\n      fixture.destroyProxies(broadPhase);\n    }\n\n    fixture.m_body = null;\n    fixture.m_next = null;\n\n    this.m_world.publish('remove-fixture', fixture);\n\n    // Reset the mass data.\n    this.resetMassData();\n  }\n\n  /**\n   * Get the corresponding world point of a local point.\n   */\n  getWorldPoint(localPoint: Vec2): Vec2 {\n    return Transform.mulVec2(this.m_xf, localPoint);\n  }\n\n  /**\n   * Get the corresponding world vector of a local vector.\n   */\n  getWorldVector(localVector: Vec2): Vec2 {\n    return Rot.mulVec2(this.m_xf.q, localVector);\n  }\n\n  /**\n   * Gets the corresponding local point of a world point.\n   */\n  getLocalPoint(worldPoint: Vec2Value): Vec2 {\n    return Transform.mulTVec2(this.m_xf, worldPoint);\n  }\n\n  /**\n   * Gets the corresponding local vector of a world vector.\n   */\n  getLocalVector(worldVector: Vec2Value): Vec2 {\n    return Rot.mulTVec2(this.m_xf.q, worldVector);\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2 }  from '../common/Vec2';\nimport type { Body }  from './Body';\nimport { TimeStep } from \"./Solver\";\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/**\n * A joint edge is used to connect bodies and joints together in a joint graph\n * where each body is a node and each joint is an edge. A joint edge belongs to\n * a doubly linked list maintained in each attached body. Each joint has two\n * joint nodes, one for each attached body.\n */\nexport class JointEdge {\n  /**\n   * provides quick access to the other body attached.\n   */\n  other: Body | null = null;\n  /**\n   * the joint\n   */\n  joint: Joint | null = null;\n  /**\n   * prev the previous joint edge in the body's joint list\n   */\n  prev: JointEdge | null = null;\n  /**\n   * the next joint edge in the body's joint list\n   */\n  next: JointEdge | null = null;\n}\n\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointOpt {\n  /**\n   * Use this to attach application specific data to your joints.\n   */\n  userData?: any;\n  /**\n   * Set this flag to true if the attached bodies\n   * should collide.\n   */\n  collideConnected?: boolean;\n}\n/**\n * Joint definitions are used to construct joints.\n */\nexport interface JointDef extends JointOpt {\n  /**\n   * The first attached body.\n   */\n  bodyA: Body;\n  /**\n   * The second attached body.\n   */\n  bodyB: Body;\n}\n\n/** @internal */ const DEFAULTS = {\n  userData : null,\n  collideConnected : false\n};\n\n/**\n * The base joint class. Joints are used to constraint two bodies together in\n * various fashions. Some joints also feature limits and motors.\n */\nexport abstract class Joint {\n\n  /** @internal */ m_type: string = 'unknown-joint';\n\n  /** @internal */ m_bodyA: Body;\n  /** @internal */ m_bodyB: Body;\n\n  /** @internal */ m_collideConnected: boolean;\n\n  /** @internal */ m_prev: Joint | null = null;\n  /** @internal */ m_next: Joint | null = null;\n\n  /** @internal */ m_edgeA: JointEdge = new JointEdge();\n  /** @internal */ m_edgeB: JointEdge = new JointEdge();\n\n  /** @internal */ m_islandFlag: boolean = false;\n  /** @internal */ m_userData: unknown;\n\n  constructor(def: JointDef);\n  constructor(def: JointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: JointDef | JointOpt, bodyA?: Body, bodyB?: Body) {\n    bodyA = 'bodyA' in def ? def.bodyA : bodyA;\n    bodyB = 'bodyB' in def ? def.bodyB : bodyB;\n\n    _ASSERT && console.assert(!!bodyA);\n    _ASSERT && console.assert(!!bodyB);\n    _ASSERT && console.assert(bodyA != bodyB);\n\n    this.m_bodyA = bodyA!;\n    this.m_bodyB = bodyB!;\n\n    this.m_collideConnected = !!def.collideConnected;\n    this.m_userData = def.userData;\n  }\n\n  /**\n   * Short-cut function to determine if either body is inactive.\n   */\n  isActive(): boolean {\n    return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n  }\n\n  /**\n   * Get the type of the concrete joint.\n   */\n  getType(): string {\n    return this.m_type;\n  }\n\n  /**\n   * Get the first body attached to this joint.\n   */\n  getBodyA(): Body {\n    return this.m_bodyA;\n  }\n\n  /**\n   * Get the second body attached to this joint.\n   */\n  getBodyB(): Body {\n    return this.m_bodyB;\n  }\n\n  /**\n   * Get the next joint the world joint list.\n   */\n  getNext(): Joint {\n    return this.m_next;\n  }\n\n  getUserData(): unknown {\n    return this.m_userData;\n  }\n\n  setUserData(data: unknown): void {\n    this.m_userData = data;\n  }\n\n  /**\n   * Get collide connected. Note: modifying the collide connect flag won't work\n   * correctly because the flag is only checked when fixture AABBs begin to\n   * overlap.\n   */\n  getCollideConnected(): boolean {\n    return this.m_collideConnected;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  abstract getAnchorA(): Vec2;\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  abstract getAnchorB(): Vec2;\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  abstract getReactionForce(inv_dt: number): Vec2;\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  abstract getReactionTorque(inv_dt: number): number;\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2): void {}\n\n  abstract initVelocityConstraints(step: TimeStep): void;\n\n  abstract solveVelocityConstraints(step: TimeStep): void;\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  abstract solvePositionConstraints(step: TimeStep): boolean;\n\n}\n", "export const stats = {\n  gjkCalls: 0,\n  gjkIters: 0,\n  gjkMaxIters: 0,\n\n  toiTime: 0,\n  toiMaxTime: 0,\n  toiCalls: 0,\n  toiIters: 0,\n  toiMaxIters: 0,\n  toiRootIters: 0,\n  toiMaxRootIters: 0,\n\n  toString(newline?: string): string {\n    newline = typeof newline === 'string' ? newline : '\\n';\n    let string = \"\";\n    // tslint:disable-next-line:no-for-in\n    for (const name in this) {\n      if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {\n        string += name + ': ' + this[name] + newline;\n      }\n    }\n    return string;\n  }\n};\n", "/** @internal */\nexport const now = function(): number {\n  return Date.now();\n};\n\n/** @internal */\nexport const diff = function(time: number): number {\n  return Date.now() - time;\n};\n\n/** @internal */\nexport default {\n  now,\n  diff,\n};\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport { Shape } from './Shape';\nimport { EPSILON } from '../common/Math';\nimport { Vec2, Vec2Value } from '../common/Vec2';\nimport { Rot } from '../common/Rot';\nimport { Transform, TransformValue } from '../common/Transform';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_max = Math.max;\n\n\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const normal = matrix.vec2(0, 0);\n/** @internal */ const e12 = matrix.vec2(0, 0);\n/** @internal */ const e13 = matrix.vec2(0, 0);\n/** @internal */ const e23 = matrix.vec2(0, 0);\n/** @internal */ const temp1 = matrix.vec2(0, 0);\n/** @internal */ const temp2 = matrix.vec2(0, 0);\n\n/**\n * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.\n */\n\nstats.gjkCalls = 0;\nstats.gjkIters = 0;\nstats.gjkMaxIters = 0;\n\n/**\n * Input for Distance. You have to option to use the shape radii in the\n * computation. Even\n */\nexport class DistanceInput {\n  readonly proxyA = new DistanceProxy();\n  readonly proxyB = new DistanceProxy();\n  readonly transformA = Transform.identity();\n  readonly transformB = Transform.identity();\n  useRadii = false;\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.transformA.setIdentity();\n    this.transformB.setIdentity();\n    this.useRadii = false;\n  }\n}\n\n/**\n * Output for Distance.\n */\nexport class DistanceOutput {\n  /** closest point on shapeA */\n  pointA = matrix.vec2(0, 0);\n  /** closest point on shapeB */\n  pointB = matrix.vec2(0, 0);\n  distance = 0;\n  /** iterations number of GJK iterations used */\n  iterations = 0;\n  recycle() {\n    matrix.zeroVec2(this.pointA)\n    matrix.zeroVec2(this.pointB)\n    this.distance = 0;\n    this.iterations = 0;\n  }\n}\n\n/**\n * Used to warm start Distance. Set count to zero on first call.\n */\nexport class SimplexCache {\n  /** length or area */\n  metric: number = 0;\n  /** vertices on shape A */\n  indexA: number[] = [];\n  /** vertices on shape B */\n  indexB: number[] = [];\n  count: number = 0;\n  recycle() {\n    this.metric = 0;\n    this.indexA.length = 0;\n    this.indexB.length = 0;\n    this.count = 0;\n  }\n}\n\n/**\n * Compute the closest points between two shapes. Supports any combination of:\n * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On\n * the first call set SimplexCache.count to zero.\n */\nexport const Distance = function (output: DistanceOutput, cache: SimplexCache, input: DistanceInput): void {\n  ++stats.gjkCalls;\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  // Initialize the simplex.\n  // const simplex = new Simplex();\n  simplex.recycle();\n  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n  const k_maxIters = Settings.maxDistanceIterations;\n\n  // These store the vertices of the last simplex so that we\n  // can check for duplicates and prevent cycling.\n  const saveA = [];\n  const saveB = []; // int[3]\n  let saveCount = 0;\n\n  // Main iteration loop.\n  let iter = 0;\n  while (iter < k_maxIters) {\n    // Copy simplex so we can identify duplicates.\n    saveCount = simplex.m_count;\n    for (let i = 0; i < saveCount; ++i) {\n      saveA[i] = vertices[i].indexA;\n      saveB[i] = vertices[i].indexB;\n    }\n\n    simplex.solve();\n\n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count === 3) {\n      break;\n    }\n\n    // Get search direction.\n    const d = simplex.getSearchDirection();\n\n    // Ensure the search direction is numerically fit.\n    if (matrix.lengthSqrVec2(d) < EPSILON * EPSILON) {\n      // The origin is probably contained by a line segment\n      // or triangle. Thus the shapes are overlapped.\n\n      // We can't return zero here even though there may be overlap.\n      // In case the simplex is a point, segment, or triangle it is difficult\n      // to determine if the origin is contained in the CSO or very close to it.\n      break;\n    }\n\n    // Compute a tentative new simplex vertex using support points.\n    const vertex = vertices[simplex.m_count]; // SimplexVertex\n\n    vertex.indexA = proxyA.getSupport(matrix.invRotVec2(temp, xfA.q, matrix.setMulVec2(temp, -1, d)));\n    matrix.transformVec2(vertex.wA, xfA, proxyA.getVertex(vertex.indexA));\n\n    vertex.indexB = proxyB.getSupport(matrix.invRotVec2(temp, xfB.q, d));\n    matrix.transformVec2(vertex.wB, xfB, proxyB.getVertex(vertex.indexB));\n\n    matrix.diffVec2(vertex.w, vertex.wB, vertex.wA);\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n    ++stats.gjkIters;\n\n    // Check for duplicate support points. This is the main termination\n    // criteria.\n    let duplicate = false;\n    for (let i = 0; i < saveCount; ++i) {\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n        duplicate = true;\n        break;\n      }\n    }\n\n    // If we found a duplicate support point we must exit to avoid cycling.\n    if (duplicate) {\n      break;\n    }\n\n    // New vertex is ok and needed.\n    ++simplex.m_count;\n  }\n\n  stats.gjkMaxIters = math_max(stats.gjkMaxIters, iter);\n\n  // Prepare output.\n  simplex.getWitnessPoints(output.pointA, output.pointB);\n  output.distance = matrix.distVec2(output.pointA, output.pointB);\n  output.iterations = iter;\n\n  // Cache the simplex.\n  simplex.writeCache(cache);\n\n  // Apply radii if requested.\n  if (input.useRadii) {\n    const rA = proxyA.m_radius;\n    const rB = proxyB.m_radius;\n\n    if (output.distance > rA + rB && output.distance > EPSILON) {\n      // Shapes are still no overlapped.\n      // Move the witness points to the outer surface.\n      output.distance -= rA + rB;\n      matrix.diffVec2(normal, output.pointB, output.pointA);\n      matrix.normalizeVec2(normal);\n      matrix.addMulVec2(output.pointA, rA, normal);\n      matrix.subMulVec2(output.pointB, rB, normal);\n    } else {\n      // Shapes are overlapped when radii are considered.\n      // Move the witness points to the middle.\n      const p = matrix.diffVec2(temp, output.pointA, output.pointB);\n      matrix.copyVec2(output.pointA, p);\n      matrix.copyVec2(output.pointB, p);\n      output.distance = 0.0;\n    }\n  }\n}\n\n/**\n * A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n */\nexport class DistanceProxy {\n  /** @internal */ m_vertices: Vec2Value[] = [];\n  // todo: remove this?\n  /** @internal */ m_count = 0;\n  /** @internal */ m_radius = 0;\n\n  recycle() {\n    this.m_vertices.length = 0;\n    this.m_count = 0;\n    this.m_radius = 0;\n  }\n\n  /**\n   * Get the vertex count.\n   */\n  getVertexCount(): number {\n    return this.m_count;\n  }\n\n  /**\n   * Get a vertex by index. Used by Distance.\n   */\n  getVertex(index: number): Vec2Value {\n    _ASSERT && console.assert(0 <= index && index < this.m_count);\n    return this.m_vertices[index];\n  }\n\n  /**\n   * Get the supporting vertex index in the given direction.\n   */\n  getSupport(d: Vec2Value): number {\n    let bestIndex = -1;\n    let bestValue = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const value = matrix.dotVec2(this.m_vertices[i], d);\n      if (value > bestValue) {\n        bestIndex = i;\n        bestValue = value;\n      }\n    }\n    return bestIndex;\n  }\n\n  /**\n   * Get the supporting vertex in the given direction.\n   */\n  getSupportVertex(d: Vec2Value): Vec2Value {\n    return this.m_vertices[this.getSupport(d)];\n  }\n\n  /**\n   * Initialize the proxy using the given shape. The shape must remain in scope\n   * while the proxy is in use.\n   */\n  set(shape: Shape, index: number): void {\n    // TODO remove, use shape instead\n    _ASSERT && console.assert(typeof shape.computeDistanceProxy === 'function');\n    shape.computeDistanceProxy(this, index);\n  }\n\n  /**\n   * Initialize the proxy using a vertex cloud and radius. The vertices\n   * must remain in scope while the proxy is in use.\n   */\n  setVertices(vertices: Vec2Value[], count: number, radius: number) {\n    this.m_vertices = vertices;\n    this.m_count = count;\n    this.m_radius = radius;\n  }\n}\n\nclass SimplexVertex {\n  /** support point in proxyA */\n  wA = matrix.vec2(0, 0);\n  /** wA index */\n  indexA = 0;\n\n  /** support point in proxyB */\n  wB = matrix.vec2(0, 0);\n  /** wB index */\n  indexB = 0;\n\n  /** wB - wA; */\n  w = matrix.vec2(0, 0);\n  /** barycentric coordinate for closest point */\n  a = 0;\n\n  recycle() {\n    this.indexA = 0;\n    this.indexB = 0;\n    matrix.zeroVec2(this.wA)\n    matrix.zeroVec2(this.wB)\n    matrix.zeroVec2(this.w)\n    this.a = 0;\n  }\n  set(v: SimplexVertex): void {\n    this.indexA = v.indexA;\n    this.indexB = v.indexB;\n    matrix.copyVec2(this.wA, v.wA);\n    matrix.copyVec2(this.wB, v.wB);\n    matrix.copyVec2(this.w, v.w);\n    this.a = v.a;\n  }\n}\n\n/** @internal */ const searchDirection_reuse = matrix.vec2(0, 0);\n/** @internal */ const closestPoint_reuse = matrix.vec2(0, 0);  \n\nclass Simplex {\n  m_v1 = new SimplexVertex();\n  m_v2 = new SimplexVertex();\n  m_v3 = new SimplexVertex();\n  m_v = [this.m_v1, this.m_v2, this.m_v3];\n  m_count: number;\n  recycle() {\n    this.m_v1.recycle();\n    this.m_v2.recycle();\n    this.m_v3.recycle();\n    this.m_count = 0;\n  }\n\n  /** @internal */ toString(): string {\n    if (this.m_count === 3) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,\n        this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y\n      ].toString();\n\n    } else if (this.m_count === 2) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,\n        this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y\n      ].toString();\n\n    } else if (this.m_count === 1) {\n      return [\"+\" + this.m_count,\n        this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y\n      ].toString();\n\n    } else {\n      return \"+\" + this.m_count;\n    }\n  }\n\n  readCache(cache: SimplexCache, proxyA: DistanceProxy, transformA: TransformValue, proxyB: DistanceProxy, transformB: TransformValue): void {\n    _ASSERT && console.assert(cache.count <= 3);\n\n    // Copy data from cache.\n    this.m_count = cache.count;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = this.m_v[i];\n      v.indexA = cache.indexA[i];\n      v.indexB = cache.indexB[i];\n      const wALocal = proxyA.getVertex(v.indexA);\n      const wBLocal = proxyB.getVertex(v.indexB);\n      matrix.transformVec2(v.wA, transformA, wALocal);\n      matrix.transformVec2(v.wB, transformB, wBLocal);\n      matrix.diffVec2(v.w,v.wB, v.wA);\n      v.a = 0.0;\n    }\n\n    // Compute the new simplex metric, if it is substantially different than\n    // old metric then flush the simplex.\n    if (this.m_count > 1) {\n      const metric1 = cache.metric;\n      const metric2 = this.getMetric();\n      if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2 || metric2 < EPSILON) {\n        // Reset the simplex.\n        this.m_count = 0;\n      }\n    }\n\n    // If the cache is empty or invalid...\n    if (this.m_count === 0) {\n      const v = this.m_v[0];\n      v.indexA = 0;\n      v.indexB = 0;\n      const wALocal = proxyA.getVertex(0);\n      const wBLocal = proxyB.getVertex(0);\n      matrix.transformVec2(v.wA, transformA, wALocal);\n      matrix.transformVec2(v.wB, transformB, wBLocal);\n      matrix.diffVec2(v.w,v.wB, v.wA);\n      v.a = 1.0;\n      this.m_count = 1;\n    }\n  }\n\n  writeCache(cache: SimplexCache): void {\n    cache.metric = this.getMetric();\n    cache.count = this.m_count;\n    for (let i = 0; i < this.m_count; ++i) {\n      cache.indexA[i] = this.m_v[i].indexA;\n      cache.indexB[i] = this.m_v[i].indexB;\n    }\n  }\n\n  getSearchDirection(): Vec2Value {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 1:\n        return matrix.setVec2(searchDirection_reuse, -v1.w.x, -v1.w.y);\n\n      case 2: {\n        matrix.diffVec2(e12, v2.w, v1.w);\n        const sgn = -matrix.crossVec2Vec2(e12, v1.w);\n        if (sgn > 0.0) {\n          // Origin is left of e12.\n          return matrix.setVec2(searchDirection_reuse, -e12.y, e12.x);\n        } else {\n          // Origin is right of e12.\n          return matrix.setVec2(searchDirection_reuse, e12.y, -e12.x);\n        }\n      }\n\n      default:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(searchDirection_reuse);\n    }\n  }\n\n  getClosestPoint(): Vec2Value {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(closestPoint_reuse);\n\n      case 1:\n        return matrix.copyVec2(closestPoint_reuse, v1.w);\n\n      case 2:\n        return  matrix.combineVec2(closestPoint_reuse, v1.a, v1.w, v2.a, v2.w);\n\n      case 3:\n        return matrix.zeroVec2(closestPoint_reuse);\n\n      default:\n        _ASSERT && console.assert(false);\n        return matrix.zeroVec2(closestPoint_reuse);\n    }\n  }\n\n  getWitnessPoints(pA: Vec2Value, pB: Vec2Value): void {\n    const v1 = this.m_v1;\n    const v2 = this.m_v2;\n    const v3 = this.m_v3;\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        break;\n\n      case 1:\n        matrix.copyVec2(pA, v1.wA);\n        matrix.copyVec2(pB, v1.wB);\n        break;\n\n      case 2:\n        matrix.combineVec2(pA, v1.a, v1.wA, v2.a, v2.wA);\n        matrix.combineVec2(pB, v1.a, v1.wB, v2.a, v2.wB);\n        break;\n\n      case 3:\n        pB.x = pA.x = v1.a * v1.wA.x + v2.a * v2.wA.x + v3.a * v3.wA.x;\n        pB.y = pA.y = v1.a * v1.wA.y + v2.a * v2.wA.y + v3.a * v3.wA.y;\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n        break;\n    }\n  }\n\n  getMetric(): number {\n    switch (this.m_count) {\n      case 0:\n        _ASSERT && console.assert(false);\n        return 0.0;\n\n      case 1:\n        return 0.0;\n\n      case 2:\n        return matrix.distVec2(this.m_v1.w, this.m_v2.w);\n\n      case 3:\n        return matrix.crossVec2Vec2(\n          matrix.diffVec2(temp1, this.m_v2.w, this.m_v1.w),\n          matrix.diffVec2(temp2, this.m_v3.w, this.m_v1.w),\n        );\n\n      default:\n        _ASSERT && console.assert(false);\n        return 0.0;\n    }\n  }\n\n  solve(): void {\n    switch (this.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        this.solve2();\n        break;\n\n      case 3:\n        this.solve3();\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n    }\n  }\n\n// Solve a line segment using barycentric coordinates.\n//\n// p = a1 * w1 + a2 * w2\n// a1 + a2 = 1\n//\n// The vector from the origin to the closest point on the line is\n// perpendicular to the line.\n// e12 = w2 - w1\n// dot(p, e) = 0\n// a1 * dot(w1, e) + a2 * dot(w2, e) = 0\n//\n// 2-by-2 linear system\n// [1 1 ][a1] = [1]\n// [w1.e12 w2.e12][a2] = [0]\n//\n// Define\n// d12_1 = dot(w2, e12)\n// d12_2 = -dot(w1, e12)\n// d12 = d12_1 + d12_2\n//\n// Solution\n// a1 = d12_1 / d12\n// a2 = d12_2 / d12\n  solve2(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    matrix.diffVec2(e12, w2, w1);\n\n    // w1 region\n    const d12_2 = -matrix.dotVec2(w1, e12);\n    if (d12_2 <= 0.0) {\n      // a2 <= 0, so we clamp it to 0\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // w2 region\n    const d12_1 = matrix.dotVec2(w2, e12);\n    if (d12_1 <= 0.0) {\n      // a1 <= 0, so we clamp it to 0\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // Must be in e12 region.\n    const inv_d12 = 1.0 / (d12_1 + d12_2);\n    this.m_v1.a = d12_1 * inv_d12;\n    this.m_v2.a = d12_2 * inv_d12;\n    this.m_count = 2;\n  }\n\n// Possible regions:\n// - points[2]\n// - edge points[0]-points[2]\n// - edge points[1]-points[2]\n// - inside the triangle\n  solve3(): void {\n    const w1 = this.m_v1.w;\n    const w2 = this.m_v2.w;\n    const w3 = this.m_v3.w;\n\n    // Edge12\n    // [1 1 ][a1] = [1]\n    // [w1.e12 w2.e12][a2] = [0]\n    // a3 = 0\n    matrix.diffVec2(e12, w2, w1);\n    const w1e12 = matrix.dotVec2(w1, e12);\n    const w2e12 = matrix.dotVec2(w2, e12);\n    const d12_1 = w2e12;\n    const d12_2 = -w1e12;\n\n    // Edge13\n    // [1 1 ][a1] = [1]\n    // [w1.e13 w3.e13][a3] = [0]\n    // a2 = 0\n    matrix.diffVec2(e13, w3, w1);\n    const w1e13 = matrix.dotVec2(w1, e13);\n    const w3e13 = matrix.dotVec2(w3, e13);\n    const d13_1 = w3e13;\n    const d13_2 = -w1e13;\n\n    // Edge23\n    // [1 1 ][a2] = [1]\n    // [w2.e23 w3.e23][a3] = [0]\n    // a1 = 0\n    matrix.diffVec2(e23, w3, w2);\n    const w2e23 = matrix.dotVec2(w2, e23);\n    const w3e23 = matrix.dotVec2(w3, e23);\n    const d23_1 = w3e23;\n    const d23_2 = -w2e23;\n\n    // Triangle123\n    const n123 = matrix.crossVec2Vec2(e12, e13);\n\n    const d123_1 = n123 * matrix.crossVec2Vec2(w2, w3);\n    const d123_2 = n123 * matrix.crossVec2Vec2(w3, w1);\n    const d123_3 = n123 * matrix.crossVec2Vec2(w1, w2);\n\n    // w1 region\n    if (d12_2 <= 0.0 && d13_2 <= 0.0) {\n      this.m_v1.a = 1.0;\n      this.m_count = 1;\n      return;\n    }\n\n    // e12\n    if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {\n      const inv_d12 = 1.0 / (d12_1 + d12_2);\n      this.m_v1.a = d12_1 * inv_d12;\n      this.m_v2.a = d12_2 * inv_d12;\n      this.m_count = 2;\n      return;\n    }\n\n    // e13\n    if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {\n      const inv_d13 = 1.0 / (d13_1 + d13_2);\n      this.m_v1.a = d13_1 * inv_d13;\n      this.m_v3.a = d13_2 * inv_d13;\n      this.m_count = 2;\n      this.m_v2.set(this.m_v3);\n      return;\n    }\n\n    // w2 region\n    if (d12_1 <= 0.0 && d23_2 <= 0.0) {\n      this.m_v2.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v2);\n      return;\n    }\n\n    // w3 region\n    if (d13_1 <= 0.0 && d23_1 <= 0.0) {\n      this.m_v3.a = 1.0;\n      this.m_count = 1;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // e23\n    if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {\n      const inv_d23 = 1.0 / (d23_1 + d23_2);\n      this.m_v2.a = d23_1 * inv_d23;\n      this.m_v3.a = d23_2 * inv_d23;\n      this.m_count = 2;\n      this.m_v1.set(this.m_v3);\n      return;\n    }\n\n    // Must be in triangle123\n    const inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);\n    this.m_v1.a = d123_1 * inv_d123;\n    this.m_v2.a = d123_2 * inv_d123;\n    this.m_v3.a = d123_3 * inv_d123;\n    this.m_count = 3;\n  }\n}\n\n/** @internal */ const simplex = new Simplex();\n\n/** @internal */ const input = new DistanceInput();\n/** @internal */ const cache = new SimplexCache();\n/** @internal */ const output = new DistanceOutput();\n\n/**\n * Determine if two generic shapes overlap.\n */\nexport const testOverlap = function (shapeA: Shape, indexA: number, shapeB: Shape, indexB: number, xfA: TransformValue, xfB: TransformValue): boolean {\n  input.recycle();\n  input.proxyA.set(shapeA, indexA);\n  input.proxyB.set(shapeB, indexB);\n  matrix.copyTransform(input.transformA, xfA);\n  matrix.copyTransform(input.transformB, xfB);\n  input.useRadii = true;\n\n  output.recycle();\n  cache.recycle();\n\n  Distance(output, cache, input);\n\n  return output.distance < 10.0 * EPSILON;\n}\n\n// legacy exports\nDistance.testOverlap = testOverlap;\nDistance.Input = DistanceInput;\nDistance.Output = DistanceOutput;\nDistance.Proxy = DistanceProxy;\nDistance.Cache = SimplexCache;\n\n/**\n * Input parameters for ShapeCast\n */\nexport class ShapeCastInput {\n  readonly proxyA = new DistanceProxy();\n  readonly proxyB = new DistanceProxy();\n  readonly transformA = Transform.identity();\n  readonly transformB = Transform.identity();\n  readonly translationB = Vec2.zero();\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.transformA.setIdentity();\n    this.transformB.setIdentity();\n    matrix.zeroVec2(this.translationB);\n  }\n}\n\n/**\n * Output results for b2ShapeCast\n */\nexport class ShapeCastOutput {\n  point: Vec2 = Vec2.zero();\n  normal: Vec2 = Vec2.zero();\n  lambda = 1.0;\n  iterations = 0;\n}\n\n/**\n * Perform a linear shape cast of shape B moving and shape A fixed. Determines\n * the hit point, normal, and translation fraction.\n * \n * @returns true if hit, false if there is no hit or an initial overlap\n */\n//\n// GJK-raycast\n// Algorithm by Gino van den Bergen.\n// \"Smooth Mesh Contacts with GJK\" in Game Physics Pearls. 2010\nexport const ShapeCast = function(output: ShapeCastOutput, input: ShapeCastInput): boolean {\n  output.iterations = 0;\n  output.lambda = 1.0;\n  output.normal.setZero();\n  output.point.setZero();\n\n  const proxyA = input.proxyA;\n  const proxyB = input.proxyB;\n\n  const radiusA = math_max(proxyA.m_radius, Settings.polygonRadius);\n  const radiusB = math_max(proxyB.m_radius, Settings.polygonRadius);\n  const radius = radiusA + radiusB;\n\n  const xfA = input.transformA;\n  const xfB = input.transformB;\n\n  const r = input.translationB;\n  const n = Vec2.zero();\n  let lambda = 0.0;\n\n  // Initial simplex\n  const simplex = new Simplex();\n  simplex.m_count = 0;\n\n  // Get simplex vertices as an array.\n  const vertices = simplex.m_v;\n\n  // Get support point in -r direction\n  let indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(r)));\n  let wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));\n  let indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, r));\n  let wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));\n  const v = Vec2.sub(wA, wB);\n\n  // Sigma is the target distance between polygons\n  const sigma = math_max(Settings.polygonRadius, radius - Settings.polygonRadius);\n  const tolerance = 0.5 * Settings.linearSlop;\n\n  // Main iteration loop.\n  const k_maxIters = 20;\n  let iter = 0;\n  while (iter < k_maxIters && v.length() - sigma > tolerance) {\n    _ASSERT && console.assert(simplex.m_count < 3);\n\n    output.iterations += 1;\n\n    // Support in direction -v (A - B)\n    indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(v)));\n    wA = Transform.mulVec2(xfA, proxyA.getVertex(indexA));\n    indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, v));\n    wB = Transform.mulVec2(xfB, proxyB.getVertex(indexB));\n    const p = Vec2.sub(wA, wB);\n\n    // -v is a normal at p\n    v.normalize();\n\n    // Intersect ray with plane\n    const vp = Vec2.dot(v, p);\n    const vr = Vec2.dot(v, r);\n    if (vp - sigma > lambda * vr) {\n      if (vr <= 0.0) {\n        return false;\n      }\n\n      lambda = (vp - sigma) / vr;\n      if (lambda > 1.0) {\n        return false;\n      }\n\n      n.setMul(-1, v);\n      simplex.m_count = 0;\n    }\n\n    // Reverse simplex since it works with B - A.\n    // Shift by lambda * r because we want the closest point to the current clip point.\n    // Note that the support point p is not shifted because we want the plane equation\n    // to be formed in unshifted space.\n    const vertex = vertices[simplex.m_count];\n    vertex.indexA = indexB;\n    vertex.wA = Vec2.combine(1, wB, lambda, r);\n    vertex.indexB = indexA;\n    vertex.wB = wA;\n    vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n    vertex.a = 1.0;\n    simplex.m_count += 1;\n\n    switch (simplex.m_count) {\n      case 1:\n        break;\n\n      case 2:\n        simplex.solve2();\n        break;\n\n      case 3:\n        simplex.solve3();\n        break;\n\n      default:\n        _ASSERT && console.assert(false);\n    }\n    \n    // If we have 3 points, then the origin is in the corresponding triangle.\n    if (simplex.m_count == 3) {\n      // Overlap\n      return false;\n    }\n\n    // Get search direction.\n    v.setVec2(simplex.getClosestPoint());\n\n    // Iteration count is equated to the number of support point calls.\n    ++iter;\n  }\n\n  if (iter == 0) {\n    // Initial overlap\n    return false;\n\t}\n\n  // Prepare output.\n  const pointA = Vec2.zero();\n  const pointB = Vec2.zero();\n  simplex.getWitnessPoints(pointB, pointA);\n\n  if (v.lengthSquared() > 0.0) {\n    n.setMul(-1, v);\n    n.normalize();\n  }\n\n  output.point = Vec2.combine(1, pointA, radiusA, n);\n  output.normal = n;\n  output.lambda = lambda;\n  output.iterations = iter;\n  return true;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { stats } from '../util/stats';\nimport Timer from '../util/Timer';\nimport { Sweep } from '../common/Sweep';\nimport { Transform } from '../common/Transform';\nimport { Distance, DistanceInput, DistanceOutput, DistanceProxy, SimplexCache } from './Distance';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_max = Math.max;\n\n\n/**\n * Input parameters for TimeOfImpact.\n */\nexport class TOIInput {\n  proxyA = new DistanceProxy();\n  proxyB = new DistanceProxy();\n  sweepA = new Sweep();\n  sweepB = new Sweep();\n  /** defines sweep interval [0, tMax] */\n  tMax: number;\n  recycle() {\n    this.proxyA.recycle();\n    this.proxyB.recycle();\n    this.sweepA.recycle();\n    this.sweepB.recycle();\n    this.tMax = -1;\n  }\n}\n\nexport enum TOIOutputState {\n  e_unset = -1,\n  e_unknown = 0,\n  e_failed = 1,\n  e_overlapped = 2,\n  e_touching = 3,\n  e_separated = 4,\n}\n\n/**\n * Output parameters for TimeOfImpact.\n */\nexport class TOIOutput {\n  state = TOIOutputState.e_unset;\n  t = -1;\n  recycle() {\n    this.state = TOIOutputState.e_unset;\n    this.t = -1;\n  }\n}\n\nstats.toiTime = 0;\nstats.toiMaxTime = 0;\nstats.toiCalls = 0;\nstats.toiIters = 0;\nstats.toiMaxIters = 0;\nstats.toiRootIters = 0;\nstats.toiMaxRootIters = 0;\n\n/** @internal */ const distanceInput = new DistanceInput();\n/** @internal */ const distanceOutput = new DistanceOutput();\n// this is passed to Distance and SeparationFunction\n/** @internal */ const cache = new SimplexCache();\n\n/** @internal */ const xfA = matrix.transform(0, 0, 0);\n/** @internal */ const xfB = matrix.transform(0, 0, 0);\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const pointA = matrix.vec2(0, 0);\n/** @internal */ const pointB = matrix.vec2(0, 0);\n/** @internal */ const normal = matrix.vec2(0, 0);\n/** @internal */ const axisA = matrix.vec2(0, 0);\n/** @internal */ const axisB = matrix.vec2(0, 0);\n/** @internal */ const localPointA = matrix.vec2(0, 0);\n/** @internal */ const localPointB = matrix.vec2(0, 0);\n\n\n/**\n * Compute the upper bound on time before two shapes penetrate. Time is\n * represented as a fraction between [0,tMax]. This uses a swept separating axis\n * and may miss some intermediate, non-tunneling collisions. If you change the\n * time interval, you should call this function again.\n *\n * Note: use Distance to compute the contact point and normal at the time of\n * impact.\n *\n * CCD via the local separating axis method. This seeks progression by computing\n * the largest time at which separation is maintained.\n */\nexport const TimeOfImpact = function (output: TOIOutput, input: TOIInput): void {\n  const timer = Timer.now();\n\n  ++stats.toiCalls;\n\n  output.state = TOIOutputState.e_unknown;\n  output.t = input.tMax;\n\n  const proxyA = input.proxyA; // DistanceProxy\n  const proxyB = input.proxyB; // DistanceProxy\n\n  const sweepA = input.sweepA; // Sweep\n  const sweepB = input.sweepB; // Sweep\n\n  // Large rotations can make the root finder fail, so we normalize the\n  // sweep angles.\n  sweepA.normalize();\n  sweepB.normalize();\n\n  const tMax = input.tMax;\n\n  const totalRadius = proxyA.m_radius + proxyB.m_radius;\n  const target = math_max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);\n  const tolerance = 0.25 * Settings.linearSlop;\n  _ASSERT && console.assert(target > tolerance);\n\n  let t1 = 0.0;\n  const k_maxIterations = Settings.maxTOIIterations;\n  let iter = 0;\n\n  // Prepare input for distance query.\n  // const cache = new SimplexCache();\n  cache.recycle();\n\n  distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);\n  distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);\n  distanceInput.useRadii = false;\n\n  // The outer loop progressively attempts to compute new separating axes.\n  // This loop terminates when an axis is repeated (no progress is made).\n  while (true) {\n    sweepA.getTransform(xfA, t1);\n    sweepB.getTransform(xfB, t1);\n\n    // Get the distance between shapes. We can also use the results\n    // to get a separating axis.\n    matrix.copyTransform(distanceInput.transformA, xfA);\n    matrix.copyTransform(distanceInput.transformB, xfB);\n    Distance(distanceOutput, cache, distanceInput);\n\n    // If the shapes are overlapped, we give up on continuous collision.\n    if (distanceOutput.distance <= 0.0) {\n      // Failure!\n      output.state = TOIOutputState.e_overlapped;\n      output.t = 0.0;\n      break;\n    }\n\n    if (distanceOutput.distance < target + tolerance) {\n      // Victory!\n      output.state = TOIOutputState.e_touching;\n      output.t = t1;\n      break;\n    }\n\n    // Initialize the separating axis.\n    separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n\n    // if (false) {\n    //   // Dump the curve seen by the root finder\n    //   const N = 100;\n    //   const dx = 1.0 / N;\n    //   const xs = []; // [ N + 1 ];\n    //   const fs = []; // [ N + 1 ];\n    //   const x = 0.0;\n    //   for (const i = 0; i <= N; ++i) {\n    //     sweepA.getTransform(xfA, x);\n    //     sweepB.getTransform(xfB, x);\n    //     const f = fcn.evaluate(xfA, xfB) - target;\n    //     printf(\"%g %g\\n\", x, f);\n    //     xs[i] = x;\n    //     fs[i] = f;\n    //     x += dx;\n    //   }\n    // }\n\n    // Compute the TOI on the separating axis. We do this by successively\n    // resolving the deepest point. This loop is bounded by the number of\n    // vertices.\n    let done = false;\n    let t2 = tMax;\n    let pushBackIter = 0;\n    while (true) {\n      // Find the deepest point at t2. Store the witness point indices.\n      let s2 = separationFunction.findMinSeparation(t2);\n\n      // Is the final configuration separated?\n      if (s2 > target + tolerance) {\n        // Victory!\n        output.state = TOIOutputState.e_separated;\n        output.t = tMax;\n        done = true;\n        break;\n      }\n\n      // Has the separation reached tolerance?\n      if (s2 > target - tolerance) {\n        // Advance the sweeps\n        t1 = t2;\n        break;\n      }\n\n      // Compute the initial separation of the witness points.\n      let s1 = separationFunction.evaluate(t1);\n\n      // Check for initial overlap. This might happen if the root finder\n      // runs out of iterations.\n      if (s1 < target - tolerance) {\n        output.state = TOIOutputState.e_failed;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Check for touching\n      if (s1 <= target + tolerance) {\n        // Victory! t1 should hold the TOI (could be 0.0).\n        output.state = TOIOutputState.e_touching;\n        output.t = t1;\n        done = true;\n        break;\n      }\n\n      // Compute 1D root of: f(x) - target = 0\n      let rootIterCount = 0;\n      let a1 = t1;\n      let a2 = t2;\n      while (true) {\n        // Use a mix of the secant rule and bisection.\n        let t;\n        if (rootIterCount & 1) {\n          // Secant rule to improve convergence.\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n        } else {\n          // Bisection to guarantee progress.\n          t = 0.5 * (a1 + a2);\n        }\n\n        ++rootIterCount;\n        ++stats.toiRootIters;\n\n        const s = separationFunction.evaluate(t);\n\n        if (math_abs(s - target) < tolerance) {\n          // t2 holds a tentative value for t1\n          t2 = t;\n          break;\n        }\n\n        // Ensure we continue to bracket the root.\n        if (s > target) {\n          a1 = t;\n          s1 = s;\n        } else {\n          a2 = t;\n          s2 = s;\n        }\n\n        if (rootIterCount === 50) {\n          break;\n        }\n      }\n\n      stats.toiMaxRootIters = math_max(stats.toiMaxRootIters, rootIterCount);\n\n      ++pushBackIter;\n\n      if (pushBackIter === Settings.maxPolygonVertices) {\n        break;\n      }\n    }\n\n    ++iter;\n    ++stats.toiIters;\n\n    if (done) {\n      break;\n    }\n\n    if (iter === k_maxIterations) {\n      // Root finder got stuck. Semi-victory.\n      output.state = TOIOutputState.e_failed;\n      output.t = t1;\n      break;\n    }\n  }\n\n  stats.toiMaxIters = math_max(stats.toiMaxIters, iter);\n\n  const time = Timer.diff(timer);\n  stats.toiMaxTime = math_max(stats.toiMaxTime, time);\n  stats.toiTime += time;\n\n  separationFunction.recycle();\n}\n\nenum SeparationFunctionType {\n  e_unset = -1,\n  e_points = 1,\n  e_faceA = 2,\n  e_faceB = 3,\n}\n\nclass SeparationFunction {\n  // input cache\n  // todo: maybe assign by copy instead of reference?\n  m_proxyA: DistanceProxy = null;\n  m_proxyB: DistanceProxy = null;\n  m_sweepA: Sweep = null;\n  m_sweepB: Sweep = null;\n\n  // initialize cache\n  m_type = SeparationFunctionType.e_unset;\n  m_localPoint = matrix.vec2(0, 0);\n  m_axis = matrix.vec2(0, 0);\n\n  // compute output\n  indexA = -1;\n  indexB = -1;\n\n  recycle() {\n    this.m_proxyA = null;\n    this.m_proxyB = null;\n    this.m_sweepA = null;\n    this.m_sweepB = null;\n\n    this.m_type = SeparationFunctionType.e_unset;\n    matrix.zeroVec2(this.m_localPoint)\n    matrix.zeroVec2(this.m_axis)\n\n    this.indexA = -1;\n    this.indexB = -1;\n  }\n\n  // TODO_ERIN might not need to return the separation\n\n  initialize(cache: SimplexCache, proxyA: DistanceProxy, sweepA: Sweep, proxyB: DistanceProxy, sweepB: Sweep, t1: number): number {\n    const count = cache.count;\n    _ASSERT && console.assert(0 < count && count < 3);\n\n    this.m_proxyA = proxyA;\n    this.m_proxyB = proxyB;\n    this.m_sweepA = sweepA;\n    this.m_sweepB = sweepB;\n\n    this.m_sweepA.getTransform(xfA, t1);\n    this.m_sweepB.getTransform(xfB, t1);\n\n    if (count === 1) {\n      this.m_type = SeparationFunctionType.e_points;\n      const localPointA = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      matrix.transformVec2(pointA, xfA, localPointA);\n      matrix.transformVec2(pointB, xfB, localPointB);\n      matrix.diffVec2(this.m_axis, pointB, pointA);\n      const s = matrix.normalizeVec2Length(this.m_axis);\n      return s;\n\n    } else if (cache.indexA[0] === cache.indexA[1]) {\n      // Two points on B and one on A.\n      this.m_type = SeparationFunctionType.e_faceB;\n      const localPointB1 = proxyB.getVertex(cache.indexB[0]);\n      const localPointB2 = proxyB.getVertex(cache.indexB[1]);\n\n      matrix.crossVec2Num(this.m_axis, matrix.diffVec2(temp, localPointB2, localPointB1), 1.0);\n      matrix.normalizeVec2(this.m_axis);\n      matrix.rotVec2(normal, xfB.q, this.m_axis);\n\n      matrix.combineVec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);\n      matrix.transformVec2(pointB, xfB, this.m_localPoint);\n\n      const localPointA = proxyA.getVertex(cache.indexA[0]);\n      const pointA = Transform.mulVec2(xfA, localPointA);\n\n      let s = matrix.dotVec2(pointA, normal) - matrix.dotVec2(pointB, normal);\n      if (s < 0.0) {\n        matrix.negVec2(this.m_axis);\n        s = -s;\n      }\n      return s;\n\n    } else {\n      // Two points on A and one or two points on B.\n      this.m_type = SeparationFunctionType.e_faceA;\n      const localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);\n      const localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);\n\n      matrix.crossVec2Num(this.m_axis, matrix.diffVec2(temp, localPointA2, localPointA1), 1.0);\n      matrix.normalizeVec2(this.m_axis);\n      matrix.rotVec2(normal, xfA.q, this.m_axis);\n\n      matrix.combineVec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);\n      matrix.transformVec2(pointA, xfA, this.m_localPoint);\n\n      const localPointB = this.m_proxyB.getVertex(cache.indexB[0]);\n      matrix.transformVec2(pointB, xfB, localPointB);\n\n      let s = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal);\n      if (s < 0.0) {\n        matrix.negVec2(this.m_axis);\n        s = -s;\n      }\n      return s;\n    }\n  }\n\n  compute(find: boolean, t: number): number {\n    // It was findMinSeparation and evaluate\n    this.m_sweepA.getTransform(xfA, t);\n    this.m_sweepB.getTransform(xfB, t);\n\n    switch (this.m_type) {\n      case SeparationFunctionType.e_points: {\n        if (find) {\n          matrix.invRotVec2(axisA, xfA.q, this.m_axis);\n          matrix.invRotVec2(axisB, xfB.q, matrix.setMulVec2(temp, -1, this.m_axis));\n\n          this.indexA = this.m_proxyA.getSupport(axisA);\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        matrix.copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n        matrix.copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n\n        matrix.transformVec2(pointA, xfA, localPointA);\n        matrix.transformVec2(pointB, xfB, localPointB);\n\n        const sep = matrix.dotVec2(pointB, this.m_axis) - matrix.dotVec2(pointA, this.m_axis);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceA: {\n        matrix.rotVec2(normal, xfA.q, this.m_axis);\n        matrix.transformVec2(pointA, xfA, this.m_localPoint);\n\n        if (find) {\n          matrix.invRotVec2(axisB, xfB.q, matrix.setMulVec2(temp, -1, normal));\n\n          this.indexA = -1;\n          this.indexB = this.m_proxyB.getSupport(axisB);\n        }\n\n        matrix.copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n        matrix.transformVec2(pointB, xfB, localPointB);\n\n        const sep = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal);\n        return sep;\n      }\n\n      case SeparationFunctionType.e_faceB: {\n        matrix.rotVec2(normal, xfB.q, this.m_axis);\n        matrix.transformVec2(pointB, xfB, this.m_localPoint);\n\n        if (find) {\n          matrix.invRotVec2(axisA, xfA.q, matrix.setMulVec2(temp, -1, normal));\n\n          this.indexB = -1;\n          this.indexA = this.m_proxyA.getSupport(axisA);\n        }\n\n        matrix.copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n        matrix.transformVec2(pointA, xfA, localPointA);\n\n        const sep = matrix.dotVec2(pointA, normal) - matrix.dotVec2(pointB, normal);\n        return sep;\n      }\n\n      default:\n        _ASSERT && console.assert(false);\n        if (find) {\n          this.indexA = -1;\n          this.indexB = -1;\n        }\n        return 0.0;\n    }\n  }\n\n  findMinSeparation(t: number): number {\n    return this.compute(true, t);\n  }\n\n  evaluate(t: number): number {\n    return this.compute(false, t);\n  }\n}\n\n/** @internal */ const separationFunction = new SeparationFunction();\n\n// legacy exports\nTimeOfImpact.Input = TOIInput;\nTimeOfImpact.Output = TOIOutput;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { EPSILON } from '../common/Math';\nimport { Body } from './Body';\nimport type { Contact } from './Contact';\nimport { Joint } from './Joint';\nimport { TimeOfImpact, TOIInput, TOIOutput, TOIOutputState } from '../collision/TimeOfImpact';\nimport { Distance, DistanceInput, DistanceOutput, SimplexCache } from '../collision/Distance';\nimport { World } from \"./World\";\nimport { Sweep } from '../common/Sweep';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_sqrt = Math.sqrt;\n/** @internal */ const math_min = Math.min;\n\n\nexport class TimeStep {\n  /** time step */\n  dt: number = 0;\n  /** inverse time step (0 if dt == 0) */\n  inv_dt: number = 0;\n  velocityIterations: number = 0;\n  positionIterations: number = 0;\n  warmStarting: boolean = false;\n  blockSolve: boolean = true;\n\n  /** timestep ratio for variable timestep */\n  inv_dt0: number = 0.0;\n  /** dt * inv_dt0 */\n  dtRatio: number = 1;\n\n  reset(dt: number): void {\n    if (this.dt > 0.0) {\n      this.inv_dt0 = this.inv_dt;\n    }\n    this.dt = dt;\n    this.inv_dt = dt == 0 ? 0 : 1 / dt;\n    this.dtRatio = dt * this.inv_dt0;\n  }\n}\n\n// reuse\n/** @internal */ const s_subStep = new TimeStep();\n/** @internal */ const c = matrix.vec2(0, 0);\n/** @internal */ const v = matrix.vec2(0, 0);\n/** @internal */ const translation = matrix.vec2(0, 0);\n/** @internal */ const input = new TOIInput();\n/** @internal */ const output = new TOIOutput();\n/** @internal */ const backup = new Sweep();\n/** @internal */ const backup1 = new Sweep();\n/** @internal */ const backup2 = new Sweep();\n\n/**\n * Contact impulses for reporting. Impulses are used instead of forces because\n * sub-step forces may approach infinity for rigid body collisions. These match\n * up one-to-one with the contact points in Manifold.\n */\nexport class ContactImpulse {\n  // TODO: merge with Contact class?\n\n  private readonly contact: Contact;\n  private readonly normals: number[];\n  private readonly tangents: number[];\n\n  constructor(contact: Contact) {\n    this.contact = contact;\n    this.normals = [];\n    this.tangents = [];\n  }\n\n  recycle() {\n    this.normals.length = 0;\n    this.tangents.length = 0;\n  }\n\n  get normalImpulses(): number[] {\n    const contact = this.contact;\n    const normals = this.normals;\n    normals.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      normals.push(contact.v_points[p].normalImpulse);\n    }\n    return normals;\n  }\n\n  get tangentImpulses(): number[] {\n    const contact = this.contact;\n    const tangents = this.tangents;\n    tangents.length = 0;\n    for (let p = 0; p < contact.v_points.length; ++p) {\n      tangents.push(contact.v_points[p].tangentImpulse);\n    }\n    return tangents;\n  }\n}\n\n/**\n * Finds and solves islands. An island is a connected subset of the world.\n */\nexport class Solver {\n  m_world: World;\n  m_stack: Body[];\n  m_bodies: Body[];\n  m_contacts: Contact[];\n  m_joints: Joint[];\n\n  constructor(world: World) {\n    this.m_world = world;\n    this.m_stack = [];\n    this.m_bodies = [];\n    this.m_contacts = [];\n    this.m_joints = [];\n  }\n\n  clear(): void {\n    this.m_stack.length = 0;\n    this.m_bodies.length = 0;\n    this.m_contacts.length = 0;\n    this.m_joints.length = 0;\n  }\n\n  addBody(body: Body): void {\n    _ASSERT && console.assert(body instanceof Body, 'Not a Body!', body);\n    this.m_bodies.push(body);\n    // why?\n    // body.c_position.c.setZero();\n    // body.c_position.a = 0;\n    // body.c_velocity.v.setZero();\n    // body.c_velocity.w = 0;\n  }\n\n  addContact(contact: Contact): void {\n    // _ASSERT && console.assert(contact instanceof Contact, 'Not a Contact!', contact);\n    this.m_contacts.push(contact);\n  }\n\n  addJoint(joint: Joint): void {\n    _ASSERT && console.assert(joint instanceof Joint, 'Not a Joint!', joint);\n    this.m_joints.push(joint);\n  }\n\n  solveWorld(step: TimeStep): void {\n    const world = this.m_world;\n\n    // Clear all the island flags.\n    for (let b = world.m_bodyList; b; b = b.m_next) {\n      b.m_islandFlag = false;\n    }\n    for (let c = world.m_contactList; c; c = c.m_next) {\n      c.m_islandFlag = false;\n    }\n    for (let j = world.m_jointList; j; j = j.m_next) {\n      j.m_islandFlag = false;\n    }\n\n    // Build and simulate all awake islands.\n    const stack = this.m_stack;\n    let loop = -1;\n    for (let seed = world.m_bodyList; seed; seed = seed.m_next) {\n      loop++;\n      if (seed.m_islandFlag) {\n        continue;\n      }\n\n      if (seed.isAwake() == false || seed.isActive() == false) {\n        continue;\n      }\n\n      // The seed can be dynamic or kinematic.\n      if (seed.isStatic()) {\n        continue;\n      }\n\n      // Reset island and stack.\n      this.clear();\n\n      stack.push(seed);\n\n      seed.m_islandFlag = true;\n\n      // Perform a depth first search (DFS) on the constraint graph.\n      while (stack.length > 0) {\n        // Grab the next body off the stack and add it to the island.\n        const b = stack.pop();\n        _ASSERT && console.assert(b.isActive() == true);\n        this.addBody(b);\n\n        // Make sure the body is awake (without resetting sleep timer).\n        b.m_awakeFlag = true;\n\n        // To keep islands as small as possible, we don't\n        // propagate islands across static bodies.\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Search all contacts connected to this body.\n        for (let ce = b.m_contactList; ce; ce = ce.next) {\n          const contact = ce.contact;\n\n          // Has this contact already been added to an island?\n          if (contact.m_islandFlag) {\n            continue;\n          }\n\n          // Is this contact solid and touching?\n          if (contact.isEnabled() == false || contact.isTouching() == false) {\n            continue;\n          }\n\n          // Skip sensors.\n          const sensorA = contact.m_fixtureA.m_isSensor;\n          const sensorB = contact.m_fixtureB.m_isSensor;\n          if (sensorA || sensorB) {\n            continue;\n          }\n\n          this.addContact(contact);\n          contact.m_islandFlag = true;\n\n          const other = ce.other;\n\n          // Was the other body already added to this island?\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && console.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n\n        // Search all joints connect to this body.\n        for (let je = b.m_jointList; je; je = je.next) {\n          if (je.joint.m_islandFlag == true) {\n            continue;\n          }\n\n          const other = je.other;\n\n          // Don't simulate joints connected to inactive bodies.\n          if (other.isActive() == false) {\n            continue;\n          }\n\n          this.addJoint(je.joint);\n          je.joint.m_islandFlag = true;\n\n          if (other.m_islandFlag) {\n            continue;\n          }\n\n          // _ASSERT && console.assert(stack.length < world.m_bodyCount);\n          stack.push(other);\n          other.m_islandFlag = true;\n        }\n      }\n\n      this.solveIsland(step);\n\n      // Post solve cleanup.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        // Allow static bodies to participate in other islands.\n        // TODO: are they added at all?\n        const b = this.m_bodies[i];\n        if (b.isStatic()) {\n          b.m_islandFlag = false;\n        }\n      }\n    }\n  }\n\n  solveIsland(step: TimeStep): void {\n    // B2: Island Solve\n    const world = this.m_world;\n    const gravity = world.m_gravity;\n    const allowSleep = world.m_allowSleep;\n\n    const h = step.dt;\n\n    // Integrate velocities and apply damping. Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.m_sweep.c);\n      const a = body.m_sweep.a;\n      matrix.copyVec2(v, body.m_linearVelocity);\n      let w = body.m_angularVelocity;\n\n      // Store positions for continuous collision.\n      matrix.copyVec2(body.m_sweep.c0, body.m_sweep.c);\n      body.m_sweep.a0 = body.m_sweep.a;\n\n      if (body.isDynamic()) {\n        // Integrate velocities.\n        matrix.addMulVec2(v, h * body.m_gravityScale, gravity);\n        matrix.addMulVec2(v, h * body.m_invMass, body.m_force);\n        w += h * body.m_invI * body.m_torque;\n        /**\n         * <pre>\n         * Apply damping.\n         * ODE: dv/dt + c * v = 0\n         * Solution: v(t) = v0 * exp(-c * t)\n         * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)\n         * v2 = exp(-c * dt) * v1\n         * Pade approximation:\n         * v2 = v1 * 1 / (1 + c * dt)\n         * </pre>\n         */\n        matrix.setMulVec2(v, 1.0 / (1.0 + h * body.m_linearDamping), v)\n        w *= 1.0 / (1.0 + h * body.m_angularDamping);\n      }\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(step);\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(step);\n    }\n\n    if (step.warmStarting) {\n      // Warm start.\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const contact = this.m_contacts[i];\n        contact.warmStartConstraint(step);\n      }\n    }\n\n    for (let i = 0; i < this.m_joints.length; ++i) {\n      const joint = this.m_joints[i];\n      joint.initVelocityConstraints(step);\n    }\n\n    // Solve velocity constraints\n    for (let i = 0; i < step.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        joint.solveVelocityConstraints(step);\n      }\n\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(step);\n      }\n    }\n\n    // Store impulses for warm starting\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.storeConstraintImpulses(step);\n    }\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.c_position.c);\n      let a = body.c_position.a;\n      matrix.copyVec2(v, body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      matrix.setMulVec2(translation, h, v);\n      const translationLengthSqr = matrix.lengthSqrVec2(translation);\n      if (translationLengthSqr > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / math_sqrt(translationLengthSqr);\n        matrix.scaleVec2(v, ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / math_abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      matrix.addMulVec2(c, h, v);\n      a += h * w;\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n    }\n\n    // Solve position constraints\n    let positionSolved = false;\n    for (let i = 0; i < step.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraint(step);\n        minSeparation = math_min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;\n\n      let jointsOkay = true;\n      for (let j = 0; j < this.m_joints.length; ++j) {\n        const joint = this.m_joints[j];\n        const jointOkay = joint.solvePositionConstraints(step);\n        jointsOkay = jointsOkay && jointOkay;\n      }\n\n      if (contactsOkay && jointsOkay) {\n        // Exit early if the position errors are small.\n        positionSolved = true;\n        break;\n      }\n    }\n\n    // Copy state buffers back to the bodies\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(body.m_sweep.c, body.c_position.c);\n      body.m_sweep.a = body.c_position.a;\n      matrix.copyVec2(body.m_linearVelocity, body.c_velocity.v);\n      body.m_angularVelocity = body.c_velocity.w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n\n    if (allowSleep) {\n      let minSleepTime = Infinity;\n\n      const linTolSqr = Settings.linearSleepToleranceSqr;\n      const angTolSqr = Settings.angularSleepToleranceSqr;\n\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        if (body.isStatic()) {\n          continue;\n        }\n\n        if ((body.m_autoSleepFlag == false)\n          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)\n          || (matrix.lengthSqrVec2(body.m_linearVelocity) > linTolSqr)) {\n          body.m_sleepTime = 0.0;\n          minSleepTime = 0.0;\n        } else {\n          body.m_sleepTime += h;\n          minSleepTime = math_min(minSleepTime, body.m_sleepTime);\n        }\n      }\n\n      if (minSleepTime >= Settings.timeToSleep && positionSolved) {\n        for (let i = 0; i < this.m_bodies.length; ++i) {\n          const body = this.m_bodies[i];\n          body.setAwake(false);\n        }\n      }\n    }\n  }\n\n  /**\n   * Find TOI contacts and solve them.\n   */\n  solveWorldTOI(step: TimeStep): void {\n    const world = this.m_world;\n\n    if (world.m_stepComplete) {\n      for (let b = world.m_bodyList; b; b = b.m_next) {\n        b.m_islandFlag = false;\n        b.m_sweep.alpha0 = 0.0;\n      }\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Invalidate TOI\n        c.m_toiFlag = false;\n        c.m_islandFlag = false;\n        c.m_toiCount = 0;\n        c.m_toi = 1.0;\n      }\n    }\n\n    // Find TOI events and solve them.\n    while (true) {\n      // Find the first TOI.\n      let minContact: Contact | null = null;\n      let minAlpha = 1.0;\n\n      for (let c = world.m_contactList; c; c = c.m_next) {\n        // Is this contact disabled?\n        if (c.isEnabled() == false) {\n          continue;\n        }\n\n        // Prevent excessive sub-stepping.\n        if (c.m_toiCount > Settings.maxSubSteps) {\n          continue;\n        }\n\n        let alpha = 1.0;\n        if (c.m_toiFlag) {\n          // This contact has a valid cached TOI.\n          alpha = c.m_toi;\n        } else {\n          const fA = c.getFixtureA();\n          const fB = c.getFixtureB();\n\n          // Is there a sensor?\n          if (fA.isSensor() || fB.isSensor()) {\n            continue;\n          }\n\n          const bA = fA.getBody();\n          const bB = fB.getBody();\n\n          _ASSERT && console.assert(bA.isDynamic() || bB.isDynamic());\n\n          const activeA = bA.isAwake() && !bA.isStatic();\n          const activeB = bB.isAwake() && !bB.isStatic();\n\n          // Is at least one body active (awake and dynamic or kinematic)?\n          if (activeA == false && activeB == false) {\n            continue;\n          }\n\n          const collideA = bA.isBullet() || !bA.isDynamic();\n          const collideB = bB.isBullet() || !bB.isDynamic();\n\n          // Are these two non-bullet dynamic bodies?\n          if (collideA == false && collideB == false) {\n            continue;\n          }\n\n          // Compute the TOI for this contact.\n          // Put the sweeps onto the same time interval.\n          let alpha0 = bA.m_sweep.alpha0;\n\n          if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {\n            alpha0 = bB.m_sweep.alpha0;\n            bA.m_sweep.advance(alpha0);\n          } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {\n            alpha0 = bA.m_sweep.alpha0;\n            bB.m_sweep.advance(alpha0);\n          }\n\n          _ASSERT && console.assert(alpha0 < 1.0);\n\n          const indexA = c.getChildIndexA();\n          const indexB = c.getChildIndexB();\n\n          const sweepA = bA.m_sweep;\n          const sweepB = bB.m_sweep;\n\n          // Compute the time of impact in interval [0, minTOI]\n          input.proxyA.set(fA.getShape(), indexA);\n          input.proxyB.set(fB.getShape(), indexB);\n          input.sweepA.set(bA.m_sweep);\n          input.sweepB.set(bB.m_sweep);\n          input.tMax = 1.0;\n\n          TimeOfImpact(output, input);\n\n          // Beta is the fraction of the remaining portion of the [time?].\n          const beta = output.t;\n          if (output.state == TOIOutputState.e_touching) {\n            alpha = math_min(alpha0 + (1.0 - alpha0) * beta, 1.0);\n          } else {\n            alpha = 1.0;\n          }\n\n          c.m_toi = alpha;\n          c.m_toiFlag = true;\n        }\n\n        if (alpha < minAlpha) {\n          // This is the minimum TOI found so far.\n          minContact = c;\n          minAlpha = alpha;\n        }\n      }\n\n      if (minContact == null || 1.0 - 10.0 * EPSILON < minAlpha) {\n        // No more TOI events. Done!\n        world.m_stepComplete = true;\n        break;\n      }\n\n      // Advance the bodies to the TOI.\n      const fA = minContact.getFixtureA();\n      const fB = minContact.getFixtureB();\n      const bA = fA.getBody();\n      const bB = fB.getBody();\n\n      backup1.set(bA.m_sweep);\n      backup2.set(bB.m_sweep);\n\n      bA.advance(minAlpha);\n      bB.advance(minAlpha);\n\n      // The TOI contact likely has some new contact points.\n      minContact.update(world);\n      minContact.m_toiFlag = false;\n      ++minContact.m_toiCount;\n\n      // Is the contact solid?\n      if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n        // Restore the sweeps.\n        minContact.setEnabled(false);\n        bA.m_sweep.set(backup1);\n        bB.m_sweep.set(backup2);\n        bA.synchronizeTransform();\n        bB.synchronizeTransform();\n        continue;\n      }\n\n      bA.setAwake(true);\n      bB.setAwake(true);\n\n      // Build the island\n      this.clear();\n      this.addBody(bA);\n      this.addBody(bB);\n      this.addContact(minContact);\n\n      bA.m_islandFlag = true;\n      bB.m_islandFlag = true;\n      minContact.m_islandFlag = true;\n\n      // Get contacts on bodyA and bodyB.\n      const bodies = [ bA, bB ];\n      for (let i = 0; i < bodies.length; ++i) {\n        const body = bodies[i];\n        if (body.isDynamic()) {\n          for (let ce = body.m_contactList; ce; ce = ce.next) {\n            // if (this.m_bodyCount == this.m_bodyCapacity) { break; }\n            // if (this.m_contactCount == this.m_contactCapacity) { break; }\n\n            const contact = ce.contact;\n\n            // Has this contact already been added to the island?\n            if (contact.m_islandFlag) {\n              continue;\n            }\n\n            // Only add if either is static, kinematic or bullet.\n            const other = ce.other;\n            if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n              continue;\n            }\n\n            // Skip sensors.\n            const sensorA = contact.m_fixtureA.m_isSensor;\n            const sensorB = contact.m_fixtureB.m_isSensor;\n            if (sensorA || sensorB) {\n              continue;\n            }\n\n            // Tentatively advance the body to the TOI.\n            backup.set(other.m_sweep);\n            if (other.m_islandFlag == false) {\n              other.advance(minAlpha);\n            }\n\n            // Update the contact points\n            contact.update(world);\n\n            // Was the contact disabled by the user?\n            // Are there contact points?\n            if (contact.isEnabled() == false || contact.isTouching() == false) {\n              other.m_sweep.set(backup);\n              other.synchronizeTransform();\n              continue;\n            }\n\n            // Add the contact to the island\n            contact.m_islandFlag = true;\n            this.addContact(contact);\n\n            // Has the other body already been added to the island?\n            if (other.m_islandFlag) {\n              continue;\n            }\n\n            // Add the other body to the island.\n            other.m_islandFlag = true;\n\n            if (!other.isStatic()) {\n              other.setAwake(true);\n            }\n\n            this.addBody(other);\n          }\n        }\n      }\n\n      s_subStep.reset((1.0 - minAlpha) * step.dt);\n      s_subStep.dtRatio = 1.0;\n      s_subStep.positionIterations = 20;\n      s_subStep.velocityIterations = step.velocityIterations;\n      s_subStep.warmStarting = false;\n\n      this.solveIslandTOI(s_subStep, bA, bB);\n\n      // Reset island flags and synchronize broad-phase proxies.\n      for (let i = 0; i < this.m_bodies.length; ++i) {\n        const body = this.m_bodies[i];\n        body.m_islandFlag = false;\n\n        if (!body.isDynamic()) {\n          continue;\n        }\n\n        body.synchronizeFixtures();\n\n        // Invalidate all contact TOIs on this displaced body.\n        for (let ce = body.m_contactList; ce; ce = ce.next) {\n          ce.contact.m_toiFlag = false;\n          ce.contact.m_islandFlag = false;\n        }\n      }\n\n      // Commit fixture proxy movements to the broad-phase so that new contacts\n      // are created.\n      // Also, some contacts can be destroyed.\n      world.findNewContacts();\n\n      if (world.m_subStepping) {\n        world.m_stepComplete = false;\n        break;\n      }\n    }\n  }\n\n  solveIslandTOI(subStep: TimeStep, toiA: Body, toiB: Body): void {\n\n    // Initialize the body state.\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n      matrix.copyVec2(body.c_position.c, body.m_sweep.c);\n      body.c_position.a = body.m_sweep.a;\n      matrix.copyVec2(body.c_velocity.v, body.m_linearVelocity);\n      body.c_velocity.w = body.m_angularVelocity;\n    }\n\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initConstraint(subStep);\n    }\n\n    // Solve position constraints.\n    for (let i = 0; i < subStep.positionIterations; ++i) {\n      let minSeparation = 0.0;\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        const separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n        minSeparation = math_min(minSeparation, separation);\n      }\n      // We can't expect minSpeparation >= -Settings.linearSlop because we don't\n      // push the separation above -Settings.linearSlop.\n      const contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;\n      if (contactsOkay) {\n        break;\n      }\n    }\n\n    if (false) {\n      // Is the new position really safe?\n      for (let i = 0; i < this.m_contacts.length; ++i) {\n        const c = this.m_contacts[i];\n        const fA = c.getFixtureA();\n        const fB = c.getFixtureB();\n\n        const bA = fA.getBody();\n        const bB = fB.getBody();\n\n        const indexA = c.getChildIndexA();\n        const indexB = c.getChildIndexB();\n\n        const input = new DistanceInput();\n        input.proxyA.set(fA.getShape(), indexA);\n        input.proxyB.set(fB.getShape(), indexB);\n        input.transformA.set(bA.getTransform());\n        input.transformB.set(bB.getTransform());\n        input.useRadii = false;\n\n        const output = new DistanceOutput();\n        const cache = new SimplexCache();\n        Distance(output, cache, input);\n\n        if (output.distance == 0 || cache.count == 3) {\n          cache.count += 0;\n        }\n      }\n    }\n\n    // Leap of faith to new safe state.\n    matrix.copyVec2(toiA.m_sweep.c0, toiA.c_position.c);\n    toiA.m_sweep.a0 = toiA.c_position.a;\n    matrix.copyVec2(toiB.m_sweep.c0, toiB.c_position.c);\n    toiB.m_sweep.a0 = toiB.c_position.a;\n\n    // No warm starting is needed for TOI events because warm\n    // starting impulses were applied in the discrete solver.\n    for (let i = 0; i < this.m_contacts.length; ++i) {\n      const contact = this.m_contacts[i];\n      contact.initVelocityConstraint(subStep);\n    }\n\n    // Solve velocity constraints.\n    for (let i = 0; i < subStep.velocityIterations; ++i) {\n      for (let j = 0; j < this.m_contacts.length; ++j) {\n        const contact = this.m_contacts[j];\n        contact.solveVelocityConstraint(subStep);\n      }\n    }\n\n    // Don't store the TOI contact forces for warm starting\n    // because they can be quite large.\n\n    const h = subStep.dt;\n\n    // Integrate positions\n    for (let i = 0; i < this.m_bodies.length; ++i) {\n      const body = this.m_bodies[i];\n\n      matrix.copyVec2(c, body.c_position.c);\n      let a = body.c_position.a;\n      matrix.copyVec2(v, body.c_velocity.v);\n      let w = body.c_velocity.w;\n\n      // Check for large velocities\n      matrix.setMulVec2(translation, h, v);\n      const translationLengthSqr = matrix.lengthSqrVec2(translation);\n      if (translationLengthSqr > Settings.maxTranslationSquared) {\n        const ratio = Settings.maxTranslation / math_sqrt(translationLengthSqr);\n        matrix.scaleVec2(v, ratio);\n      }\n\n      const rotation = h * w;\n      if (rotation * rotation > Settings.maxRotationSquared) {\n        const ratio = Settings.maxRotation / math_abs(rotation);\n        w *= ratio;\n      }\n\n      // Integrate\n      matrix.addMulVec2(c, h, v);\n      a += h * w;\n\n      matrix.copyVec2(body.c_position.c, c);\n      body.c_position.a = a;\n      matrix.copyVec2(body.c_velocity.v, v);\n      body.c_velocity.w = w;\n\n      // Sync bodies\n      matrix.copyVec2(body.m_sweep.c, c);\n      body.m_sweep.a = a;\n      matrix.copyVec2(body.m_linearVelocity, v);\n      body.m_angularVelocity = w;\n      body.synchronizeTransform();\n    }\n\n    this.postSolveIsland();\n  }\n\n  /** @internal */\n  postSolveIsland(): void {\n    for (let c = 0; c < this.m_contacts.length; ++c) {\n      const contact = this.m_contacts[c];\n      this.m_world.postSolve(contact, contact.m_impulse);\n    }\n  }\n}\n\n// @ts-ignore\nSolver.TimeStep = TimeStep;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2 } from './Vec2';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 2-by-2 matrix. Stored in column-major order.\n */\nexport class Mat22 {\n  ex: Vec2;\n  ey: Vec2;\n\n  constructor(a: number, b: number, c: number, d: number);\n  constructor(a: { x: number; y: number }, b: { x: number; y: number });\n  constructor();\n  constructor(a?, b?, c?, d?) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec2.clone(a);\n      this.ey = Vec2.clone(b);\n    } else if (typeof a === 'number') {\n      this.ex = Vec2.neo(a, c);\n      this.ey = Vec2.neo(b, d);\n    } else {\n      this.ex = Vec2.zero();\n      this.ey = Vec2.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Mat22.isValid(o), 'Invalid Mat22!', o);\n  }\n\n  set(a: Mat22): void;\n  set(a: Vec2, b: Vec2): void;\n  set(a: number, b: number, c: number, d: number): void;\n  set(a, b?, c?, d?): void {\n    if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'\n      && typeof d === 'number') {\n      this.ex.setNum(a, c);\n      this.ey.setNum(b, d);\n\n    } else if (typeof a === 'object' && typeof b === 'object') {\n      this.ex.setVec2(a);\n      this.ey.setVec2(b);\n\n    } else if (typeof a === 'object') {\n      _ASSERT && Mat22.assert(a);\n      this.ex.setVec2(a.ex);\n      this.ey.setVec2(a.ey);\n\n    } else {\n      _ASSERT && console.assert(false);\n    }\n  }\n\n  setIdentity(): void {\n    this.ex.x = 1.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 1.0;\n  }\n\n  setZero(): void {\n    this.ex.x = 0.0;\n    this.ey.x = 0.0;\n    this.ex.y = 0.0;\n    this.ey.y = 0.0;\n  }\n\n  getInverse(): Mat22 {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const imx = new Mat22();\n    imx.ex.x = det * d;\n    imx.ey.x = -det * b;\n    imx.ex.y = -det * c;\n    imx.ey.y = det * a;\n    return imx;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve(v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const w = Vec2.zero();\n    w.x = det * (d * v.x - b * v.y);\n    w.y = det * (a * v.y - c * v.x);\n    return w;\n  }\n\n  /**\n   * Multiply a matrix times a vector. If a rotation matrix is provided, then this\n   * transforms the vector from one frame to another.\n   */\n  static mul(mx: Mat22, my: Mat22): Mat22;\n  static mul(mx: Mat22, v: Vec2): Vec2;\n  static mul(mx, v) {\n    if (v && 'x' in v && 'y' in v) {\n      _ASSERT && Vec2.assert(v);\n      const x = mx.ex.x * v.x + mx.ey.x * v.y;\n      const y = mx.ex.y * v.x + mx.ey.y * v.y;\n      return Vec2.neo(x, y);\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n      const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n      const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n      const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n      const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n      return new Mat22(a, b, c, d);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Vec2.assert(v);\n    const x = mx.ex.x * v.x + mx.ey.x * v.y;\n    const y = mx.ex.y * v.x + mx.ey.y * v.y;\n    return Vec2.neo(x, y);\n  }\n\n  static mulMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(v);\n    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));\n    const a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;\n    const b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;\n    const c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;\n    const d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;\n    return new Mat22(a, b, c, d);\n  }\n\n  /**\n   * Multiply a matrix transpose times a vector. If a rotation matrix is provided,\n   * then this transforms the vector from one frame to another (inverse\n   * transform).\n   */\n  static mulT(mx: Mat22, my: Mat22): Mat22;\n  static mulT(mx: Mat22, v: Vec2): Vec2;\n  static mulT(mx, v) {\n    if (v && 'x' in v && 'y' in v) { // Vec2\n      _ASSERT && Vec2.assert(v);\n      return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n\n    } else if (v && 'ex' in v && 'ey' in v) { // Mat22\n      _ASSERT && Mat22.assert(v);\n      const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n      const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n      return new Mat22(c1, c2);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulTVec2(mx: Mat22, v: Vec2): Vec2 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Vec2.assert(v);\n    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));\n  }\n\n  static mulTMat22(mx: Mat22, v: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    _ASSERT && Mat22.assert(v);\n    const c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));\n    const c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));\n    return new Mat22(c1, c2);\n  }\n\n  static abs(mx: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx);\n    return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n  }\n\n  static add(mx1: Mat22, mx2: Mat22): Mat22 {\n    _ASSERT && Mat22.assert(mx1);\n    _ASSERT && Mat22.assert(mx2);\n    return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { Vec2Value } from '../common/Vec2';\nimport { TransformValue } from '../common/Transform';\nimport { EPSILON } from '../common/Math';\n\n\n/** @internal */ const math_sqrt = Math.sqrt;\n\n/** @internal */ const pointA = matrix.vec2(0, 0);\n/** @internal */ const pointB = matrix.vec2(0, 0);\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const cA = matrix.vec2(0, 0);\n/** @internal */ const cB = matrix.vec2(0, 0);\n/** @internal */ const dist = matrix.vec2(0, 0);\n/** @internal */ const planePoint = matrix.vec2(0, 0);\n/** @internal */ const clipPoint = matrix.vec2(0, 0);\n\nexport enum ManifoldType {\n  e_unset = -1,\n  e_circles = 0,\n  e_faceA = 1,\n  e_faceB = 2\n}\n\nexport enum ContactFeatureType {\n  e_unset = -1,\n  e_vertex = 0,\n  e_face = 1\n}\n\n/**\n * This is used for determining the state of contact points.\n */\n export enum PointState {\n  /** Point does not exist */\n  nullState = 0,\n  /** Point was added in the update */\n  addState = 1,\n  /** Point persisted across the update */\n  persistState = 2,\n  /** Point was removed in the update */\n  removeState = 3\n}\n\n/**\n * Used for computing contact manifolds.\n */\n export class ClipVertex {\n  v = matrix.vec2(0, 0);\n  id: ContactID = new ContactID();\n\n  set(o: ClipVertex): void {\n    matrix.copyVec2(this.v, o.v);\n    this.id.set(o.id);\n  }\n  recycle() {\n    matrix.zeroVec2(this.v)\n    this.id.recycle();\n  }\n}\n\n/**\n * A manifold for two touching convex shapes. Manifolds are created in `evaluate`\n * method of Contact subclasses.\n *\n * Supported manifold types are e_faceA or e_faceB for clip point versus plane\n * with radius and e_circles point versus point with radius.\n *\n * We store contacts in this way so that position correction can account for\n * movement, which is critical for continuous physics. All contact scenarios\n * must be expressed in one of these types. This structure is stored across time\n * steps, so we keep it small.\n */\nexport class Manifold {\n  type: ManifoldType;\n\n  /**\n   * Usage depends on manifold type:\n   * - circles: not used\n   * - faceA: the normal on polygonA\n   * - faceB: the normal on polygonB\n   */\n  localNormal = matrix.vec2(0, 0);\n\n  /**\n   * Usage depends on manifold type:\n   * - circles: the local center of circleA\n   * - faceA: the center of faceA\n   * - faceB: the center of faceB\n   */\n  localPoint = matrix.vec2(0, 0);\n\n  /** The points of contact */\n  points: ManifoldPoint[] = [ new ManifoldPoint(), new ManifoldPoint() ];\n\n  /** The number of manifold points */\n  pointCount: number = 0;\n\n  set(that: Manifold): void {\n    this.type = that.type;\n    matrix.copyVec2(this.localNormal, that.localNormal);\n    matrix.copyVec2(this.localPoint, that.localPoint);\n    this.pointCount = that.pointCount;\n    this.points[0].set(that.points[0]);\n    this.points[1].set(that.points[1]);\n  }\n\n  recycle(): void {\n    this.type = ManifoldType.e_unset;\n    matrix.zeroVec2(this.localNormal)\n    matrix.zeroVec2(this.localPoint)\n    this.pointCount = 0;\n    this.points[0].recycle();\n    this.points[1].recycle();\n  }\n\n  /**\n   * Evaluate the manifold with supplied transforms. This assumes modest motion\n   * from the original state. This does not change the point count, impulses, etc.\n   * The radii must come from the shapes that generated the manifold.\n   */\n  getWorldManifold(wm: WorldManifold | null, xfA: TransformValue, radiusA: number, xfB: TransformValue, radiusB: number): WorldManifold {\n    if (this.pointCount == 0) {\n      return wm;\n    }\n\n    wm = wm || new WorldManifold();\n\n    wm.pointCount = this.pointCount;\n\n    const normal = wm.normal;\n    const points = wm.points;\n    const separations = wm.separations;\n\n    switch (this.type) {\n      case ManifoldType.e_circles: {\n        matrix.setVec2(normal, 1.0, 0.0);\n        const manifoldPoint = this.points[0];\n        matrix.transformVec2(pointA, xfA, this.localPoint);\n        matrix.transformVec2(pointB, xfB, manifoldPoint.localPoint);\n        matrix.diffVec2(dist, pointB, pointA);\n        const lengthSqr = matrix.lengthSqrVec2(dist);\n          if (lengthSqr > EPSILON * EPSILON) {\n          const length = math_sqrt(lengthSqr);\n          matrix.setMulVec2(normal, 1 / length, dist);\n        }\n        matrix.combineVec2(cA, 1, pointA, radiusA, normal);\n        matrix.combineVec2(cB, 1, pointB, -radiusB, normal);\n        matrix.combineVec2(points[0], 0.5, cA, 0.5, cB);\n        separations[0] = matrix.dotVec2(matrix.diffVec2(temp, cB, cA), normal);\n        break;\n      }\n\n      case ManifoldType.e_faceA: {\n        matrix.rotVec2(normal, xfA.q, this.localNormal);\n        matrix.transformVec2(planePoint, xfA, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const manifoldPoint = this.points[i];\n          matrix.transformVec2(clipPoint, xfB, manifoldPoint.localPoint);\n          matrix.combineVec2(cA, 1, clipPoint, radiusA - matrix.dotVec2(matrix.diffVec2(temp, clipPoint, planePoint), normal), normal);\n          matrix.combineVec2(cB, 1, clipPoint, -radiusB, normal);\n          matrix.combineVec2(points[i], 0.5, cA, 0.5, cB);\n          separations[i] = matrix.dotVec2(matrix.diffVec2(temp, cB, cA), normal);\n        }\n        break;\n      }\n\n      case ManifoldType.e_faceB: {\n        matrix.rotVec2(normal, xfB.q, this.localNormal);\n        matrix.transformVec2(planePoint, xfB, this.localPoint);\n\n        for (let i = 0; i < this.pointCount; ++i) {\n          const manifoldPoint = this.points[i];\n          matrix.transformVec2(clipPoint, xfA, manifoldPoint.localPoint);\n          matrix.combineVec2(cB, 1, clipPoint, radiusB - matrix.dotVec2(matrix.diffVec2(temp, clipPoint, planePoint), normal), normal);\n          matrix.combineVec2(cA, 1, clipPoint, -radiusA, normal);\n          matrix.combineVec2(points[i], 0.5, cA, 0.5, cB);\n          separations[i] = matrix.dotVec2(matrix.diffVec2(temp, cA, cB), normal);\n        }\n        // Ensure normal points from A to B.\n        matrix.negVec2(normal);\n        break;\n      }\n    }\n\n    return wm;\n  }\n\n  static clipSegmentToLine = clipSegmentToLine;\n  static ClipVertex = ClipVertex;\n  static getPointStates = getPointStates;\n  static PointState = PointState;\n}\n\n/**\n * A manifold point is a contact point belonging to a contact manifold. It holds\n * details related to the geometry and dynamics of the contact points.\n *\n * This structure is stored across time steps, so we keep it small.\n *\n * Note: impulses are used for internal caching and may not provide reliable\n * contact forces, especially for high speed collisions.\n */\nexport class ManifoldPoint {\n  /**\n   * Usage depends on manifold type:\n   * - circles: the local center of circleB\n   * - faceA: the local center of circleB or the clip point of polygonB\n   * - faceB: the clip point of polygonA\n   */\n  localPoint = matrix.vec2(0, 0);\n  /**\n   * The non-penetration impulse\n   */\n  normalImpulse = 0;\n  /**\n   * The friction impulse\n   */\n  tangentImpulse = 0;\n  /**\n   * Uniquely identifies a contact point between two shapes to facilitate warm starting\n   */\n  readonly id = new ContactID();\n\n  set(that: ManifoldPoint): void {\n    matrix.copyVec2(this.localPoint, that.localPoint);\n    this.normalImpulse = that.normalImpulse;\n    this.tangentImpulse = that.tangentImpulse;\n    this.id.set(that.id);\n  }\n\n  recycle(): void {\n    matrix.zeroVec2(this.localPoint)\n    this.normalImpulse = 0;\n    this.tangentImpulse = 0;\n    this.id.recycle();\n  }\n}\n\n/**\n * Contact ids to facilitate warm starting.\n * \n * ContactFeature: The features that intersect to form the contact point.\n */\nexport class ContactID {\n\n  /**\n   * Used to quickly compare contact ids.\n   */\n  key = -1;\n\n  /** ContactFeature index on shapeA */\n  indexA = -1;\n\n  /** ContactFeature index on shapeB */\n  indexB = -1;\n\n  /** ContactFeature type on shapeA */\n  typeA = ContactFeatureType.e_unset;\n\n  /** ContactFeature type on shapeB */\n  typeB = ContactFeatureType.e_unset;\n\n  setFeatures(indexA: number, typeA: ContactFeatureType, indexB: number, typeB: ContactFeatureType): void {\n    this.indexA = indexA;\n    this.indexB = indexB;\n    this.typeA = typeA;\n    this.typeB = typeB;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  set(that: ContactID): void {\n    this.indexA = that.indexA;\n    this.indexB = that.indexB;\n    this.typeA = that.typeA;\n    this.typeB = that.typeB;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  swapFeatures(): void {\n    const indexA = this.indexA;\n    const indexB = this.indexB;\n    const typeA = this.typeA;\n    const typeB = this.typeB;\n    this.indexA = indexB;\n    this.indexB = indexA;\n    this.typeA = typeB;\n    this.typeB = typeA;\n    this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64\n  }\n\n  recycle(): void {\n    this.indexA = 0;\n    this.indexB = 0;\n    this.typeA = ContactFeatureType.e_unset;\n    this.typeB = ContactFeatureType.e_unset;\n    this.key = -1;\n  }\n}\n\n/**\n * This is used to compute the current state of a contact manifold.\n */\nexport class WorldManifold {\n  /** World vector pointing from A to B */\n  normal = matrix.vec2(0, 0);\n\n  /** World contact point (point of intersection) */\n  points = [matrix.vec2(0, 0), matrix.vec2(0, 0)]; // [maxManifoldPoints]\n\n  /** A negative value indicates overlap, in meters */\n  separations = [0, 0]; // [maxManifoldPoints]\n\n  /** The number of manifold points */\n  pointCount = 0;\n\n  recycle() {\n    matrix.zeroVec2(this.normal)\n    matrix.zeroVec2(this.points[0]);\n    matrix.zeroVec2(this.points[1]);\n    this.separations[0] = 0;\n    this.separations[1] = 0;\n    this.pointCount = 0;\n  }\n}\n\n/**\n * Compute the point states given two manifolds. The states pertain to the\n * transition from manifold1 to manifold2. So state1 is either persist or remove\n * while state2 is either add or persist.\n */\nexport function getPointStates(\n  state1: PointState[],\n  state2: PointState[],\n  manifold1: Manifold,\n  manifold2: Manifold\n): void {\n  // state1, state2: PointState[Settings.maxManifoldPoints]\n\n  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {\n  // state1[i] = PointState.nullState;\n  // state2[i] = PointState.nullState;\n  // }\n\n  // Detect persists and removes.\n  for (let i = 0; i < manifold1.pointCount; ++i) {\n    const id = manifold1.points[i].id;\n\n    state1[i] = PointState.removeState;\n\n    for (let j = 0; j < manifold2.pointCount; ++j) {\n      if (manifold2.points[j].id.key === id.key) {\n        state1[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n\n  // Detect persists and adds.\n  for (let i = 0; i < manifold2.pointCount; ++i) {\n    const id = manifold2.points[i].id;\n\n    state2[i] = PointState.addState;\n\n    for (let j = 0; j < manifold1.pointCount; ++j) {\n      if (manifold1.points[j].id.key === id.key) {\n        state2[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Clipping for contact manifolds. Sutherland-Hodgman clipping.\n */\nexport function clipSegmentToLine(\n  vOut: ClipVertex[],\n  vIn: ClipVertex[],\n  normal: Vec2Value,\n  offset: number,\n  vertexIndexA: number\n): number {\n  // Start with no output points\n  let numOut = 0;\n\n  // Calculate the distance of end points to the line\n  const distance0 = matrix.dotVec2(normal, vIn[0].v) - offset;\n  const distance1 = matrix.dotVec2(normal, vIn[1].v) - offset;\n\n  // If the points are behind the plane\n  if (distance0 <= 0.0)\n    vOut[numOut++].set(vIn[0]);\n  if (distance1 <= 0.0)\n    vOut[numOut++].set(vIn[1]);\n\n  // If the points are on different sides of the plane\n  if (distance0 * distance1 < 0.0) {\n    // Find intersection point of edge and plane\n    const interp = distance0 / (distance0 - distance1);\n    matrix.combineVec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);\n\n    // VertexA is hitting edgeB.\n    vOut[numOut].id.setFeatures(vertexIndexA, ContactFeatureType.e_vertex, vIn[0].id.indexB, ContactFeatureType.e_face);\n    ++numOut;\n  }\n\n  return numOut;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../common/Matrix';\nimport { ShapeType } from \"../collision/Shape\";\nimport { clamp } from '../common/Math';\nimport { TransformValue } from '../common/Transform';\nimport { Mat22 } from '../common/Mat22';\nimport { SettingsInternal as Settings } from '../Settings';\nimport { Manifold, ManifoldType, WorldManifold } from '../collision/Manifold';\nimport { testOverlap } from '../collision/Distance';\nimport { Fixture } from \"./Fixture\";\nimport { Body } from \"./Body\";\nimport { ContactImpulse, TimeStep } from \"./Solver\";\nimport { Pool } from \"../util/Pool\";\nimport { getTransform } from \"./Position\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_sqrt = Math.sqrt;\n/** @internal */ const math_max = Math.max;\n/** @internal */ const math_min = Math.min;\n\n\n// Solver debugging is normally disabled because the block solver sometimes has to deal with a poorly conditioned effective mass matrix.\n/** @internal */ const DEBUG_SOLVER = false;\n\n/** @internal */ const contactPool = new Pool<Contact>({\n  create() {\n    return new Contact();\n  },\n  release(contact: Contact) {\n    contact.recycle();\n  }\n});\n\n/** @internal */ const oldManifold = new Manifold();\n\n/** @internal */ const worldManifold = new WorldManifold();\n\n/**\n * A contact edge is used to connect bodies and contacts together in a contact\n * graph where each body is a node and each contact is an edge. A contact edge\n * belongs to a doubly linked list maintained in each attached body. Each\n * contact has two contact nodes, one for each attached body.\n */\nexport class ContactEdge {\n  contact: Contact;\n  prev: ContactEdge | null = null;\n  next: ContactEdge | null = null;\n  other: Body | null = null;\n  constructor(contact: Contact) {\n    this.contact = contact;\n  }\n\n  /** @internal */\n  recycle() {\n    this.prev = null;\n    this.next = null;\n    this.other = null;\n  }\n}\n\nexport type EvaluateFunction = (\n  manifold: Manifold,\n  xfA: TransformValue,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: TransformValue,\n  fixtureB: Fixture,\n  indexB: number\n) => void;\n\n/**\n * Friction mixing law. The idea is to allow either fixture to drive the\n * friction to zero. For example, anything slides on ice.\n */\nexport function mixFriction(friction1: number, friction2: number): number {\n  return math_sqrt(friction1 * friction2);\n}\n\n/**\n * Restitution mixing law. The idea is allow for anything to bounce off an\n * inelastic surface. For example, a superball bounces on anything.\n */\nexport function mixRestitution(restitution1: number, restitution2: number): number {\n  return restitution1 > restitution2 ? restitution1 : restitution2;\n}\n\n// TODO: move this to Settings?\n/** @internal */ const s_registers = [];\n\n// TODO: merge with ManifoldPoint?\nexport class VelocityConstraintPoint {\n  rA = matrix.vec2(0, 0);\n  rB = matrix.vec2(0, 0);\n  normalImpulse = 0;\n  tangentImpulse = 0;\n  normalMass = 0;\n  tangentMass = 0;\n  velocityBias = 0;\n\n  recycle() {\n    matrix.zeroVec2(this.rA)\n    matrix.zeroVec2(this.rB)\n    this.normalImpulse = 0;\n    this.tangentImpulse = 0;\n    this.normalMass = 0;\n    this.tangentMass = 0;\n    this.velocityBias = 0;\n  }\n}\n\n/** @internal */ const cA = matrix.vec2(0, 0);\n/** @internal */ const vA = matrix.vec2(0, 0);\n/** @internal */ const cB = matrix.vec2(0, 0);\n/** @internal */ const vB = matrix.vec2(0, 0);\n/** @internal */ const tangent = matrix.vec2(0, 0);\n/** @internal */ const xfA = matrix.transform(0, 0, 0);\n/** @internal */ const xfB = matrix.transform(0, 0, 0);\n/** @internal */ const pointA = matrix.vec2(0, 0);\n/** @internal */ const pointB = matrix.vec2(0, 0);\n/** @internal */ const clipPoint = matrix.vec2(0, 0);\n/** @internal */ const planePoint = matrix.vec2(0, 0);\n/** @internal */ const rA = matrix.vec2(0, 0);\n/** @internal */ const rB = matrix.vec2(0, 0);\n/** @internal */ const P = matrix.vec2(0, 0);\n/** @internal */ const normal = matrix.vec2(0, 0);\n/** @internal */ const point = matrix.vec2(0, 0);\n/** @internal */ const dv = matrix.vec2(0, 0);\n/** @internal */ const dv1 = matrix.vec2(0, 0);\n/** @internal */ const dv2 = matrix.vec2(0, 0);\n/** @internal */ const b = matrix.vec2(0, 0);\n/** @internal */ const a = matrix.vec2(0, 0);\n/** @internal */ const x = matrix.vec2(0, 0);\n/** @internal */ const d = matrix.vec2(0, 0);\n/** @internal */ const P1 = matrix.vec2(0, 0);\n/** @internal */ const P2 = matrix.vec2(0, 0);\n/** @internal */ const temp = matrix.vec2(0, 0);\n\n/**\n * The class manages contact between two shapes. A contact exists for each\n * overlapping AABB in the broad-phase (except if filtered). Therefore a contact\n * object may exist that has no contact points.\n */\nexport class Contact {\n  // Nodes for connecting bodies.\n  /** @internal */\n  m_nodeA = new ContactEdge(this);\n  /** @internal */\n  m_nodeB = new ContactEdge(this);\n  /** @internal */\n  m_fixtureA: Fixture | null = null;\n  /** @internal */\n  m_fixtureB: Fixture | null = null;\n  /** @internal */\n  m_indexA = -1;\n  /** @internal */\n  m_indexB = -1;\n  /** @internal */\n  m_evaluateFcn: EvaluateFunction | null = null;\n  /** @internal */\n  m_manifold: Manifold = new Manifold();\n  /** @internal */\n  m_prev: Contact | null = null;\n  /** @internal */\n  m_next: Contact | null = null;\n  /** @internal */\n  m_toi = 1.0;\n  /** @internal */\n  m_toiCount = 0;\n  /** @internal This contact has a valid TOI in m_toi */\n  m_toiFlag = false;\n  /** @internal */\n  m_friction = 0.0;\n  /** @internal */\n  m_restitution = 0.0;\n  /** @internal */\n  m_tangentSpeed = 0.0;\n  /** @internal This contact can be disabled (by user) */\n  m_enabledFlag = true;\n  /** @internal Used when crawling contact graph when forming islands. */\n  m_islandFlag = false;\n  /** @internal Set when the shapes are touching. */\n  m_touchingFlag = false;\n  /** @internal This contact needs filtering because a fixture filter was changed. */\n  m_filterFlag = false;\n  /** @internal This bullet contact had a TOI event */\n  m_bulletHitFlag = false;\n\n  /** @internal Contact reporting impulse object cache */\n  m_impulse: ContactImpulse = new ContactImpulse(this);\n\n  // VelocityConstraint\n  /** @internal */\n  v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()]; // [maxManifoldPoints];\n  /** @internal */\n  v_normal = matrix.vec2(0, 0);\n  /** @internal */ v_normalMass: Mat22 = new Mat22();\n  /** @internal */ v_K: Mat22 = new Mat22();\n  /** @internal */ v_pointCount = 0;\n  /** @internal */ v_tangentSpeed = 0;\n  /** @internal */ v_friction = 0;\n  /** @internal */ v_restitution = 0;\n  /** @internal */ v_invMassA = 0;\n  /** @internal */ v_invMassB = 0;\n  /** @internal */ v_invIA = 0;\n  /** @internal */ v_invIB = 0;\n\n  // PositionConstraint\n  /** @internal */ p_localPoints = [matrix.vec2(0, 0), matrix.vec2(0, 0)]; // [maxManifoldPoints];\n  /** @internal */ p_localNormal = matrix.vec2(0, 0);\n  /** @internal */ p_localPoint = matrix.vec2(0, 0);\n  /** @internal */ p_localCenterA = matrix.vec2(0, 0);\n  /** @internal */ p_localCenterB = matrix.vec2(0, 0);\n  /** @internal */ p_type = ManifoldType.e_unset;\n  /** @internal */ p_radiusA = 0;\n  /** @internal */ p_radiusB = 0;\n  /** @internal */ p_pointCount = 0;\n  /** @internal */ p_invMassA = 0;\n  /** @internal */ p_invMassB = 0;\n  /** @internal */ p_invIA = 0;\n  /** @internal */ p_invIB = 0;\n\n  /** @internal */ \n  initialize(fA: Fixture, indexA: number, fB: Fixture, indexB: number, evaluateFcn: EvaluateFunction) {\n    this.m_fixtureA = fA;\n    this.m_fixtureB = fB;\n\n    this.m_indexA = indexA;\n    this.m_indexB = indexB;\n\n    this.m_evaluateFcn = evaluateFcn;\n\n    this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n    this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n  }\n\n  /** @internal */ \n  recycle() {\n    this.m_nodeA.recycle();\n    this.m_nodeB.recycle();\n    this.m_fixtureA = null;\n    this.m_fixtureB = null;\n    this.m_indexA = -1;\n    this.m_indexB = -1;\n    this.m_evaluateFcn = null;\n    this.m_manifold.recycle();\n    this.m_prev = null;\n    this.m_next = null;\n    this.m_toi = 1;\n    this.m_toiCount = 0;\n    this.m_toiFlag = false;\n    this.m_friction = 0;\n    this.m_restitution = 0;\n    this.m_tangentSpeed = 0;\n    this.m_enabledFlag = true;\n    this.m_islandFlag = false;\n    this.m_touchingFlag = false;\n    this.m_filterFlag = false;\n    this.m_bulletHitFlag = false;\n\n    this.m_impulse.recycle();\n\n    // VelocityConstraint\n    for(const point of this.v_points) {\n      point.recycle();\n    }\n    matrix.zeroVec2(this.v_normal)\n    this.v_normalMass.setZero();\n    this.v_K.setZero();\n    this.v_pointCount = 0;\n    this.v_tangentSpeed = 0;\n    this.v_friction = 0;\n    this.v_restitution = 0;\n    this.v_invMassA = 0;\n    this.v_invMassB = 0;\n    this.v_invIA = 0;\n    this.v_invIB = 0;\n\n    // PositionConstraint\n    for(const point of this.p_localPoints) {\n      matrix.zeroVec2(point);\n    }\n    matrix.zeroVec2(this.p_localNormal)\n    matrix.zeroVec2(this.p_localPoint)\n    matrix.zeroVec2(this.p_localCenterA)\n    matrix.zeroVec2(this.p_localCenterB)\n    this.p_type = ManifoldType.e_unset;\n    this.p_radiusA = 0;\n    this.p_radiusB = 0;\n    this.p_pointCount = 0;\n    this.p_invMassA = 0;\n    this.p_invMassB = 0;\n    this.p_invIA = 0;\n    this.p_invIB = 0;\n  }\n\n  initConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    const manifold = this.m_manifold;\n\n    const pointCount = manifold.pointCount;\n    _ASSERT && console.assert(pointCount > 0);\n\n    this.v_invMassA = bodyA.m_invMass;\n    this.v_invMassB = bodyB.m_invMass;\n    this.v_invIA = bodyA.m_invI;\n    this.v_invIB = bodyB.m_invI;\n\n    this.v_friction = this.m_friction;\n    this.v_restitution = this.m_restitution;\n    this.v_tangentSpeed = this.m_tangentSpeed;\n\n    this.v_pointCount = pointCount;\n\n    this.v_K.setZero();\n    this.v_normalMass.setZero();\n\n    this.p_invMassA = bodyA.m_invMass;\n    this.p_invMassB = bodyB.m_invMass;\n    this.p_invIA = bodyA.m_invI;\n    this.p_invIB = bodyB.m_invI;\n    matrix.copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);\n    matrix.copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);\n\n    this.p_radiusA = shapeA.m_radius;\n    this.p_radiusB = shapeB.m_radius;\n\n    this.p_type = manifold.type;\n    matrix.copyVec2(this.p_localNormal, manifold.localNormal);\n    matrix.copyVec2(this.p_localPoint, manifold.localPoint);\n    this.p_pointCount = pointCount;\n\n    for (let j = 0; j < Settings.maxManifoldPoints; ++j) {\n      this.v_points[j].recycle();\n      matrix.zeroVec2(this.p_localPoints[j]);\n    }\n\n    for (let j = 0; j < pointCount; ++j) {\n      const cp = manifold.points[j];\n      const vcp = this.v_points[j];\n      if (step.warmStarting) {\n        vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n        vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n      }\n      matrix.copyVec2(this.p_localPoints[j], cp.localPoint);\n    }\n  }\n\n  /**\n   * Get the contact manifold. Do not modify the manifold unless you understand\n   * the internals of the library.\n   */\n  getManifold(): Manifold {\n    return this.m_manifold;\n  }\n\n  /**\n   * Get the world manifold.\n   */\n  getWorldManifold(worldManifold: WorldManifold | null): WorldManifold | undefined {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    return this.m_manifold.getWorldManifold(\n      worldManifold,\n      bodyA.getTransform(), shapeA.m_radius,\n      bodyB.getTransform(), shapeB.m_radius\n    );\n  }\n\n  /**\n   * Enable/disable this contact. This can be used inside the pre-solve contact\n   * listener. The contact is only disabled for the current time step (or sub-step\n   * in continuous collisions).\n   */\n  setEnabled(flag: boolean): void {\n    this.m_enabledFlag = !!flag;\n  }\n\n  /**\n   * Has this contact been disabled?\n   */\n  isEnabled(): boolean {\n    return this.m_enabledFlag;\n  }\n\n  /**\n   * Is this contact touching?\n   */\n  isTouching(): boolean {\n    return this.m_touchingFlag;\n  }\n\n  /**\n   * Get the next contact in the world's contact list.\n   */\n  getNext(): Contact | null {\n    return this.m_next;\n  }\n\n  /**\n   * Get fixture A in this contact.\n   */\n  getFixtureA(): Fixture {\n    return this.m_fixtureA;\n  }\n\n  /**\n   * Get fixture B in this contact.\n   */\n  getFixtureB(): Fixture {\n    return this.m_fixtureB;\n  }\n\n  /**\n   * Get the child primitive index for fixture A.\n   */\n  getChildIndexA(): number {\n    return this.m_indexA;\n  }\n\n  /**\n   * Get the child primitive index for fixture B.\n   */\n  getChildIndexB(): number {\n    return this.m_indexB;\n  }\n\n  /**\n   * Flag this contact for filtering. Filtering will occur the next time step.\n   */\n  flagForFiltering(): void {\n    this.m_filterFlag = true;\n  }\n\n  /**\n   * Override the default friction mixture. You can call this in\n   * ContactListener.preSolve. This value persists until set or reset.\n   */\n  setFriction(friction: number): void {\n    this.m_friction = friction;\n  }\n\n  /**\n   * Get the friction.\n   */\n  getFriction(): number {\n    return this.m_friction;\n  }\n\n  /**\n   * Reset the friction mixture to the default value.\n   */\n  resetFriction(): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);\n  }\n\n  /**\n   * Override the default restitution mixture. You can call this in\n   * ContactListener.preSolve. The value persists until you set or reset.\n   */\n  setRestitution(restitution: number): void {\n    this.m_restitution = restitution;\n  }\n\n  /**\n   * Get the restitution.\n   */\n  getRestitution(): number {\n    return this.m_restitution;\n  }\n\n  /**\n   * Reset the restitution to the default value.\n   */\n  resetRestitution(): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);\n  }\n\n  /**\n   * Set the desired tangent speed for a conveyor belt behavior. In meters per\n   * second.\n   */\n  setTangentSpeed(speed: number): void {\n    this.m_tangentSpeed = speed;\n  }\n\n  /**\n   * Get the desired tangent speed. In meters per second.\n   */\n  getTangentSpeed(): number {\n    return this.m_tangentSpeed;\n  }\n\n  /**\n   * Called by Update method, and implemented by subclasses.\n   */\n  evaluate(manifold: Manifold, xfA: TransformValue, xfB: TransformValue): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    this.m_evaluateFcn(manifold, xfA, fixtureA, this.m_indexA, xfB, fixtureB, this.m_indexB);\n  }\n\n  /**\n   * Updates the contact manifold and touching status.\n   *\n   * Note: do not assume the fixture AABBs are overlapping or are valid.\n   *\n   * @param listener.beginContact\n   * @param listener.endContact\n   * @param listener.preSolve\n   */\n  update(listener?: {\n    beginContact(contact: Contact): void,\n    endContact(contact: Contact): void,\n    preSolve(contact: Contact, oldManifold: Manifold): void\n  }): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n    const shapeA = fixtureA.m_shape;\n    const shapeB = fixtureB.m_shape;\n    if (shapeA === null || shapeB === null) return;\n\n    // Re-enable this contact.\n    this.m_enabledFlag = true;\n\n    let touching = false;\n    const wasTouching = this.m_touchingFlag;\n\n    const sensorA = fixtureA.m_isSensor;\n    const sensorB = fixtureB.m_isSensor;\n    const sensor = sensorA || sensorB;\n\n    const xfA = bodyA.m_xf;\n    const xfB = bodyB.m_xf;\n\n    // Is this contact a sensor?\n    if (sensor) {\n      touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA, xfB);\n\n      // Sensors don't generate manifolds.\n      this.m_manifold.pointCount = 0;\n    } else {\n\n      oldManifold.recycle();\n      oldManifold.set(this.m_manifold);\n      this.m_manifold.recycle();\n\n      this.evaluate(this.m_manifold, xfA, xfB);\n      touching = this.m_manifold.pointCount > 0;\n\n      // Match old contact ids to new contact ids and copy the\n      // stored impulses to warm start the solver.\n      for (let i = 0; i < this.m_manifold.pointCount; ++i) {\n        const nmp = this.m_manifold.points[i];\n        nmp.normalImpulse = 0.0;\n        nmp.tangentImpulse = 0.0;\n\n        for (let j = 0; j < oldManifold.pointCount; ++j) {\n          const omp = oldManifold.points[j];\n          if (omp.id.key === nmp.id.key) {\n            nmp.normalImpulse = omp.normalImpulse;\n            nmp.tangentImpulse = omp.tangentImpulse;\n            break;\n          }\n        }\n      }\n\n      if (touching !== wasTouching) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n    }\n\n    this.m_touchingFlag = touching;\n\n    const hasListener = typeof listener === 'object' && listener !== null;\n\n    if (!wasTouching && touching && hasListener) {\n      listener.beginContact(this);\n    }\n\n    if (wasTouching && !touching && hasListener) {\n      listener.endContact(this);\n    }\n\n    if (!sensor && touching && hasListener && oldManifold) {\n      listener.preSolve(this, oldManifold);\n    }\n  }\n\n  solvePositionConstraint(step: TimeStep): number {\n    return this._solvePositionConstraint(step, null, null);\n  }\n\n  solvePositionConstraintTOI(step: TimeStep, toiA: Body, toiB: Body): number {\n    return this._solvePositionConstraint(step, toiA, toiB);\n  }\n\n  private _solvePositionConstraint(step: TimeStep, toiA: Body | null, toiB: Body | null): number {\n    const toi = toiA !== null && toiB !== null ? true : false;\n    let minSeparation = 0.0;\n\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return minSeparation;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return minSeparation;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const localCenterA = this.p_localCenterA;\n    const localCenterB = this.p_localCenterB;\n\n    let mA = 0.0;\n    let iA = 0.0;\n    if (!toi || (bodyA === toiA || bodyA === toiB)) {\n      mA = this.p_invMassA;\n      iA = this.p_invIA;\n    }\n\n    let mB = 0.0;\n    let iB = 0.0;\n    if (!toi || (bodyB === toiA || bodyB === toiB)) {\n      mB = this.p_invMassB;\n      iB = this.p_invIB;\n    }\n\n    matrix.copyVec2(cA, positionA.c);\n    let aA = positionA.a;\n\n    matrix.copyVec2(cB, positionB.c);\n    let aB = positionB.a;\n\n    // Solve normal constraints\n    for (let j = 0; j < this.p_pointCount; ++j) {\n      getTransform(xfA, localCenterA, cA, aA);\n      getTransform(xfB, localCenterB, cB, aB);\n\n      // PositionSolverManifold\n      let separation: number;\n      switch (this.p_type) {\n        case ManifoldType.e_circles: {\n          matrix.transformVec2(pointA, xfA, this.p_localPoint);\n          matrix.transformVec2(pointB, xfB, this.p_localPoints[0]);\n          matrix.diffVec2(normal, pointB, pointA);\n          matrix.normalizeVec2(normal);\n\n          matrix.combineVec2(point, 0.5, pointA, 0.5, pointB);\n          separation = matrix.dotVec2(pointB, normal) - matrix.dotVec2(pointA, normal) - this.p_radiusA - this.p_radiusB;\n          break;\n        }\n\n        case ManifoldType.e_faceA: {\n          matrix.rotVec2(normal, xfA.q, this.p_localNormal);\n          matrix.transformVec2(planePoint, xfA, this.p_localPoint);\n          matrix.transformVec2(clipPoint, xfB, this.p_localPoints[j]);\n          separation = matrix.dotVec2(clipPoint, normal) - matrix.dotVec2(planePoint, normal) - this.p_radiusA - this.p_radiusB;\n          matrix.copyVec2(point, clipPoint);\n          break;\n        }\n\n        case ManifoldType.e_faceB: {\n          matrix.rotVec2(normal, xfB.q, this.p_localNormal);\n          matrix.transformVec2(planePoint, xfB, this.p_localPoint);\n          matrix.transformVec2(clipPoint, xfA, this.p_localPoints[j]);\n          separation = matrix.dotVec2(clipPoint, normal) - matrix.dotVec2(planePoint, normal) - this.p_radiusA - this.p_radiusB;\n          matrix.copyVec2(point, clipPoint);\n\n          // Ensure normal points from A to B\n          matrix.negVec2(normal);\n          break;\n        }\n        // todo: what should we do here?\n        default: {\n          return minSeparation;\n        }\n      }\n\n      matrix.diffVec2(rA, point, cA);\n      matrix.diffVec2(rB, point, cB);\n\n      // Track max constraint error.\n      minSeparation = math_min(minSeparation, separation);\n\n      const baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;\n      const linearSlop = Settings.linearSlop;\n      const maxLinearCorrection = Settings.maxLinearCorrection;\n\n      // Prevent large corrections and allow slop.\n      const C = clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0.0);\n\n      // Compute the effective mass.\n      const rnA = matrix.crossVec2Vec2(rA, normal);\n      const rnB = matrix.crossVec2Vec2(rB, normal);\n      const K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      // Compute normal impulse\n      const impulse = K > 0.0 ? -C / K : 0.0;\n\n      matrix.setMulVec2(P, impulse, normal);\n\n      matrix.subMulVec2(cA, mA, P);\n      aA -= iA * matrix.crossVec2Vec2(rA, P);\n\n      matrix.addMulVec2(cB, mB, P);\n      aB += iB * matrix.crossVec2Vec2(rB, P);\n    }\n\n    matrix.copyVec2(positionA.c, cA);\n    positionA.a = aA;\n\n    matrix.copyVec2(positionB.c, cB);\n    positionB.a = aB;\n\n    return minSeparation;\n  }\n\n  initVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const radiusA = this.p_radiusA;\n    const radiusB = this.p_radiusB;\n    const manifold = this.m_manifold;\n\n    const mA = this.v_invMassA;\n    const mB = this.v_invMassB;\n    const iA = this.v_invIA;\n    const iB = this.v_invIB;\n    const localCenterA = this.p_localCenterA;\n    const localCenterB = this.p_localCenterB;\n\n    matrix.copyVec2(cA, positionA.c);\n    const aA = positionA.a;\n    matrix.copyVec2(vA, velocityA.v);\n    const wA = velocityA.w;\n\n    matrix.copyVec2(cB, positionB.c);\n    const aB = positionB.a;\n    matrix.copyVec2(vB, velocityB.v);\n    const wB = velocityB.w;\n\n    _ASSERT && console.assert(manifold.pointCount > 0);\n\n    getTransform(xfA, localCenterA, cA, aA);\n    getTransform(xfB, localCenterB, cB, aB);\n\n    worldManifold.recycle();\n    manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);\n\n    matrix.copyVec2(this.v_normal, worldManifold.normal);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n      const wmp = worldManifold.points[j];\n\n      matrix.diffVec2(vcp.rA, wmp, cA);\n      matrix.diffVec2(vcp.rB, wmp, cB);\n\n      const rnA = matrix.crossVec2Vec2(vcp.rA, this.v_normal);\n      const rnB = matrix.crossVec2Vec2(vcp.rB, this.v_normal);\n\n      const kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n\n      vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;\n\n      matrix.crossVec2Num(tangent, this.v_normal, 1.0);\n\n      const rtA = matrix.crossVec2Vec2(vcp.rA, tangent);\n      const rtB = matrix.crossVec2Vec2(vcp.rB, tangent);\n\n      const kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n\n      vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;\n\n      // Setup a velocity bias for restitution.\n      vcp.velocityBias = 0.0;\n      let vRel = 0;\n      vRel += matrix.dotVec2(this.v_normal, vB)\n      vRel += matrix.dotVec2(this.v_normal, matrix.crossNumVec2(temp, wB, vcp.rB))\n      vRel -= matrix.dotVec2(this.v_normal, vA)\n      vRel -= matrix.dotVec2(this.v_normal, matrix.crossNumVec2(temp, wA, vcp.rA));\n      if (vRel < -Settings.velocityThreshold) {\n        vcp.velocityBias = -this.v_restitution * vRel;\n      }\n    }\n\n    // If we have two points, then prepare the block solver.\n    if (this.v_pointCount == 2 && step.blockSolve) {\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      const rn1A = matrix.crossVec2Vec2(vcp1.rA, this.v_normal);\n      const rn1B = matrix.crossVec2Vec2(vcp1.rB, this.v_normal);\n      const rn2A = matrix.crossVec2Vec2(vcp2.rA, this.v_normal);\n      const rn2B = matrix.crossVec2Vec2(vcp2.rB, this.v_normal);\n\n      const k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n      const k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n      const k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n\n      // Ensure a reasonable condition number.\n      const k_maxConditionNumber = 1000.0;\n      if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n        // K is safe to invert.\n        this.v_K.ex.setNum(k11, k12);\n        this.v_K.ey.setNum(k12, k22);\n        // this.v_normalMass.set(this.v_K.getInverse());\n        const a = this.v_K.ex.x;\n        const b = this.v_K.ey.x;\n        const c = this.v_K.ex.y;\n        const d = this.v_K.ey.y;\n        let det = a * d - b * c;\n        if (det !== 0.0) {\n          det = 1.0 / det;\n        }\n        this.v_normalMass.ex.x = det * d;\n        this.v_normalMass.ey.x = -det * b;\n        this.v_normalMass.ex.y = -det * c;\n        this.v_normalMass.ey.y = det * a;\n\n      } else {\n        // The constraints are redundant, just use one.\n        // TODO_ERIN use deepest?\n        this.v_pointCount = 1;\n      }\n    }\n\n    matrix.copyVec2(positionA.c, cA);\n    positionA.a = aA;\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n\n    matrix.copyVec2(positionB.c, cB);\n    positionB.a = aB;\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  warmStartConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const velocityB = bodyB.c_velocity;\n    const positionA = bodyA.c_position;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    matrix.copyVec2(vA, velocityA.v);\n    let wA = velocityA.w;\n    matrix.copyVec2(vB, velocityB.v);\n    let wB = velocityB.w;\n\n    matrix.copyVec2(normal, this.v_normal);\n    matrix.crossVec2Num(tangent, normal, 1.0);\n\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      matrix.combineVec2(P, vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);\n\n      wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n      matrix.subMulVec2(vA, mA, P);\n      wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n      matrix.addMulVec2(vB, mB, P);\n    }\n\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  storeConstraintImpulses(step: TimeStep): void {\n    const manifold = this.m_manifold;\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n      manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n    }\n  }\n\n  solveVelocityConstraint(step: TimeStep): void {\n    const fixtureA = this.m_fixtureA;\n    const fixtureB = this.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    const velocityA = bodyA.c_velocity;\n    const positionA = bodyA.c_position;\n\n    const velocityB = bodyB.c_velocity;\n    const positionB = bodyB.c_position;\n\n    const mA = this.v_invMassA;\n    const iA = this.v_invIA;\n    const mB = this.v_invMassB;\n    const iB = this.v_invIB;\n\n    matrix.copyVec2(vA, velocityA.v);\n    let wA = velocityA.w;\n    matrix.copyVec2(vB, velocityB.v);\n    let wB = velocityB.w;\n\n    matrix.copyVec2(normal, this.v_normal);\n    matrix.crossVec2Num(tangent, normal, 1.0);\n    const friction = this.v_friction;\n\n    _ASSERT && console.assert(this.v_pointCount == 1 || this.v_pointCount == 2);\n\n    // Solve tangent constraints first because non-penetration is more important\n    // than friction.\n    for (let j = 0; j < this.v_pointCount; ++j) {\n      const vcp = this.v_points[j]; // VelocityConstraintPoint\n\n      // Relative velocity at contact\n      matrix.zeroVec2(dv);\n      matrix.addVec2(dv, vB);\n      matrix.addVec2(dv, matrix.crossNumVec2(temp, wB, vcp.rB));\n      matrix.subVec2(dv, vA);\n      matrix.subVec2(dv, matrix.crossNumVec2(temp, wA, vcp.rA));\n\n      // Compute tangent force\n      const vt = matrix.dotVec2(dv, tangent) - this.v_tangentSpeed;\n      let lambda = vcp.tangentMass * (-vt);\n\n      // Clamp the accumulated force\n      const maxFriction = friction * vcp.normalImpulse;\n      const newImpulse = clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n      lambda = newImpulse - vcp.tangentImpulse;\n      vcp.tangentImpulse = newImpulse;\n\n      // Apply contact impulse\n      matrix.setMulVec2(P, lambda, tangent);\n\n      matrix.subMulVec2(vA, mA, P);\n      wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n\n      matrix.addMulVec2(vB, mB, P);\n      wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n    }\n\n    // Solve normal constraints\n    if (this.v_pointCount == 1 || step.blockSolve == false) {\n      for (let i = 0; i < this.v_pointCount; ++i) {\n        const vcp = this.v_points[i]; // VelocityConstraintPoint\n\n        // Relative velocity at contact\n        matrix.zeroVec2(dv);\n        matrix.addVec2(dv, vB);\n        matrix.addVec2(dv, matrix.crossNumVec2(temp, wB, vcp.rB));\n        matrix.subVec2(dv, vA);\n        matrix.subVec2(dv, matrix.crossNumVec2(temp, wA, vcp.rA));\n\n        // Compute normal impulse\n        const vn = matrix.dotVec2(dv, normal);\n        let lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n\n        // Clamp the accumulated impulse\n        const newImpulse = math_max(vcp.normalImpulse + lambda, 0.0);\n        lambda = newImpulse - vcp.normalImpulse;\n        vcp.normalImpulse = newImpulse;\n\n        // Apply contact impulse\n        matrix.setMulVec2(P, lambda, normal);\n\n        matrix.subMulVec2(vA, mA, P);\n        wA -= iA * matrix.crossVec2Vec2(vcp.rA, P);\n\n        matrix.addMulVec2(vB, mB, P);\n        wB += iB * matrix.crossVec2Vec2(vcp.rB, P);\n      }\n    } else {\n      // Block solver developed in collaboration with Dirk Gregorius (back in\n      // 01/07 on Box2D_Lite).\n      // Build the mini LCP for this contact patch\n      //\n      // vn = A * x + b, vn >= 0, x >= 0 and vn_i * x_i = 0 with i = 1..2\n      //\n      // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )\n      // b = vn0 - velocityBias\n      //\n      // The system is solved using the \"Total enumeration method\" (s. Murty).\n      // The complementary constraint vn_i * x_i\n      // implies that we must have in any solution either vn_i = 0 or x_i = 0.\n      // So for the 2D contact problem the cases\n      // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and\n      // vn1 = 0 need to be tested. The first valid\n      // solution that satisfies the problem is chosen.\n      //\n      // In order to account of the accumulated impulse 'a' (because of the\n      // iterative nature of the solver which only requires\n      // that the accumulated impulse is clamped and not the incremental\n      // impulse) we change the impulse variable (x_i).\n      //\n      // Substitute:\n      //\n      // x = a + d\n      //\n      // a := old total impulse\n      // x := new total impulse\n      // d := incremental impulse\n      //\n      // For the current iteration we extend the formula for the incremental\n      // impulse\n      // to compute the new total impulse:\n      //\n      // vn = A * d + b\n      // = A * (x - a) + b\n      // = A * x + b - A * a\n      // = A * x + b'\n      // b' = b - A * a;\n\n      const vcp1 = this.v_points[0]; // VelocityConstraintPoint\n      const vcp2 = this.v_points[1]; // VelocityConstraintPoint\n\n      matrix.setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);\n      _ASSERT && console.assert(a.x >= 0.0 && a.y >= 0.0);\n\n      // Relative velocity at contact\n      // let dv1 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp1.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp1.rA));\n      matrix.zeroVec2(dv1);\n      matrix.addVec2(dv1, vB);\n      matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n      matrix.subVec2(dv1, vA);\n      matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n      // let dv2 = Vec2.zero().add(vB).add(Vec2.crossNumVec2(wB, vcp2.rB)).sub(vA).sub(Vec2.crossNumVec2(wA, vcp2.rA));\n      matrix.zeroVec2(dv2);\n      matrix.addVec2(dv2, vB);\n      matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n      matrix.subVec2(dv2, vA);\n      matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n      // Compute normal velocity\n      let vn1 = matrix.dotVec2(dv1, normal);\n      let vn2 = matrix.dotVec2(dv2, normal);\n\n      matrix.setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n\n      // Compute b'\n      // b.sub(Mat22.mulVec2(this.v_K, a));\n      b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;\n      b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;\n\n      const k_errorTol = 1e-3;\n      // NOT_USED(k_errorTol);\n\n      while (true) {\n        //\n        // Case 1: vn = 0\n        //\n        // 0 = A * x + b'\n        //\n        // Solve for x:\n        //\n        // x = - inv(A) * b'\n        //\n        // const x = Mat22.mulVec2(this.v_normalMass, b).neg();\n        matrix.zeroVec2(x);\n        x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);\n        x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);\n\n        if (x.x >= 0.0 && x.y >= 0.0) {\n          // Get the incremental impulse\n          matrix.diffVec2(d, x, a)\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv1);\n            matrix.addVec2(dv1, vB);\n            matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n            matrix.subVec2(dv1, vA);\n            matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n            matrix.zeroVec2(dv2);\n            matrix.addVec2(dv2, vB);\n            matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n            matrix.subVec2(dv2, vA);\n            matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n            // Compute normal velocity\n            vn1 = matrix.dotVec2(dv1, normal);\n            vn2 = matrix.dotVec2(dv2, normal);\n\n            _ASSERT && console.assert(math_abs(vn1 - vcp1.velocityBias) < k_errorTol);\n            _ASSERT && console.assert(math_abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 2: vn1 = 0 and x2 = 0\n        //\n        // 0 = a11 * x1 + a12 * 0 + b1'\n        // vn2 = a21 * x1 + a22 * 0 + b2'\n        //\n        x.x = -vcp1.normalMass * b.x;\n        x.y = 0.0;\n        vn1 = 0.0;\n        vn2 = this.v_K.ex.y * x.x + b.y;\n\n        if (x.x >= 0.0 && vn2 >= 0.0) {\n          // Get the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv1);\n            matrix.addVec2(dv1, vB);\n            matrix.addVec2(dv1, matrix.crossNumVec2(temp, wB, vcp1.rB));\n            matrix.subVec2(dv1, vA);\n            matrix.subVec2(dv1, matrix.crossNumVec2(temp, wA, vcp1.rA));\n\n            // Compute normal velocity\n            vn1 = matrix.dotVec2(dv1, normal);\n\n            _ASSERT && console.assert(math_abs(vn1 - vcp1.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 3: vn2 = 0 and x1 = 0\n        //\n        // vn1 = a11 * 0 + a12 * x2 + b1'\n        // 0 = a21 * 0 + a22 * x2 + b2'\n        //\n        x.x = 0.0;\n        x.y = -vcp2.normalMass * b.y;\n        vn1 = this.v_K.ey.x * x.y + b.x;\n        vn2 = 0.0;\n\n        if (x.y >= 0.0 && vn1 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          if (DEBUG_SOLVER) {\n            // Postconditions\n            matrix.zeroVec2(dv2);\n            matrix.addVec2(dv2, vB);\n            matrix.addVec2(dv2, matrix.crossNumVec2(temp, wB, vcp2.rB));\n            matrix.subVec2(dv2, vA);\n            matrix.subVec2(dv2, matrix.crossNumVec2(temp, wA, vcp2.rA));\n\n            // Compute normal velocity\n            vn2 = matrix.dotVec2(dv2, normal);\n\n            _ASSERT && console.assert(math_abs(vn2 - vcp2.velocityBias) < k_errorTol);\n          }\n          break;\n        }\n\n        //\n        // Case 4: x1 = 0 and x2 = 0\n        //\n        // vn1 = b1\n        // vn2 = b2;\n        //\n        x.x = 0.0;\n        x.y = 0.0;\n        vn1 = b.x;\n        vn2 = b.y;\n\n        if (vn1 >= 0.0 && vn2 >= 0.0) {\n          // Resubstitute for the incremental impulse\n          matrix.diffVec2(d, x, a);\n\n          // Apply incremental impulse\n          matrix.setMulVec2(P1, d.x, normal);\n          matrix.setMulVec2(P2, d.y, normal);\n\n          // vA.subCombine(mA, P1, mA, P2);\n          matrix.subMulVec2(vA, mA, P1);\n          matrix.subMulVec2(vA, mA, P2);\n          wA -= iA * (matrix.crossVec2Vec2(vcp1.rA, P1) + matrix.crossVec2Vec2(vcp2.rA, P2));\n\n          // vB.addCombine(mB, P1, mB, P2);\n          matrix.addMulVec2(vB, mB, P1);\n          matrix.addMulVec2(vB, mB, P2);\n          wB += iB * (matrix.crossVec2Vec2(vcp1.rB, P1) + matrix.crossVec2Vec2(vcp2.rB, P2));\n\n          // Accumulate\n          vcp1.normalImpulse = x.x;\n          vcp2.normalImpulse = x.y;\n\n          break;\n        }\n\n        // No solution, give up. This is hit sometimes, but it doesn't seem to\n        // matter.\n        break;\n      }\n    }\n\n    matrix.copyVec2(velocityA.v, vA);\n    velocityA.w = wA;\n\n    matrix.copyVec2(velocityB.v, vB);\n    velocityB.w = wB;\n  }\n\n  /** @internal */\n  static addType(type1: ShapeType, type2: ShapeType, callback: EvaluateFunction): void {\n    s_registers[type1] = s_registers[type1] || {};\n    s_registers[type1][type2] = callback;\n  }\n\n  /** @internal */\n  static create(fixtureA: Fixture, indexA: number, fixtureB: Fixture, indexB: number): Contact | null {\n    const typeA = fixtureA.m_shape.m_type;\n    const typeB = fixtureB.m_shape.m_type;\n\n    const contact = contactPool.allocate();\n    let evaluateFcn;\n    if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n      contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n    } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n      contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n    } else {\n      return null;\n    }\n\n    // Contact creation may swap fixtures.\n    fixtureA = contact.m_fixtureA;\n    fixtureB = contact.m_fixtureB;\n    indexA = contact.getChildIndexA();\n    indexB = contact.getChildIndexB();\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n\n    // Connect to body A\n    contact.m_nodeA.contact = contact;\n    contact.m_nodeA.other = bodyB;\n\n    contact.m_nodeA.prev = null;\n    contact.m_nodeA.next = bodyA.m_contactList;\n    if (bodyA.m_contactList != null) {\n      bodyA.m_contactList.prev = contact.m_nodeA;\n    }\n    bodyA.m_contactList = contact.m_nodeA;\n\n    // Connect to body B\n    contact.m_nodeB.contact = contact;\n    contact.m_nodeB.other = bodyA;\n\n    contact.m_nodeB.prev = null;\n    contact.m_nodeB.next = bodyB.m_contactList;\n    if (bodyB.m_contactList != null) {\n      bodyB.m_contactList.prev = contact.m_nodeB;\n    }\n    bodyB.m_contactList = contact.m_nodeB;\n\n    // Wake up the bodies\n    if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    return contact;\n  }\n\n  /** @internal */\n  static destroy(contact: Contact, listener: { endContact: (contact: Contact) => void }): void {\n    const fixtureA = contact.m_fixtureA;\n    const fixtureB = contact.m_fixtureB;\n    if (fixtureA === null || fixtureB === null) return;\n    const bodyA = fixtureA.m_body;\n    const bodyB = fixtureB.m_body;\n    if (bodyA === null || bodyB === null) return;\n\n    if (contact.isTouching()) {\n      listener.endContact(contact);\n    }\n\n    // Remove from body 1\n    if (contact.m_nodeA.prev) {\n      contact.m_nodeA.prev.next = contact.m_nodeA.next;\n    }\n\n    if (contact.m_nodeA.next) {\n      contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n    }\n\n    if (contact.m_nodeA == bodyA.m_contactList) {\n      bodyA.m_contactList = contact.m_nodeA.next;\n    }\n\n    // Remove from body 2\n    if (contact.m_nodeB.prev) {\n      contact.m_nodeB.prev.next = contact.m_nodeB.next;\n    }\n\n    if (contact.m_nodeB.next) {\n      contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n    }\n\n    if (contact.m_nodeB == bodyB.m_contactList) {\n      bodyB.m_contactList = contact.m_nodeB.next;\n    }\n\n    if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n    }\n\n    // const typeA = fixtureA.getType();\n    // const typeB = fixtureB.getType();\n\n    // const destroyFcn = s_registers[typeA][typeB].destroyFcn;\n    // if (typeof destroyFcn === 'function') {\n    //   destroyFcn(contact);\n    // }\n\n    contactPool.release(contact);\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../util/options';\nimport { Vec2 } from '../common/Vec2';\nimport { BroadPhase } from '../collision/BroadPhase';\nimport { Solver, ContactImpulse, TimeStep } from './Solver';\nimport { Body, BodyDef } from './Body';\nimport { Joint } from './Joint';\nimport { Contact } from './Contact';\nimport { AABBValue, RayCastInput, RayCastOutput } from \"../collision/AABB\";\nimport { Fixture, FixtureProxy } from \"./Fixture\";\nimport { Manifold } from \"../collision/Manifold\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * @prop gravity [{ x : 0, y : 0}]\n * @prop allowSleep [true]\n * @prop warmStarting [true]\n * @prop continuousPhysics [true]\n * @prop subStepping [false]\n * @prop blockSolve [true]\n * @prop velocityIterations [8] For the velocity constraint solver.\n * @prop positionIterations [3] For the position constraint solver.\n */\nexport interface WorldDef {\n  gravity?: Vec2;\n  allowSleep?: boolean;\n  warmStarting?: boolean;\n  continuousPhysics?: boolean;\n  subStepping?: boolean;\n  blockSolve?: boolean;\n  velocityIterations?: number;\n  positionIterations?: number;\n}\n\n/** @internal */ const WorldDefDefault: WorldDef = {\n  gravity : Vec2.zero(),\n  allowSleep : true,\n  warmStarting : true,\n  continuousPhysics : true,\n  subStepping : false,\n  blockSolve : true,\n  velocityIterations : 8,\n  positionIterations : 3\n};\n\n/**\n * Callback function for ray casts, see {@link World.rayCast}.\n *\n * Called for each fixture found in the query. You control how the ray cast\n * proceeds by returning a float: return -1: ignore this fixture and continue\n * return 0: terminate the ray cast return fraction: clip the ray to this point\n * return 1: don't clip the ray and continue\n *\n * @param fixture The fixture hit by the ray\n * @param point The point of initial intersection\n * @param normal The normal vector at the point of intersection\n * @param fraction The fraction along the ray at the point of intersection\n *\n * @return `-1` to ignore the current fixture and continue\n * @return `0` to terminate the ray cast\n * @return `fraction` to clip the raycast at current point\n * @return `1` don't clip the ray and continue\n */\nexport type WorldRayCastCallback = (fixture: Fixture, point: Vec2, normal: Vec2, fraction: number) => number;\n\n/**\n * Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n */\nexport type WorldAABBQueryCallback = (fixture: Fixture) => boolean;\n\nexport class World {\n  /** @internal */ m_solver: Solver;\n  /** @internal */ m_broadPhase: BroadPhase;\n  /** @internal */ m_contactList: Contact | null;\n  /** @internal */ m_contactCount: number;\n  /** @internal */ m_bodyList: Body | null;\n  /** @internal */ m_bodyCount: number;\n  /** @internal */ m_jointList: Joint | null;\n  /** @internal */ m_jointCount: number;\n  /** @internal */ m_stepComplete: boolean;\n  /** @internal */ m_allowSleep: boolean;\n  /** @internal */ m_gravity: Vec2;\n  /** @internal */ m_clearForces: boolean;\n  /** @internal */ m_newFixture: boolean;\n  /** @internal */ m_locked: boolean;\n  /** @internal */ m_warmStarting: boolean;\n  /** @internal */ m_continuousPhysics: boolean;\n  /** @internal */ m_subStepping: boolean;\n  /** @internal */ m_blockSolve: boolean;\n  /** @internal */ m_velocityIterations: number;\n  /** @internal */ m_positionIterations: number;\n  /** @internal */ m_t: number;\n\n  // TODO\n  /** @internal */ _listeners: {\n    [key: string]: any[]\n  };\n\n  /**\n   * @param def World definition or gravity vector.\n   */\n  constructor(def?: WorldDef | Vec2 | null) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof World)) {\n      return new World(def);\n    }\n\n    this.s_step = new TimeStep();\n\n\n    if (def && Vec2.isValid(def)) {\n      def = { gravity: def as Vec2 };\n    }\n\n    def = options(def, WorldDefDefault) as WorldDef;\n\n    this.m_solver = new Solver(this);\n\n    this.m_broadPhase = new BroadPhase();\n\n    this.m_contactList = null;\n    this.m_contactCount = 0;\n\n    this.m_bodyList = null;\n    this.m_bodyCount = 0;\n\n    this.m_jointList = null;\n    this.m_jointCount = 0;\n\n    this.m_stepComplete = true;\n\n    this.m_allowSleep = def.allowSleep;\n    this.m_gravity = Vec2.clone(def.gravity);\n\n    this.m_clearForces = true;\n    this.m_newFixture = false;\n    this.m_locked = false;\n\n    // These are for debugging the solver.\n    this.m_warmStarting = def.warmStarting;\n    this.m_continuousPhysics = def.continuousPhysics;\n    this.m_subStepping = def.subStepping;\n\n    this.m_blockSolve = def.blockSolve;\n    this.m_velocityIterations = def.velocityIterations;\n    this.m_positionIterations = def.positionIterations;\n\n    this.m_t = 0;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const bodies = [];\n    const joints = [];\n\n    for (let b = this.getBodyList(); b; b = b.getNext()) {\n      bodies.push(b);\n    }\n\n    for (let j = this.getJointList(); j; j = j.getNext()) {\n      // @ts-ignore\n      if (typeof j._serialize === 'function') {\n        joints.push(j);\n      }\n    }\n\n    return {\n      gravity: this.m_gravity,\n      bodies,\n      joints,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, context: any, restore: any): World {\n    if (!data) {\n      return new World();\n    }\n\n    const world = new World(data.gravity);\n\n    if (data.bodies) {\n      for (let i = data.bodies.length - 1; i >= 0; i -= 1) {\n        world._addBody(restore(Body, data.bodies[i], world));\n      }\n    }\n\n    if (data.joints) {\n      for (let i = data.joints.length - 1; i >= 0; i--) {\n        world.createJoint(restore(Joint, data.joints[i], world));\n      }\n    }\n\n    return world;\n  }\n\n  /**\n   * Get the world body list. With the returned body, use Body.getNext to get the\n   * next body in the world list. A null body indicates the end of the list.\n   *\n   * @return the head of the world body list.\n   */\n  getBodyList(): Body | null {\n    return this.m_bodyList;\n  }\n\n  /**\n   * Get the world joint list. With the returned joint, use Joint.getNext to get\n   * the next joint in the world list. A null joint indicates the end of the list.\n   *\n   * @return the head of the world joint list.\n   */\n  getJointList(): Joint | null {\n    return this.m_jointList;\n  }\n\n  /**\n   * Get the world contact list. With the returned contact, use Contact.getNext to\n   * get the next contact in the world list. A null contact indicates the end of\n   * the list.\n   *\n   * Warning: contacts are created and destroyed in the middle of a time step.\n   * Use ContactListener to avoid missing contacts.\n   *\n   * @return the head of the world contact list.\n   */\n  getContactList(): Contact | null {\n    return this.m_contactList;\n  }\n\n  getBodyCount(): number {\n    return this.m_bodyCount;\n  }\n\n  getJointCount(): number {\n    return this.m_jointCount;\n  }\n\n  /**\n   * Get the number of contacts (each may have 0 or more contact points).\n   */\n  getContactCount(): number {\n    return this.m_contactCount;\n  }\n\n  /**\n   * Change the global gravity vector.\n   */\n  setGravity(gravity: Vec2): void {\n    this.m_gravity = gravity;\n  }\n\n  /**\n   * Get the global gravity vector.\n   */\n  getGravity(): Vec2 {\n    return this.m_gravity;\n  }\n\n  /**\n   * Is the world locked (in the middle of a time step).\n   */\n  isLocked(): boolean {\n    return this.m_locked;\n  }\n\n  /**\n   * Enable/disable sleep.\n   */\n  setAllowSleeping(flag: boolean): void {\n    if (flag == this.m_allowSleep) {\n      return;\n    }\n\n    this.m_allowSleep = flag;\n    if (this.m_allowSleep == false) {\n      for (let b = this.m_bodyList; b; b = b.m_next) {\n        b.setAwake(true);\n      }\n    }\n  }\n\n  getAllowSleeping(): boolean {\n    return this.m_allowSleep;\n  }\n\n  /**\n   * Enable/disable warm starting. For testing.\n   */\n  setWarmStarting(flag: boolean): void {\n    this.m_warmStarting = flag;\n  }\n\n  getWarmStarting(): boolean {\n    return this.m_warmStarting;\n  }\n\n  /**\n   * Enable/disable continuous physics. For testing.\n   */\n  setContinuousPhysics(flag: boolean): void {\n    this.m_continuousPhysics = flag;\n  }\n\n  getContinuousPhysics(): boolean {\n    return this.m_continuousPhysics;\n  }\n\n  /**\n   * Enable/disable single stepped continuous physics. For testing.\n   */\n  setSubStepping(flag: boolean): void {\n    this.m_subStepping = flag;\n  }\n\n  getSubStepping(): boolean {\n    return this.m_subStepping;\n  }\n\n  /**\n   * Set flag to control automatic clearing of forces after each time step.\n   */\n  setAutoClearForces(flag: boolean): void {\n    this.m_clearForces = flag;\n  }\n\n  /**\n   * Get the flag that controls automatic clearing of forces after each time step.\n   */\n  getAutoClearForces(): boolean {\n    return this.m_clearForces;\n  }\n\n  /**\n   * Manually clear the force buffer on all bodies. By default, forces are cleared\n   * automatically after each call to step. The default behavior is modified by\n   * calling setAutoClearForces. The purpose of this function is to support\n   * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step\n   * under a variable frame-rate. When you perform sub-stepping you will disable\n   * auto clearing of forces and instead call clearForces after all sub-steps are\n   * complete in one pass of your game loop.\n   *\n   * See {@link World.setAutoClearForces}\n   */\n  clearForces(): void {\n    for (let body = this.m_bodyList; body; body = body.getNext()) {\n      body.m_force.setZero();\n      body.m_torque = 0.0;\n    }\n  }\n\n  /**\n   * Query the world for all fixtures that potentially overlap the provided AABB.\n   *\n   * @param aabb The query box.\n   * @param callback Called for each fixture found in the query AABB. It may return `false` to terminate the query.\n   */\n  queryAABB(aabb: AABBValue, callback: WorldAABBQueryCallback): void {\n    _ASSERT && console.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n    this.m_broadPhase.query(aabb, function(proxyId: number): boolean { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      return callback(proxy.fixture);\n    });\n  }\n\n  /**\n   * Ray-cast the world for all fixtures in the path of the ray. Your callback\n   * controls whether you get the closest point, any point, or n-points. The\n   * ray-cast ignores shapes that contain the starting point.\n   *\n   * @param point1 The ray starting point\n   * @param point2 The ray ending point\n   * @param callback A user implemented callback function.\n   */\n  rayCast(point1: Vec2, point2: Vec2, callback: WorldRayCastCallback): void {\n    _ASSERT && console.assert(typeof callback === 'function');\n    const broadPhase = this.m_broadPhase;\n\n    this.m_broadPhase.rayCast({\n      maxFraction : 1.0,\n      p1 : point1,\n      p2 : point2\n    }, function(input: RayCastInput, proxyId: number): number { // TODO GC\n      const proxy = broadPhase.getUserData(proxyId);\n      const fixture = proxy.fixture;\n      const index = proxy.childIndex;\n      // @ts-ignore\n      const output: RayCastOutput = {}; // TODO GC\n      const hit = fixture.rayCast(output, input, index);\n      if (hit) {\n        const fraction = output.fraction;\n        const point = Vec2.add(Vec2.mulNumVec2((1.0 - fraction), input.p1), Vec2.mulNumVec2(fraction, input.p2));\n        return callback(fixture, point, output.normal, fraction);\n      }\n      return input.maxFraction;\n    });\n  }\n\n  /**\n   * Get the number of broad-phase proxies.\n   */\n  getProxyCount(): number {\n    return this.m_broadPhase.getProxyCount();\n  }\n\n  /**\n   * Get the height of broad-phase dynamic tree.\n   */\n  getTreeHeight(): number {\n    return this.m_broadPhase.getTreeHeight();\n  }\n\n  /**\n   * Get the balance of broad-phase dynamic tree.\n   */\n  getTreeBalance(): number {\n    return this.m_broadPhase.getTreeBalance();\n  }\n\n  /**\n   * Get the quality metric of broad-phase dynamic tree. The smaller the better.\n   * The minimum is 1.\n   */\n  getTreeQuality(): number {\n    return this.m_broadPhase.getTreeQuality();\n  }\n\n  /**\n   * Shift the world origin. Useful for large worlds. The body shift formula is:\n   * position -= newOrigin\n   *\n   * @param newOrigin The new origin with respect to the old origin\n   */\n  shiftOrigin(newOrigin: Vec2): void {\n    _ASSERT && console.assert(this.m_locked == false);\n    if (this.m_locked) {\n      return;\n    }\n\n    for (let b = this.m_bodyList; b; b = b.m_next) {\n      b.m_xf.p.sub(newOrigin);\n      b.m_sweep.c0.sub(newOrigin);\n      b.m_sweep.c.sub(newOrigin);\n    }\n\n    for (let j = this.m_jointList; j; j = j.m_next) {\n      j.shiftOrigin(newOrigin);\n    }\n\n    this.m_broadPhase.shiftOrigin(newOrigin);\n  }\n\n  /** @internal Used for deserialize. */\n  _addBody(body: Body): void {\n    _ASSERT && console.assert(this.isLocked() === false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Add to world doubly linked list.\n    body.m_prev = null;\n    body.m_next = this.m_bodyList;\n    if (this.m_bodyList) {\n      this.m_bodyList.m_prev = body;\n    }\n    this.m_bodyList = body;\n    ++this.m_bodyCount;\n  }\n\n  /**\n   * Create a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createBody(def?: BodyDef): Body;\n  createBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  /** @internal */ createBody(arg1?, arg2?) {\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n\n    const body = new Body(this, def);\n    this._addBody(body);\n    return body;\n  }\n\n  createDynamicBody(def?: BodyDef): Body;\n  createDynamicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  /** @internal */ createDynamicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'dynamic';\n    return this.createBody(def);\n  }\n\n  createKinematicBody(def?: BodyDef): Body;\n  createKinematicBody(position: Vec2, angle?: number): Body;\n  // tslint:disable-next-line:typedef\n  createKinematicBody(arg1?, arg2?) {\n    let def: BodyDef = {};\n    if (!arg1) {\n    } else if (Vec2.isValid(arg1)) {\n      def = { position : arg1, angle: arg2 };\n    } else if (typeof arg1 === 'object') {\n      def = arg1;\n    }\n    def.type = 'kinematic';\n    return this.createBody(def);\n  }\n\n  /**\n   * Destroy a rigid body given a definition. No reference to the definition is\n   * retained.\n   *\n   * Warning: This automatically deletes all associated shapes and joints.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  destroyBody(b: Body): boolean {\n    _ASSERT && console.assert(this.m_bodyCount > 0);\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    if (b.m_destroyed) {\n      return false;\n    }\n\n    // Delete the attached joints.\n    let je = b.m_jointList;\n    while (je) {\n      const je0 = je;\n      je = je.next;\n\n      this.publish('remove-joint', je0.joint);\n      this.destroyJoint(je0.joint);\n\n      b.m_jointList = je;\n    }\n    b.m_jointList = null;\n\n    // Delete the attached contacts.\n    let ce = b.m_contactList;\n    while (ce) {\n      const ce0 = ce;\n      ce = ce.next;\n\n      this.destroyContact(ce0.contact);\n\n      b.m_contactList = ce;\n    }\n    b.m_contactList = null;\n\n    // Delete the attached fixtures. This destroys broad-phase proxies.\n    let f = b.m_fixtureList;\n    while (f) {\n      const f0 = f;\n      f = f.m_next;\n\n      this.publish('remove-fixture', f0);\n      f0.destroyProxies(this.m_broadPhase);\n\n      b.m_fixtureList = f;\n    }\n    b.m_fixtureList = null;\n\n    // Remove world body list.\n    if (b.m_prev) {\n      b.m_prev.m_next = b.m_next;\n    }\n\n    if (b.m_next) {\n      b.m_next.m_prev = b.m_prev;\n    }\n\n    if (b == this.m_bodyList) {\n      this.m_bodyList = b.m_next;\n    }\n\n    b.m_destroyed = true;\n\n    --this.m_bodyCount;\n\n    this.publish('remove-body', b);\n\n    return true;\n  }\n\n  /**\n   * Create a joint to constrain bodies together. No reference to the definition\n   * is retained. This may cause the connected bodies to cease colliding.\n   *\n   * Warning: This function is locked during callbacks.\n   */\n  createJoint<T extends Joint>(joint: T): T | null {\n    _ASSERT && console.assert(!!joint.m_bodyA);\n    _ASSERT && console.assert(!!joint.m_bodyB);\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return null;\n    }\n\n    // Connect to the world list.\n    joint.m_prev = null;\n    joint.m_next = this.m_jointList;\n    if (this.m_jointList) {\n      this.m_jointList.m_prev = joint;\n    }\n    this.m_jointList = joint;\n    ++this.m_jointCount;\n\n    // Connect to the bodies' doubly linked lists.\n    joint.m_edgeA.joint = joint;\n    joint.m_edgeA.other = joint.m_bodyB;\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n    if (joint.m_bodyA.m_jointList)\n      joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n    joint.m_bodyA.m_jointList = joint.m_edgeA;\n\n    joint.m_edgeB.joint = joint;\n    joint.m_edgeB.other = joint.m_bodyA;\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n    if (joint.m_bodyB.m_jointList)\n      joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n    joint.m_bodyB.m_jointList = joint.m_edgeB;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      for (let edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n        if (edge.other == joint.m_bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n      }\n    }\n\n    // Note: creating a joint doesn't wake the bodies.\n\n    return joint;\n  }\n\n  /**\n   * Destroy a joint. This may cause the connected bodies to begin colliding.\n   * Warning: This function is locked during callbacks.\n   */\n  destroyJoint(joint: Joint): void {\n    _ASSERT && console.assert(this.isLocked() == false);\n    if (this.isLocked()) {\n      return;\n    }\n\n    // Remove from the doubly linked list.\n    if (joint.m_prev) {\n      joint.m_prev.m_next = joint.m_next;\n    }\n\n    if (joint.m_next) {\n      joint.m_next.m_prev = joint.m_prev;\n    }\n\n    if (joint == this.m_jointList) {\n      this.m_jointList = joint.m_next;\n    }\n\n    // Disconnect from bodies.\n    const bodyA = joint.m_bodyA;\n    const bodyB = joint.m_bodyB;\n\n    // Wake up connected bodies.\n    bodyA.setAwake(true);\n    bodyB.setAwake(true);\n\n    // Remove from body 1.\n    if (joint.m_edgeA.prev) {\n      joint.m_edgeA.prev.next = joint.m_edgeA.next;\n    }\n\n    if (joint.m_edgeA.next) {\n      joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n    }\n\n    if (joint.m_edgeA == bodyA.m_jointList) {\n      bodyA.m_jointList = joint.m_edgeA.next;\n    }\n\n    joint.m_edgeA.prev = null;\n    joint.m_edgeA.next = null;\n\n    // Remove from body 2\n    if (joint.m_edgeB.prev) {\n      joint.m_edgeB.prev.next = joint.m_edgeB.next;\n    }\n\n    if (joint.m_edgeB.next) {\n      joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n    }\n\n    if (joint.m_edgeB == bodyB.m_jointList) {\n      bodyB.m_jointList = joint.m_edgeB.next;\n    }\n\n    joint.m_edgeB.prev = null;\n    joint.m_edgeB.next = null;\n\n    _ASSERT && console.assert(this.m_jointCount > 0);\n    --this.m_jointCount;\n\n    // If the joint prevents collisions, then flag any contacts for filtering.\n    if (joint.m_collideConnected == false) {\n      let edge = bodyB.getContactList();\n      while (edge) {\n        if (edge.other == bodyA) {\n          // Flag the contact for filtering at the next time step (where either\n          // body is awake).\n          edge.contact.flagForFiltering();\n        }\n\n        edge = edge.next;\n      }\n    }\n\n    this.publish('remove-joint', joint);\n  }\n\n  /** @internal */\n  s_step: TimeStep; // reuse\n\n  /**\n   * Take a time step. This performs collision detection, integration, and\n   * constraint solution.\n   *\n   * Broad-phase, narrow-phase, solve and solve time of impacts.\n   *\n   * @param timeStep Time step, this should not vary.\n   */\n  step(timeStep: number, velocityIterations?: number, positionIterations?: number): void {\n    this.publish('pre-step', timeStep);\n\n    if ((velocityIterations | 0) !== velocityIterations) {\n      // TODO: remove this in future\n      velocityIterations = 0;\n    }\n\n    velocityIterations = velocityIterations || this.m_velocityIterations;\n    positionIterations = positionIterations || this.m_positionIterations;\n\n    // If new fixtures were added, we need to find the new contacts.\n    if (this.m_newFixture) {\n      this.findNewContacts();\n      this.m_newFixture = false;\n    }\n\n    this.m_locked = true;\n\n    this.s_step.reset(timeStep);\n    this.s_step.velocityIterations = velocityIterations;\n    this.s_step.positionIterations = positionIterations;\n    this.s_step.warmStarting = this.m_warmStarting;\n    this.s_step.blockSolve = this.m_blockSolve;\n\n    // Update contacts. This is where some contacts are destroyed.\n    this.updateContacts();\n\n    // Integrate velocities, solve velocity constraints, and integrate positions.\n    if (this.m_stepComplete && timeStep > 0.0) {\n      this.m_solver.solveWorld(this.s_step);\n\n      // Synchronize fixtures, check for out of range bodies.\n      for (let b = this.m_bodyList; b; b = b.getNext()) {\n        // If a body was not in an island then it did not move.\n        if (b.m_islandFlag == false) {\n          continue;\n        }\n\n        if (b.isStatic()) {\n          continue;\n        }\n\n        // Update fixtures (for broad-phase).\n        b.synchronizeFixtures();\n      }\n      // Look for new contacts.\n      this.findNewContacts();\n    }\n\n    // Handle TOI events.\n    if (this.m_continuousPhysics && timeStep > 0.0) {\n      this.m_solver.solveWorldTOI(this.s_step);\n    }\n\n    if (this.m_clearForces) {\n      this.clearForces();\n    }\n\n    this.m_locked = false;\n\n    this.publish('post-step', timeStep);\n  }\n\n  /**\n   * @internal\n   * Call this method to find new contacts.\n   */\n  findNewContacts(): void {\n    this.m_broadPhase.updatePairs(\n      (proxyA: FixtureProxy, proxyB: FixtureProxy) => this.createContact(proxyA, proxyB)\n    );\n  }\n\n  /**\n   * @internal\n   * Callback for broad-phase.\n   */\n  createContact(proxyA: FixtureProxy, proxyB: FixtureProxy): void {\n    const fixtureA = proxyA.fixture;\n    const fixtureB = proxyB.fixture;\n\n    const indexA = proxyA.childIndex;\n    const indexB = proxyB.childIndex;\n\n    const bodyA = fixtureA.getBody();\n    const bodyB = fixtureB.getBody();\n\n    // Are the fixtures on the same body?\n    if (bodyA == bodyB) {\n      return;\n    }\n\n    // TODO_ERIN use a hash table to remove a potential bottleneck when both\n    // bodies have a lot of contacts.\n    // Does a contact already exist?\n    let edge = bodyB.getContactList(); // ContactEdge\n    while (edge) {\n      if (edge.other == bodyA) {\n        const fA = edge.contact.getFixtureA();\n        const fB = edge.contact.getFixtureB();\n        const iA = edge.contact.getChildIndexA();\n        const iB = edge.contact.getChildIndexB();\n\n        if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n          // A contact already exists.\n          return;\n        }\n\n        if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n          // A contact already exists.\n          return;\n        }\n      }\n\n      edge = edge.next;\n    }\n\n    if (bodyB.shouldCollide(bodyA) == false) {\n      return;\n    }\n    if (fixtureB.shouldCollide(fixtureA) == false) {\n      return;\n    }\n\n    // Call the factory.\n    const contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n    if (contact == null) {\n      return;\n    }\n\n    // Insert into the world.\n    contact.m_prev = null;\n    if (this.m_contactList != null) {\n      contact.m_next = this.m_contactList;\n      this.m_contactList.m_prev = contact;\n    }\n    this.m_contactList = contact;\n\n    ++this.m_contactCount;\n  }\n\n  /**\n   * @internal\n   * Removes old non-overlapping contacts, applies filters and updates contacts.\n   */\n  updateContacts(): void {\n    // Update awake contacts.\n    let c: Contact;\n    let next_c = this.m_contactList;\n    while (c = next_c) {\n      next_c = c.getNext();\n      const fixtureA = c.getFixtureA();\n      const fixtureB = c.getFixtureB();\n      const indexA = c.getChildIndexA();\n      const indexB = c.getChildIndexB();\n      const bodyA = fixtureA.getBody();\n      const bodyB = fixtureB.getBody();\n\n      // Is this contact flagged for filtering?\n      if (c.m_filterFlag) {\n        if (bodyB.shouldCollide(bodyA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        if (fixtureB.shouldCollide(fixtureA) == false) {\n          this.destroyContact(c);\n          continue;\n        }\n\n        // Clear the filtering flag.\n        c.m_filterFlag = false;\n      }\n\n      const activeA = bodyA.isAwake() && !bodyA.isStatic();\n      const activeB = bodyB.isAwake() && !bodyB.isStatic();\n\n      // At least one body must be awake and it must be dynamic or kinematic.\n      if (activeA == false && activeB == false) {\n        continue;\n      }\n\n      const proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n      const proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n      const overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n\n      // Here we destroy contacts that cease to overlap in the broad-phase.\n      if (overlap == false) {\n        this.destroyContact(c);\n        continue;\n      }\n\n      // The contact persists.\n      c.update(this);\n    }\n  }\n\n  /** @internal */\n  destroyContact(contact: Contact): void {\n    // Remove from the world.\n    if (contact.m_prev) {\n      contact.m_prev.m_next = contact.m_next;\n    }\n    if (contact.m_next) {\n      contact.m_next.m_prev = contact.m_prev;\n    }\n    if (contact == this.m_contactList) {\n      this.m_contactList = contact.m_next;\n    }\n\n    Contact.destroy(contact, this);\n\n    --this.m_contactCount;\n  }\n\n\n  /**\n   * Called when two fixtures begin to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  /**\n   * Called when two fixtures cease to touch.\n   *\n   * Implement contact callbacks to get contact information. You can use these\n   * results for things like sounds and game logic. You can also get contact\n   * results by traversing the contact lists after the time step. However, you\n   * might miss some contacts because continuous physics leads to sub-stepping.\n   * Additionally you may receive multiple callbacks for the same contact in a\n   * single time step. You should strive to make your callbacks efficient because\n   * there may be many callbacks per time step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'end-contact', listener: (contact: Contact) => void): World;\n  /**\n   * This is called after a contact is updated. This allows you to inspect a\n   * contact before it goes to the solver. If you are careful, you can modify the\n   * contact manifold (e.g. disable contact). A copy of the old manifold is\n   * provided so that you can detect changes. Note: this is called only for awake\n   * bodies. Note: this is called even when the number of contact points is zero.\n   * Note: this is not called for sensors. Note: if you set the number of contact\n   * points to zero, you will not get an endContact callback. However, you may get\n   * a beginContact callback the next step.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  /**\n   * This lets you inspect a contact after the solver is finished. This is useful\n   * for inspecting impulses. Note: the contact manifold does not include time of\n   * impact impulses, which can be arbitrarily large if the sub-step is small.\n   * Hence the impulse is provided explicitly in a separate data structure. Note:\n   * this is only called for contacts that are touching, solid, and awake.\n   *\n   * Warning: You cannot create/destroy world entities inside these callbacks.\n   */\n  on(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  /** Listener is called whenever a body is removed. */\n  on(name: 'remove-body', listener: (body: Body) => void): World;\n  /** Listener is called whenever a joint is removed implicitly or explicitly. */\n  on(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  /** Listener is called whenever a fixture is removed implicitly or explicitly. */\n  on(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Register an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  on(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    if (!this._listeners) {\n      this._listeners = {};\n    }\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    this._listeners[name].push(listener);\n    return this;\n  }\n\n  off(name: 'begin-contact', listener: (contact: Contact) => void): World;\n  off(name: 'end-contact', listener: (contact: Contact) => void): World;\n  off(name: 'pre-solve', listener: (contact: Contact, oldManifold: Manifold) => void): World;\n  off(name: 'post-solve', listener: (contact: Contact, impulse: ContactImpulse) => void): World;\n  off(name: 'remove-body', listener: (body: Body) => void): World;\n  off(name: 'remove-joint', listener: (joint: Joint) => void): World;\n  off(name: 'remove-fixture', listener: (fixture: Fixture) => void): World;\n  /**\n   * Remove an event listener.\n   */\n  // tslint:disable-next-line:typedef\n  off(name, listener) {\n    if (typeof name !== 'string' || typeof listener !== 'function') {\n      return this;\n    }\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return this;\n    }\n    const index = listeners.indexOf(listener);\n    if (index >= 0) {\n      listeners.splice(index, 1);\n    }\n    return this;\n  }\n\n  publish(name: string, arg1?: any, arg2?: any, arg3?: any): number {\n    const listeners = this._listeners && this._listeners[name];\n    if (!listeners || !listeners.length) {\n      return 0;\n    }\n    for (let l = 0; l < listeners.length; l++) {\n      listeners[l].call(this, arg1, arg2, arg3);\n    }\n    return listeners.length;\n  }\n\n  /** @internal */\n  beginContact(contact: Contact): void {\n    this.publish('begin-contact', contact);\n  }\n\n  /** @internal */\n  endContact(contact: Contact): void {\n    this.publish('end-contact', contact);\n  }\n\n  /** @internal */\n  preSolve(contact: Contact, oldManifold: Manifold): void {\n    this.publish('pre-solve', contact, oldManifold);\n  }\n\n  /** @internal */\n  postSolve(contact: Contact, impulse: ContactImpulse): void {\n    this.publish('post-solve', contact, impulse);\n  }\n\n  /**\n   * Joints and fixtures are destroyed when their associated body is destroyed.\n   * Register a destruction listener so that you may nullify references to these\n   * joints and shapes.\n   *\n   * `function(object)` is called when any joint or fixture is about to\n   * be destroyed due to the destruction of one of its attached or parent bodies.\n   */\n\n  /**\n   * Register a contact filter to provide specific control over collision.\n   * Otherwise the default filter is used (defaultFilter). The listener is owned\n   * by you and must remain in scope.\n   *\n   * Moved to Fixture.\n   */\n}", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\nexport interface Vec3Value {\n  x: number;\n  y: number;\n  z: number;\n}\n\nexport class Vec3 {\n  x: number;\n  y: number;\n  z: number;\n\n  constructor(x: number, y: number, z: number);\n  constructor(obj: { x: number, y: number, z: number });\n  constructor();\n  constructor(x?, y?, z?) {\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof Vec3)) {\n      return new Vec3(x, y, z);\n    }\n    if (typeof x === 'undefined') {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n    } else if (typeof x === 'object') {\n      this.x = x.x;\n      this.y = x.y;\n      this.z = x.z;\n    } else {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n    }\n    _ASSERT && Vec3.assert(this);\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      x: this.x,\n      y: this.y,\n      z: this.z\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = data.x;\n    obj.y = data.y;\n    obj.z = data.z;\n    return obj;\n  }\n\n  /** @internal */\n  static neo(x: number, y: number, z: number): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = x;\n    obj.y = y;\n    obj.z = z;\n    return obj;\n  }\n\n  static zero(): Vec3 {\n    const obj = Object.create(Vec3.prototype);\n    obj.x = 0;\n    obj.y = 0;\n    obj.z = 0;\n    return obj;\n  }\n\n  static clone(v: Vec3Value): Vec3 {\n    _ASSERT && Vec3.assert(v);\n    return Vec3.neo(v.x, v.y, v.z);\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  /** Does this vector contain finite coordinates? */\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Number.isFinite(obj.x) && Number.isFinite(obj.y) && Number.isFinite(obj.z);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Vec3.isValid(o), 'Invalid Vec3!', o);\n  }\n\n  setZero(): Vec3 {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = 0.0;\n    return this;\n  }\n\n  set(x: number, y: number, z: number): Vec3 {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n\n  add(w: Vec3Value): Vec3 {\n    this.x += w.x;\n    this.y += w.y;\n    this.z += w.z;\n    return this;\n  }\n\n  sub(w: Vec3Value): Vec3 {\n    this.x -= w.x;\n    this.y -= w.y;\n    this.z -= w.z;\n    return this;\n  }\n\n  mul(m: number): Vec3 {\n    this.x *= m;\n    this.y *= m;\n    this.z *= m;\n    return this;\n  }\n\n  static areEqual(v: Vec3Value, w: Vec3Value): boolean {\n    _ASSERT && Vec3.assert(v);\n    _ASSERT && Vec3.assert(w);\n    return v === w ||\n      typeof v === 'object' && v !== null &&\n      typeof w === 'object' && w !== null &&\n      v.x === w.x && v.y === w.y && v.z === w.z;\n  }\n\n  /** Dot product on two vectors */\n  static dot(v: Vec3Value, w: Vec3Value): number {\n    return v.x * w.x + v.y * w.y + v.z * w.z;\n  }\n\n  /** Cross product on two vectors */\n  static cross(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(\n      v.y * w.z - v.z * w.y,\n      v.z * w.x - v.x * w.z,\n      v.x * w.y - v.y * w.x\n    );\n  }\n\n  static add(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);\n  }\n\n  static sub(v: Vec3Value, w: Vec3Value): Vec3 {\n    return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);\n  }\n\n  static mul(v: Vec3Value, m: number): Vec3 {\n    return new Vec3(m * v.x, m * v.y, m * v.z);\n  }\n\n  neg(): Vec3 {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n\n  static neg(v: Vec3Value): Vec3 {\n    return new Vec3(-v.x, -v.y, -v.z);\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../../Settings';\nimport * as matrix from '../../common/Matrix';\nimport { Shape } from '../Shape';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { AABB, AABBValue, RayCastInput, RayCastOutput } from '../AABB';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/** @internal */ const v1 = matrix.vec2(0, 0);\n/** @internal */ const v2 = matrix.vec2(0, 0);\n\n/**\n * A line segment (edge) shape. These can be connected in chains or loops to\n * other edge shapes. The connectivity information is used to ensure correct\n * contact normals.\n */\nexport class EdgeShape extends Shape {\n  static TYPE = 'edge' as const;\n  m_type: 'edge';\n\n  m_radius: number;\n\n  // These are the edge vertices\n  m_vertex1: Vec2;\n  m_vertex2: Vec2;\n\n  // Optional adjacent vertices. These are used for smooth collision.\n  // Used by chain shape.\n  m_vertex0: Vec2;\n  m_vertex3: Vec2;\n  m_hasVertex0: boolean;\n  m_hasVertex3: boolean;\n\n  constructor(v1?: Vec2Value, v2?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof EdgeShape)) {\n      return new EdgeShape(v1, v2);\n    }\n\n    super();\n\n    this.m_type = EdgeShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n\n    this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();\n    this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();\n\n    this.m_vertex0 = Vec2.zero();\n    this.m_vertex3 = Vec2.zero();\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertex1: this.m_vertex1,\n      vertex2: this.m_vertex2,\n\n      vertex0: this.m_vertex0,\n      vertex3: this.m_vertex3,\n      hasVertex0: this.m_hasVertex0,\n      hasVertex3: this.m_hasVertex3,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): EdgeShape {\n    const shape = new EdgeShape(data.vertex1, data.vertex2);\n    if (shape.m_hasVertex0) {\n      shape.setPrevVertex(data.vertex0);\n    }\n    if (shape.m_hasVertex3) {\n      shape.setNextVertex(data.vertex3);\n    }\n    return shape;\n  }\n\n  /** @internal */\n  _reset(): void {\n    // noop\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getType(): 'edge' {\n    return this.m_type;\n  }\n\n  /** @internal @deprecated */\n  setNext(v?: Vec2): EdgeShape {\n    return this.setNextVertex(v);\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  setNextVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex3.setVec2(v);\n      this.m_hasVertex3 = true;\n    } else {\n      this.m_vertex3.setZero();\n      this.m_hasVertex3 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional next vertex, used for smooth collision.\n   */\n  getNextVertex(): Vec2 {\n    return this.m_vertex3;\n  }\n\n  /** @internal @deprecated */\n  setPrev(v?: Vec2): EdgeShape {\n    return this.setPrevVertex(v);\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  setPrevVertex(v?: Vec2): EdgeShape {\n    if (v) {\n      this.m_vertex0.setVec2(v);\n      this.m_hasVertex0 = true;\n    } else {\n      this.m_vertex0.setZero();\n      this.m_hasVertex0 = false;\n    }\n    return this;\n  }\n\n  /**\n   * Optional prev vertex, used for smooth collision.\n   */\n  getPrevVertex(): Vec2 {\n    return this.m_vertex0;\n  }\n\n  /**\n   * Set this as an isolated edge.\n   */\n  _set(v1: Vec2, v2: Vec2): EdgeShape {\n    this.m_vertex1.setVec2(v1);\n    this.m_vertex2.setVec2(v2);\n    this.m_hasVertex0 = false;\n    this.m_hasVertex3 = false;\n    return this;\n  }\n\n  /**\n   * @internal @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): EdgeShape {\n    const clone = new EdgeShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_vertex1.setVec2(this.m_vertex1);\n    clone.m_vertex2.setVec2(this.m_vertex2);\n    clone.m_vertex0.setVec2(this.m_vertex0);\n    clone.m_vertex3.setVec2(this.m_vertex3);\n    clone.m_hasVertex0 = this.m_hasVertex0;\n    clone.m_hasVertex3 = this.m_hasVertex3;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // p = p1 + t * d\n    // v = v1 + s * e\n    // p1 + t * d = v1 + s * e\n    // s * e - t * d = p1 - v1\n\n    // NOT_USED(childIndex);\n\n    // Put the ray into the edge's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    const v1 = this.m_vertex1;\n    const v2 = this.m_vertex2;\n    const e = Vec2.sub(v2, v1);\n    const normal = Vec2.neo(e.y, -e.x);\n    normal.normalize();\n\n    // q = p1 + t * d\n    // dot(normal, q - v1) = 0\n    // dot(normal, p1 - v1) + t * dot(normal, d) = 0\n    const numerator = Vec2.dot(normal, Vec2.sub(v1, p1));\n    const denominator = Vec2.dot(normal, d);\n\n    if (denominator == 0.0) {\n      return false;\n    }\n\n    const t = numerator / denominator;\n    if (t < 0.0 || input.maxFraction < t) {\n      return false;\n    }\n\n    const q = Vec2.add(p1, Vec2.mulNumVec2(t, d));\n\n    // q = v1 + s * r\n    // s = dot(q - v1, r) / dot(r, r)\n    const r = Vec2.sub(v2, v1);\n    const rr = Vec2.dot(r, r);\n    if (rr == 0.0) {\n      return false;\n    }\n\n    const s = Vec2.dot(Vec2.sub(q, v1), r) / rr;\n    if (s < 0.0 || 1.0 < s) {\n      return false;\n    }\n\n    output.fraction = t;\n    if (numerator > 0.0) {\n      output.normal = Rot.mulVec2(xf.q, normal).neg();\n    } else {\n      output.normal = Rot.mulVec2(xf.q, normal);\n    }\n    return true;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    matrix.transformVec2(v1, xf, this.m_vertex1);\n    matrix.transformVec2(v2, xf, this.m_vertex2);\n\n    AABB.combinePoints(aabb, v1, v2);\n    AABB.extend(aabb, this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    matrix.combineVec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices[0] = this.m_vertex1;\n    proxy.m_vertices[1] = this.m_vertex2;\n    proxy.m_vertices.length = 2;\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Edge = EdgeShape;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport type { MassData } from '../../dynamics/Body';\nimport { AABBValue, RayCastOutput, RayCastInput, AABB } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Shape } from '../Shape';\nimport { EdgeShape } from './EdgeShape';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n/** @internal */ const v1 = matrix.vec2(0, 0);\n/** @internal */ const v2 = matrix.vec2(0, 0);\n\n\n/**\n * A chain shape is a free form sequence of line segments. The chain has\n * two-sided collision, so you can use inside and outside collision. Therefore,\n * you may use any winding order. Connectivity information is used to create\n * smooth collisions.\n *\n * WARNING: The chain will not collide properly if there are self-intersections.\n */\nexport class ChainShape extends Shape {\n  static TYPE = 'chain' as const;\n  m_type: 'chain';\n\n  m_radius: number;\n\n  m_vertices: Vec2[];\n  m_count: number;\n  m_prevVertex: Vec2 | null;\n  m_nextVertex: Vec2 | null;\n  m_hasPrevVertex: boolean;\n  m_hasNextVertex: boolean;\n\n  m_isLoop: boolean;\n\n  constructor(vertices?: Vec2Value[], loop?: boolean) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof ChainShape)) {\n      return new ChainShape(vertices, loop);\n    }\n\n    super();\n\n    this.m_type = ChainShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_vertices = [];\n    this.m_count = 0;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n\n    this.m_isLoop = !!loop;\n\n    if (vertices && vertices.length) {\n      if (loop) {\n        this._createLoop(vertices);\n      } else {\n        this._createChain(vertices);\n      }\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    const data = {\n      type: this.m_type,\n      vertices: this.m_vertices,\n      isLoop: this.m_isLoop,\n      hasPrevVertex: this.m_hasPrevVertex,\n      hasNextVertex: this.m_hasNextVertex,\n      prevVertex: null as Vec2 | null,\n      nextVertex: null as Vec2 | null,\n    };\n    if (this.m_prevVertex) {\n      data.prevVertex = this.m_prevVertex;\n    }\n    if (this.m_nextVertex) {\n      data.nextVertex = this.m_nextVertex;\n    }\n    return data;\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): ChainShape {\n    const vertices: Vec2[] = [];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n    const shape = new ChainShape(vertices, data.isLoop);\n    if (data.prevVertex) {\n      shape.setPrevVertex(data.prevVertex);\n    }\n    if (data.nextVertex) {\n      shape.setNextVertex(data.nextVertex);\n    }\n    return shape;\n  }\n\n  // clear() {\n  //   this.m_vertices.length = 0;\n  //   this.m_count = 0;\n  // }\n\n  getType(): 'chain' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * @internal\n   * Create a loop. This automatically adjusts connectivity.\n   *\n   * @param vertices an array of vertices, these are copied\n   * @param count the vertex count\n   */\n  _createLoop(vertices: Vec2Value[]): ChainShape {\n    _ASSERT && console.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && console.assert(vertices.length >= 3);\n    if (vertices.length < 3) {\n      return;\n    }\n\n    for (let i = 1; i < vertices.length; ++i) {\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      // If the code crashes here, it means your vertices are too close together.\n      _ASSERT && console.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_vertices = [];\n    this.m_count = vertices.length + 1;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n    this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n\n    this.m_prevVertex = this.m_vertices[this.m_count - 2];\n    this.m_nextVertex = this.m_vertices[1];\n    this.m_hasPrevVertex = true;\n    this.m_hasNextVertex = true;\n    return this;\n  }\n\n  /**\n   * @internal\n   * Create a chain with isolated end vertices.\n   *\n   * @param vertices an array of vertices, these are copied\n   */\n  _createChain(vertices: Vec2Value[]): ChainShape {\n    _ASSERT && console.assert(this.m_vertices.length == 0 && this.m_count == 0);\n    _ASSERT && console.assert(vertices.length >= 2);\n    for (let i = 1; i < vertices.length; ++i) {\n      // If the code crashes here, it means your vertices are too close together.\n      const v1 = vertices[i - 1];\n      const v2 = vertices[i];\n      _ASSERT && console.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);\n    }\n\n    this.m_count = vertices.length;\n    for (let i = 0; i < vertices.length; ++i) {\n      this.m_vertices[i] = Vec2.clone(vertices[i]);\n    }\n\n    this.m_hasPrevVertex = false;\n    this.m_hasNextVertex = false;\n    this.m_prevVertex = null;\n    this.m_nextVertex = null;\n    return this;\n  }\n\n  /** @internal */\n  _reset(): void {\n    if (this.m_isLoop) {\n      this._createLoop(this.m_vertices);\n    } else {\n      this._createChain(this.m_vertices);\n    }\n  }\n\n  /**\n   * Establish connectivity to a vertex that precedes the first vertex. Don't call\n   * this for loops.\n   */\n  setPrevVertex(prevVertex: Vec2): void {\n    this.m_prevVertex = prevVertex;\n    this.m_hasPrevVertex = true;\n  }\n\n  getPrevVertex(): Vec2 {\n    return this.m_prevVertex;\n  }\n\n  /**\n   * Establish connectivity to a vertex that follows the last vertex. Don't call\n   * this for loops.\n   */\n  setNextVertex(nextVertex: Vec2): void {\n    this.m_nextVertex = nextVertex;\n    this.m_hasNextVertex = true;\n  }\n\n  getNextVertex(): Vec2 {\n    return this.m_nextVertex;\n  }\n\n  /**\n   * @internal @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): ChainShape {\n    const clone = new ChainShape();\n    clone._createChain(this.m_vertices);\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_prevVertex = this.m_prevVertex;\n    clone.m_nextVertex = this.m_nextVertex;\n    clone.m_hasPrevVertex = this.m_hasPrevVertex;\n    clone.m_hasNextVertex = this.m_hasNextVertex;\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): number {\n    // edge count = vertex count - 1\n    return this.m_count - 1;\n  }\n\n  // Get a child edge.\n  getChildEdge(edge: EdgeShape, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count - 1);\n    edge.m_type = EdgeShape.TYPE;\n    edge.m_radius = this.m_radius;\n\n    edge.m_vertex1 = this.m_vertices[childIndex];\n    edge.m_vertex2 = this.m_vertices[childIndex + 1];\n\n    if (childIndex > 0) {\n      edge.m_vertex0 = this.m_vertices[childIndex - 1];\n      edge.m_hasVertex0 = true;\n    } else {\n      edge.m_vertex0 = this.m_prevVertex;\n      edge.m_hasVertex0 = this.m_hasPrevVertex;\n    }\n\n    if (childIndex < this.m_count - 2) {\n      edge.m_vertex3 = this.m_vertices[childIndex + 2];\n      edge.m_hasVertex3 = true;\n    } else {\n      edge.m_vertex3 = this.m_nextVertex;\n      edge.m_hasVertex3 = this.m_hasNextVertex;\n    }\n  }\n\n  getVertex(index: number): Vec2 {\n    _ASSERT && console.assert(0 <= index && index <= this.m_count);\n    if (index < this.m_count) {\n      return this.m_vertices[index];\n    } else {\n      return this.m_vertices[0];\n    }\n  }\n\n  isLoop(): boolean {\n    return this.m_isLoop;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * This always return false.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): false {\n    return false;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n\n    const edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n    return edgeShape.rayCast(output, input, xf, 0);\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n\n    matrix.transformVec2(v1, xf, this.getVertex(childIndex));\n    matrix.transformVec2(v2, xf, this.getVertex(childIndex + 1));\n\n    AABB.combinePoints(aabb, v1, v2);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * Chains have zero mass.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density?: number): void {\n    massData.mass = 0.0;\n    matrix.zeroVec2(massData.center)\n    massData.I = 0.0;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy, childIndex: number): void {\n    _ASSERT && console.assert(0 <= childIndex && childIndex < this.m_count);\n    proxy.m_vertices[0] = this.getVertex(childIndex);\n    proxy.m_vertices[1] = this.getVertex(childIndex + 1);\n    proxy.m_count = 2;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Chain = ChainShape;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport type { MassData } from '../../dynamics/Body';\nimport { RayCastOutput, RayCastInput, AABBValue } from '../AABB';\nimport { DistanceProxy } from '../Distance';\nimport { EPSILON } from '../../common/Math';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Shape } from '../Shape';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_max = Math.max;\n/** @internal */ const math_min = Math.min;\n\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const e = matrix.vec2(0, 0);\n/** @internal */ const e1 = matrix.vec2(0, 0);\n/** @internal */ const e2 = matrix.vec2(0, 0);\n/** @internal */ const center = matrix.vec2(0, 0);\n/** @internal */ const s = matrix.vec2(0, 0);\n\n/**\n * A convex polygon. It is assumed that the interior of the polygon is to the\n * left of each edge. Polygons have a maximum number of vertices equal to\n * Settings.maxPolygonVertices. In most cases you should not need many vertices\n * for a convex polygon. extends Shape\n */\nexport class PolygonShape extends Shape {\n  static TYPE = 'polygon' as const;\n  m_type: 'polygon';\n\n  m_centroid: Vec2;\n  m_vertices: Vec2[]; // [Settings.maxPolygonVertices]\n  m_normals: Vec2[]; // [Settings.maxPolygonVertices]\n  m_count: number;\n  m_radius: number;\n\n  constructor(vertices?: Vec2Value[]) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PolygonShape)) {\n      return new PolygonShape(vertices);\n    }\n\n    super();\n\n    this.m_type = PolygonShape.TYPE;\n    this.m_radius = Settings.polygonRadius;\n    this.m_centroid = Vec2.zero();\n    this.m_vertices = [];\n    this.m_normals = [];\n    this.m_count = 0;\n\n    if (vertices && vertices.length) {\n      this._set(vertices);\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      vertices: this.m_vertices,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, fixture: any, restore: any): PolygonShape {\n    const vertices: Vec2[] = [];\n    if (data.vertices) {\n      for (let i = 0; i < data.vertices.length; i++) {\n        vertices.push(restore(Vec2, data.vertices[i]));\n      }\n    }\n\n    const shape = new PolygonShape(vertices);\n    return shape;\n  }\n\n  getType(): 'polygon' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  /**\n   * @internal @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): PolygonShape {\n    const clone = new PolygonShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_count = this.m_count;\n    clone.m_centroid.setVec2(this.m_centroid);\n    for (let i = 0; i < this.m_count; i++) {\n      clone.m_vertices.push(this.m_vertices[i].clone());\n    }\n    for (let i = 0; i < this.m_normals.length; i++) {\n      clone.m_normals.push(this.m_normals[i].clone());\n    }\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /** @internal */ _reset(): void {\n    this._set(this.m_vertices);\n  }\n\n  /**\n   * @internal\n   *\n   * Create a convex hull from the given array of local points. The count must be\n   * in the range [3, Settings.maxPolygonVertices].\n   *\n   * Warning: the points may be re-ordered, even if they form a convex polygon\n   * Warning: collinear points are handled but not removed. Collinear points may\n   * lead to poor stacking behavior.\n   */\n  _set(vertices: Vec2Value[]): void {\n    _ASSERT && console.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);\n    if (vertices.length < 3) {\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    let n = math_min(vertices.length, Settings.maxPolygonVertices);\n\n    // Perform welding and copy vertices into local buffer.\n    const ps: Vec2[] = []; // [Settings.maxPolygonVertices];\n    for (let i = 0; i < n; ++i) {\n      const v = vertices[i];\n\n      let unique = true;\n      for (let j = 0; j < ps.length; ++j) {\n        if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {\n          unique = false;\n          break;\n        }\n      }\n\n      if (unique) {\n        ps.push(Vec2.clone(v));\n      }\n    }\n\n    n = ps.length;\n    if (n < 3) {\n      // Polygon is degenerate.\n      _ASSERT && console.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    // Create the convex hull using the Gift wrapping algorithm\n    // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm\n\n    // Find the right most point on the hull (in case of multiple points bottom most is used)\n    let i0 = 0;\n    let x0 = ps[0].x;\n    for (let i = 1; i < n; ++i) {\n      const x = ps[i].x;\n      if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {\n        i0 = i;\n        x0 = x;\n      }\n    }\n\n    const hull = [] as number[]; // [Settings.maxPolygonVertices];\n    let m = 0;\n    let ih = i0;\n\n    while (true) {\n      _ASSERT && console.assert(m < Settings.maxPolygonVertices);\n      hull[m] = ih;\n\n      let ie = 0;\n      for (let j = 1; j < n; ++j) {\n        if (ie === ih) {\n          ie = j;\n          continue;\n        }\n\n        const r = Vec2.sub(ps[ie], ps[hull[m]]);\n        const v = Vec2.sub(ps[j], ps[hull[m]]);\n        const c = Vec2.crossVec2Vec2(r, v);\n        // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping\n        if (c < 0.0) {\n          ie = j;\n        }\n\n        // Collinearity check\n        if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {\n          ie = j;\n        }\n      }\n\n      ++m;\n      ih = ie;\n\n      if (ie === i0) {\n        break;\n      }\n    }\n\n    if (m < 3) {\n      // Polygon is degenerate.\n      _ASSERT && console.assert(false);\n      this._setAsBox(1.0, 1.0);\n      return;\n    }\n\n    this.m_count = m;\n\n    // Copy vertices.\n    this.m_vertices = [];\n    for (let i = 0; i < m; ++i) {\n      this.m_vertices[i] = ps[hull[i]];\n    }\n\n    // Compute normals. Ensure the edges have non-zero length.\n    for (let i = 0; i < m; ++i) {\n      const i1 = i;\n      const i2 = i + 1 < m ? i + 1 : 0;\n      const edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n      _ASSERT && console.assert(edge.lengthSquared() > EPSILON * EPSILON);\n      this.m_normals[i] = Vec2.crossVec2Num(edge, 1.0);\n      this.m_normals[i].normalize();\n    }\n\n    // Compute the polygon centroid.\n    this.m_centroid = computeCentroid(this.m_vertices, m);\n  }\n\n  /** @internal */ _setAsBox(hx: number, hy: number, center?: Vec2Value, angle?: number): void {\n    // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()\n    this.m_vertices[0] = Vec2.neo(hx, -hy);\n    this.m_vertices[1] = Vec2.neo(hx, hy);\n    this.m_vertices[2] = Vec2.neo(-hx, hy);\n    this.m_vertices[3] = Vec2.neo(-hx, -hy);\n\n    this.m_normals[0] = Vec2.neo(1.0, 0.0);\n    this.m_normals[1] = Vec2.neo(0.0, 1.0);\n    this.m_normals[2] = Vec2.neo(-1.0, 0.0);\n    this.m_normals[3] = Vec2.neo(0.0, -1.0);\n\n    this.m_count = 4;\n\n    if (center && Vec2.isValid(center)) {\n      angle = angle || 0;\n\n      matrix.copyVec2(this.m_centroid, center);\n\n      const xf = Transform.identity();\n      xf.p.setVec2(center);\n      xf.q.setAngle(angle);\n\n      // Transform vertices and normals.\n      for (let i = 0; i < this.m_count; ++i) {\n        this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);\n        this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);\n      }\n    }\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2): boolean {\n    const pLocal = matrix.invTransformVec2(temp, xf, p);\n\n    for (let i = 0; i < this.m_count; ++i) {\n      const dot = matrix.dotVec2(this.m_normals[i], pLocal) - matrix.dotVec2(this.m_normals[i], this.m_vertices[i]);\n      if (dot > 0.0) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n\n    // Put the ray into the polygon's frame of reference.\n    const p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));\n    const p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));\n    const d = Vec2.sub(p2, p1);\n\n    let lower = 0.0;\n    let upper = input.maxFraction;\n\n    let index = -1;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // p = p1 + a * d\n      // dot(normal, p - v) = 0\n      // dot(normal, p1 - v) + a * dot(normal, d) = 0\n      const numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n      const denominator = Vec2.dot(this.m_normals[i], d);\n\n      if (denominator == 0.0) {\n        if (numerator < 0.0) {\n          return false;\n        }\n      } else {\n        // Note: we want this predicate without division:\n        // lower < numerator / denominator, where denominator < 0\n        // Since denominator < 0, we have to flip the inequality:\n        // lower < numerator / denominator <==> denominator * lower > numerator.\n        if (denominator < 0.0 && numerator < lower * denominator) {\n          // Increase lower.\n          // The segment enters this half-space.\n          lower = numerator / denominator;\n          index = i;\n        } else if (denominator > 0.0 && numerator < upper * denominator) {\n          // Decrease upper.\n          // The segment exits this half-space.\n          upper = numerator / denominator;\n        }\n      }\n\n      // The use of epsilon here causes the assert on lower to trip\n      // in some cases. Apparently the use of epsilon was to make edge\n      // shapes work, but now those are handled separately.\n      // if (upper < lower - matrix.EPSILON)\n      if (upper < lower) {\n        return false;\n      }\n    }\n\n    _ASSERT && console.assert(0.0 <= lower && lower <= input.maxFraction);\n\n    if (index >= 0) {\n      output.fraction = lower;\n      output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    for (let i = 0; i < this.m_count; ++i) {\n      const v = matrix.transformVec2(temp, xf, this.m_vertices[i]);\n      minX = math_min(minX, v.x);\n      maxX = math_max(maxX, v.x);\n      minY = math_min(minY, v.y);\n      maxY = math_max(maxY, v.y);\n    }\n\n    matrix.setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);\n    matrix.setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    // Polygon mass, centroid, and inertia.\n    // Let rho be the polygon density in mass per unit area.\n    // Then:\n    // mass = rho * int(dA)\n    // centroid.x = (1/mass) * rho * int(x * dA)\n    // centroid.y = (1/mass) * rho * int(y * dA)\n    // I = rho * int((x*x + y*y) * dA)\n    //\n    // We can compute these integrals by summing all the integrals\n    // for each triangle of the polygon. To evaluate the integral\n    // for a single triangle, we make a change of variables to\n    // the (u,v) coordinates of the triangle:\n    // x = x0 + e1x * u + e2x * v\n    // y = y0 + e1y * u + e2y * v\n    // where 0 <= u && 0 <= v && u + v <= 1.\n    //\n    // We integrate u from [0,1-v] and then v from [0,1].\n    // We also need to use the Jacobian of the transformation:\n    // D = cross(e1, e2)\n    //\n    // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)\n    //\n    // The rest of the derivation is handled by computer algebra.\n\n    _ASSERT && console.assert(this.m_count >= 3);\n\n    matrix.zeroVec2(center);\n    let area = 0.0;\n    let I = 0.0;\n\n    // s is the reference point for forming triangles.\n    // It's location doesn't change the result (except for rounding error).\n    matrix.zeroVec2(s);\n\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < this.m_count; ++i) {\n      matrix.addVec2(s, this.m_vertices[i]);\n    }\n    matrix.setMulVec2(s, 1.0 / this.m_count, s);\n\n    const k_inv3 = 1.0 / 3.0;\n\n    for (let i = 0; i < this.m_count; ++i) {\n      // Triangle vertices.\n      matrix.diffVec2(e1, this.m_vertices[i], s);\n      if ( i + 1 < this.m_count) {\n        matrix.diffVec2(e2, this.m_vertices[i + 1], s);\n      } else {\n        matrix.diffVec2(e2, this.m_vertices[0], s);\n      }\n\n      const D = matrix.crossVec2Vec2(e1, e2);\n\n      const triangleArea = 0.5 * D;\n      area += triangleArea;\n\n      // Area weighted centroid\n      matrix.combineVec2(center, 1, center, triangleArea * k_inv3, e1);\n      matrix.combineVec2(center, 1, center, triangleArea * k_inv3, e2);\n\n      const ex1 = e1.x;\n      const ey1 = e1.y;\n      const ex2 = e2.x;\n      const ey2 = e2.y;\n\n      const intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n      const inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n\n      I += (0.25 * k_inv3 * D) * (intx2 + inty2);\n    }\n\n    // Total mass\n    massData.mass = density * area;\n\n    // Center of mass\n    _ASSERT && console.assert(area > EPSILON);\n    matrix.setMulVec2(center, 1.0 / area, center);\n    matrix.sumVec2(massData.center, center, s);\n\n    // Inertia tensor relative to the local origin (point s).\n    massData.I = density * I;\n\n    // Shift to center of mass then to original body origin.\n    massData.I += massData.mass * (matrix.dotVec2(massData.center, massData.center) - matrix.dotVec2(center, center));\n  }\n\n  /**\n   * Validate convexity. This is a very time consuming operation.\n   * @returns true if valid\n   */\n  validate(): boolean {\n    for (let i = 0; i < this.m_count; ++i) {\n      const i1 = i;\n      const i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n      const p = this.m_vertices[i1];\n      matrix.diffVec2(e, this.m_vertices[i2], p);\n\n      for (let j = 0; j < this.m_count; ++j) {\n        if (j == i1 || j == i2) {\n          continue;\n        }\n\n        const c = matrix.crossVec2Vec2(e, matrix.diffVec2(temp, this.m_vertices[j], p));\n        if (c < 0.0) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    for (let i = 0; i < this.m_count; ++i) {\n      proxy.m_vertices[i] = this.m_vertices[i];\n    }\n    proxy.m_vertices.length = this.m_count;\n    proxy.m_count = this.m_count;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\n/** @internal */ function computeCentroid(vs: Vec2[], count: number): Vec2 {\n  _ASSERT && console.assert(count >= 3);\n\n  const c = Vec2.zero();\n  let area = 0.0;\n\n  // pRef is the reference point for forming triangles.\n  // It's location doesn't change the result (except for rounding error).\n  const pRef = Vec2.zero();\n  if (false) {\n    // This code would put the reference point inside the polygon.\n    for (let i = 0; i < count; ++i) {\n      pRef.add(vs[i]);\n    }\n    pRef.mul(1.0 / count);\n  }\n\n  const inv3 = 1.0 / 3.0;\n\n  for (let i = 0; i < count; ++i) {\n    // Triangle vertices.\n    const p1 = pRef;\n    const p2 = vs[i];\n    const p3 = i + 1 < count ? vs[i + 1] : vs[0];\n\n    const e1 = Vec2.sub(p2, p1);\n    const e2 = Vec2.sub(p3, p1);\n\n    const D = Vec2.crossVec2Vec2(e1, e2);\n\n    const triangleArea = 0.5 * D;\n    area += triangleArea;\n\n    // Area weighted centroid\n    c.addMul(triangleArea * inv3, p1);\n    c.addMul(triangleArea * inv3, p2);\n    c.addMul(triangleArea * inv3, p3);\n  }\n\n  // Centroid\n  _ASSERT && console.assert(area > EPSILON);\n  c.mul(1.0 / area);\n  return c;\n}\n\nexport const Polygon = PolygonShape;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport type { Vec2Value } from '../../common/Vec2';\nimport { PolygonShape } from './PolygonShape';\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * A rectangle polygon which extend PolygonShape.\n */\nexport class BoxShape extends PolygonShape {\n  static TYPE = 'polygon' as const;\n\n  constructor(hx: number, hy: number, center?: Vec2Value, angle?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof BoxShape)) {\n      return new BoxShape(hx, hy, center, angle);\n    }\n\n    super();\n\n    this._setAsBox(hx, hy, center, angle);\n  }\n}\n\nexport const Box = BoxShape;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { EPSILON } from '../../common/Math';\nimport { Rot } from '../../common/Rot';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Shape } from '../Shape';\nimport { AABBValue, RayCastInput, RayCastOutput } from '../AABB';\nimport { Transform, TransformValue } from '../../common/Transform';\nimport { MassData } from '../../dynamics/Body';\nimport { DistanceProxy } from '../Distance';\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_sqrt = Math.sqrt;\n/** @internal */ const math_PI = Math.PI;\n\n/** @internal */ const temp = matrix.vec2(0, 0);\n\nexport class CircleShape extends Shape {\n  static TYPE = 'circle' as const;\n  m_type: 'circle';\n\n  m_p: Vec2;\n  m_radius: number;\n\n  constructor(position: Vec2Value, radius?: number);\n  constructor(radius?: number);\n  constructor(a: any, b?: any) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof CircleShape)) {\n      return new CircleShape(a, b);\n    }\n\n    super();\n\n    this.m_type = CircleShape.TYPE;\n    this.m_p = Vec2.zero();\n    this.m_radius = 1;\n\n    if (typeof a === 'object' && Vec2.isValid(a)) {\n      this.m_p.setVec2(a);\n\n      if (typeof b === 'number') {\n        this.m_radius = b;\n      }\n\n    } else if (typeof a === 'number') {\n      this.m_radius = a;\n    }\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n\n      p: this.m_p,\n      radius: this.m_radius,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any): CircleShape {\n    return new CircleShape(data.p, data.radius);\n  }\n\n  /** @internal */\n  _reset(): void {\n    // noop\n  }\n\n  getType(): 'circle' {\n    return this.m_type;\n  }\n\n  getRadius(): number {\n    return this.m_radius;\n  }\n\n  getCenter(): Vec2 {\n    return this.m_p;\n  }\n\n  /**\n   * @internal @deprecated Shapes should be treated as immutable.\n   *\n   * clone the concrete shape.\n   */\n  _clone(): CircleShape {\n    const clone = new CircleShape();\n    clone.m_type = this.m_type;\n    clone.m_radius = this.m_radius;\n    clone.m_p = this.m_p.clone();\n    return clone;\n  }\n\n  /**\n   * Get the number of child primitives.\n   */\n  getChildCount(): 1 {\n    return 1;\n  }\n\n  /**\n   * Test a point for containment in this shape. This only works for convex\n   * shapes.\n   *\n   * @param xf The shape world transform.\n   * @param p A point in world coordinates.\n   */\n  testPoint(xf: TransformValue, p: Vec2Value): boolean {\n    const center = matrix.transformVec2(temp, xf, this.m_p)\n    return matrix.distSqrVec2(p, center) <= this.m_radius * this.m_radius;\n  }\n\n  /**\n   * Cast a ray against a child shape.\n   *\n   * @param output The ray-cast results.\n   * @param input The ray-cast input parameters.\n   * @param xf The transform to be applied to the shape.\n   * @param childIndex The child shape index\n   */\n  rayCast(output: RayCastOutput, input: RayCastInput, xf: Transform, childIndex: number): boolean {\n    // Collision Detection in Interactive 3D Environments by Gino van den Bergen\n    // From Section 3.1.2\n    // x = s + a * r\n    // norm(x) = radius\n\n    const position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));\n    const s = Vec2.sub(input.p1, position);\n    const b = Vec2.dot(s, s) - this.m_radius * this.m_radius;\n\n    // Solve quadratic equation.\n    const r = Vec2.sub(input.p2, input.p1);\n    const c = Vec2.dot(s, r);\n    const rr = Vec2.dot(r, r);\n    const sigma = c * c - rr * b;\n\n    // Check for negative discriminant and short segment.\n    if (sigma < 0.0 || rr < EPSILON) {\n      return false;\n    }\n\n    // Find the point of intersection of the line with the circle.\n    let a = -(c + math_sqrt(sigma));\n\n    // Is the intersection point on the segment?\n    if (0.0 <= a && a <= input.maxFraction * rr) {\n      a /= rr;\n      output.fraction = a;\n      output.normal = Vec2.add(s, Vec2.mulNumVec2(a, r));\n      output.normal.normalize();\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a transform, compute the associated axis aligned bounding box for a\n   * child shape.\n   *\n   * @param aabb Returns the axis aligned box.\n   * @param xf The world transform of the shape.\n   * @param childIndex The child shape\n   */\n  computeAABB(aabb: AABBValue, xf: TransformValue, childIndex: number): void {\n    const p = matrix.transformVec2(temp, xf, this.m_p);\n\n    matrix.setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);\n    matrix.setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);\n  }\n\n  /**\n   * Compute the mass properties of this shape using its dimensions and density.\n   * The inertia tensor is computed about the local origin.\n   *\n   * @param massData Returns the mass data for this shape.\n   * @param density The density in kilograms per meter squared.\n   */\n  computeMass(massData: MassData, density: number): void {\n    massData.mass = density * math_PI * this.m_radius * this.m_radius;\n    matrix.copyVec2(massData.center, this.m_p);\n    // inertia about the local origin\n    massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + matrix.lengthSqrVec2(this.m_p));\n  }\n\n  computeDistanceProxy(proxy: DistanceProxy): void {\n    proxy.m_vertices[0] = this.m_p;\n    proxy.m_vertices.length = 1;\n    proxy.m_count = 1;\n    proxy.m_radius = this.m_radius;\n  }\n}\n\nexport const Circle = CircleShape;\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_PI = Math.PI;\n\n\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. A value of 0 disables softness.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * Distance length.\n   */\n  length?: number;\n}\n/**\n * Distance joint definition. This requires defining an anchor point on both\n * bodies and the non-zero length of the distance joint. The definition uses\n * local anchor points so that the initial configuration can violate the\n * constraint slightly. This helps when saving and loading a game. Warning: Do\n * not use a zero or short length.\n */\nexport interface DistanceJointDef extends JointDef, DistanceJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n}\n\n/** @internal */ const DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0\n};\n\n/**\n * A distance joint constrains two points on two bodies to remain at a fixed\n * distance from each other. You can view this as a massless, rigid rod.\n */\nexport class DistanceJoint extends Joint {\n  static TYPE = 'distance-joint' as const;\n\n  // Solver shared\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_length: number;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_gamma: number;\n  /** @internal */ m_bias: number;\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  /**\n   * @param def DistanceJoint definition.\n   */\n  constructor(def: DistanceJointDef);\n  /**\n   * @param anchorA Anchor A in global coordination.\n   * @param anchorB Anchor B in global coordination.\n   */\n  constructor(def: DistanceJointOpt, bodyA: Body, bodyB: Body, anchorA: Vec2Value, anchorB: Vec2Value);\n  constructor(def: DistanceJointDef, bodyA?: Body, bodyB?: Body, anchorA?: Vec2Value, anchorB?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof DistanceJoint)) {\n      return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);\n    }\n\n    // order of constructor arguments is changed in v0.2\n    if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {\n      const temp = bodyB;\n      bodyB = anchorA as any as Body;\n      anchorA = temp as any as Vec2;\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = DistanceJoint.TYPE;\n\n    // Solver shared\n    this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n    this.m_length = Number.isFinite(def.length) ? def.length :\n      Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n    this.m_impulse = 0.0;\n    this.m_gamma = 0.0;\n    this.m_bias = 0.0;\n\n    // 1-D constrained system\n    // m (v2 - v1) = lambda\n    // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.\n    // x2 = x1 + h * v2\n\n    // 1-D mass-damper-spring system\n    // m (v2 - v1) + h * d * v2 + h * k *\n\n    // C = norm(p2 - p1) - L\n    // u = (p2 - p1) / norm(p2 - p1)\n    // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))\n    // J = [-u -cross(r1, u) u cross(r2, u)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      length: this.m_length,\n\n      impulse: this.m_impulse,\n      gamma: this.m_gamma,\n      bias: this.m_bias,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): DistanceJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new DistanceJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2Value,\n    localAnchorA?: Vec2Value,\n    anchorB?: Vec2Value,\n    localAnchorB?: Vec2Value,\n    length?: number,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.length > 0) {\n      this.m_length = +def.length;\n    } else if (def.length < 0) { // don't change length\n    } else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n      this.m_length = Vec2.distance(\n          this.m_bodyA.getWorldPoint(this.m_localAnchorA),\n          this.m_bodyB.getWorldPoint(this.m_localAnchorB)\n      );\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the natural length. Manipulating the length can lead to non-physical\n   * behavior when the frequency is zero.\n   */\n  setLength(length: number): void {\n    this.m_length = length;\n  }\n\n  /**\n   * Get the natural length.\n   */\n  getLength(): number {\n    return this.m_length;\n  }\n\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));\n\n    // Handle singularity.\n    const length = this.m_u.length();\n    if (length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / length);\n    } else {\n      this.m_u.setNum(0.0, 0.0);\n    }\n\n    const crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n    const crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n    let invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\n\n    // Compute the effective mass matrix.\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C = length - this.m_length;\n\n      // Frequency\n      const omega = 2.0 * math_PI * this.m_frequencyHz;\n\n      // Damping coefficient\n      const d = 2.0 * this.m_mass * this.m_dampingRatio * omega;\n\n      // Spring stiffness\n      const k = this.m_mass * omega * omega;\n\n      // magic formulas\n      const h = step.dt;\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invMass += this.m_gamma;\n      this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n    } else {\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n    const Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n\n    const impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n    this.m_impulse += impulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u);\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    if (this.m_frequencyHz > 0.0) {\n      // There is no position correction for soft distance constraints.\n      return true;\n    }\n\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n\n    const length = u.normalize();\n    const C = clamp(length - this.m_length, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C;\n    const P = Vec2.mulNumVec2(impulse, u);\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return math_abs(C) < Settings.linearSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointOpt extends JointOpt {\n  /**\n   * The maximum friction force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum friction torque in N-m.\n   */\n  maxTorque?: number;\n}\n/**\n * Friction joint definition.\n */\nexport interface FrictionJointDef extends JointDef, FrictionJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2;\n}\n\n/** @internal */ const DEFAULTS = {\n  maxForce : 0.0,\n  maxTorque : 0.0,\n};\n\n/**\n * Friction joint. This is used for top-down friction. It provides 2D\n * translational friction and angular friction.\n */\nexport class FrictionJoint extends Joint {\n  static TYPE = 'friction-joint' as const;\n\n  /** @internal */ m_type: 'friction-joint';\n\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  // Solver shared\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: FrictionJointDef);\n  /**\n   * @param anchor Anchor in global coordination.\n   */\n  constructor(def: FrictionJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2Value);\n  constructor(def: FrictionJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof FrictionJoint)) {\n      return new FrictionJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = FrictionJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n\n    // Solver shared\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): FrictionJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new FrictionJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2Value,\n    localAnchorA?: Vec2Value,\n    anchorB?: Vec2Value,\n    localAnchorB?: Vec2Value,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && console.assert(Number.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && console.assert(Number.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y\n        * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x\n        * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt;\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA;\n      let impulse = -this.m_angularMass * Cdot;\n\n      const oldImpulse = this.m_angularImpulse;\n      const maxImpulse = h * this.m_maxTorque;\n      this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.sub(\n        Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB)),\n        Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA))\n      );\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n      const oldImpulse = this.m_linearImpulse;\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce;\n\n      if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n        this.m_linearImpulse.normalize();\n        this.m_linearImpulse.mul(maxImpulse);\n      }\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { Vec2, Vec2Value } from './Vec2';\nimport { Vec3, Vec3Value } from './Vec3';\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\n/**\n * A 3-by-3 matrix. Stored in column-major order.\n */\nexport class Mat33 {\n  ex: Vec3;\n  ey: Vec3;\n  ez: Vec3;\n\n  constructor(a: Vec3Value, b: Vec3Value, c: Vec3Value);\n  constructor();\n  constructor(a?: Vec3Value, b?: Vec3Value, c?: Vec3Value) {\n    if (typeof a === 'object' && a !== null) {\n      this.ex = Vec3.clone(a);\n      this.ey = Vec3.clone(b);\n      this.ez = Vec3.clone(c);\n    } else {\n      this.ex = Vec3.zero();\n      this.ey = Vec3.zero();\n      this.ez = Vec3.zero();\n    }\n  }\n\n  /** @internal */\n  toString(): string {\n    return JSON.stringify(this);\n  }\n\n  static isValid(obj: any): boolean {\n    if (obj === null || typeof obj === 'undefined') {\n      return false;\n    }\n    return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n  }\n\n  static assert(o: any): void {\n    _ASSERT && console.assert(!Mat33.isValid(o), 'Invalid Mat33!', o);\n  }\n\n  /**\n   * Set this matrix to all zeros.\n   */\n  setZero(): Mat33 {\n    this.ex.setZero();\n    this.ey.setZero();\n    this.ez.setZero();\n    return this;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases.\n   */\n  solve33(v: Vec3Value): Vec3 {\n    // let det = matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, this.ez));\n    let cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n    let cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n    let cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n    let det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = new Vec3();\n    // r.x = det * matrix.dotVec3(v, matrix.newCrossVec3(this.ey, this.ez));\n    cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n    cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n    cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n    r.x = det * (v.x * cross_x + v.y * cross_y + v.z * cross_z);\n\n    // r.y = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(v, this.ez));\n    cross_x = v.y * this.ez.z - v.z * this.ez.y;\n    cross_y = v.z * this.ez.x - v.x * this.ez.z;\n    cross_z = v.x * this.ez.y - v.y * this.ez.x;\n    r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n\n    // r.z = det * matrix.dotVec3(this.ex, matrix.newCrossVec3(this.ey, v));\n    cross_x = this.ey.y * v.z - this.ey.z * v.y;\n    cross_y = this.ey.z * v.x - this.ey.x * v.z;\n    cross_z = this.ey.x * v.y - this.ey.y * v.x;\n    r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n    return r;\n  }\n\n  /**\n   * Solve A * x = b, where b is a column vector. This is more efficient than\n   * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix\n   * equation.\n   */\n  solve22(v: Vec2Value): Vec2 {\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a21 = this.ex.y;\n    const a22 = this.ey.y;\n    let det = a11 * a22 - a12 * a21;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const r = Vec2.zero();\n    r.x = det * (a22 * v.x - a12 * v.y);\n    r.y = det * (a11 * v.y - a21 * v.x);\n    return r;\n  }\n\n  /**\n   * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if\n   * singular.\n   */\n  getInverse22(M: Mat33): void {\n    const a = this.ex.x;\n    const b = this.ey.x;\n    const c = this.ex.y;\n    const d = this.ey.y;\n    let det = a * d - b * c;\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    M.ex.x = det * d;\n    M.ey.x = -det * b;\n    M.ex.z = 0.0;\n    M.ex.y = -det * c;\n    M.ey.y = det * a;\n    M.ey.z = 0.0;\n    M.ez.x = 0.0;\n    M.ez.y = 0.0;\n    M.ez.z = 0.0;\n  }\n\n  /**\n   * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix\n   * if singular.\n   */\n  getSymInverse33(M: Mat33): void {\n    let det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n    if (det !== 0.0) {\n      det = 1.0 / det;\n    }\n    const a11 = this.ex.x;\n    const a12 = this.ey.x;\n    const a13 = this.ez.x;\n    const a22 = this.ey.y;\n    const a23 = this.ez.y;\n    const a33 = this.ez.z;\n\n    M.ex.x = det * (a22 * a33 - a23 * a23);\n    M.ex.y = det * (a13 * a23 - a12 * a33);\n    M.ex.z = det * (a12 * a23 - a13 * a22);\n\n    M.ey.x = M.ex.y;\n    M.ey.y = det * (a11 * a33 - a13 * a13);\n    M.ey.z = det * (a13 * a12 - a11 * a23);\n\n    M.ez.x = M.ex.z;\n    M.ez.y = M.ey.z;\n    M.ez.z = det * (a11 * a22 - a12 * a12);\n  }\n\n  /**\n   * Multiply a matrix times a vector.\n   */\n  static mul(a: Mat33, b: Vec2Value): Vec2;\n  static mul(a: Mat33, b: Vec3Value): Vec3;\n  static mul(a, b) {\n    _ASSERT && Mat33.assert(a);\n    if (b && 'z' in b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec3.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n      const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n      const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n      return new Vec3(x, y, z);\n\n    } else if (b && 'y' in b && 'x' in b) {\n      _ASSERT && Vec2.assert(b);\n      const x = a.ex.x * b.x + a.ey.x * b.y;\n      const y = a.ex.y * b.x + a.ey.y * b.y;\n      return Vec2.neo(x, y);\n    }\n\n    _ASSERT && console.assert(false);\n  }\n\n  static mulVec3(a: Mat33, b: Vec3): Vec3 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec3.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;\n    const y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;\n    const z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;\n    return new Vec3(x, y, z);\n  }\n\n  static mulVec2(a: Mat33, b: Vec2Value): Vec2 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Vec2.assert(b);\n    const x = a.ex.x * b.x + a.ey.x * b.y;\n    const y = a.ex.y * b.x + a.ey.y * b.y;\n    return Vec2.neo(x, y);\n  }\n\n  static add(a: Mat33, b: Mat33): Mat33 {\n    _ASSERT && Mat33.assert(a);\n    _ASSERT && Mat33.assert(b);\n    return new Mat33(\n      Vec3.add(a.ex, b.ex),\n      Vec3.add(a.ey, b.ey),\n      Vec3.add(a.ez, b.ez)\n    );\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n\n\n// todo: use string?\n/** @internal */ enum LimitState {\n  inactiveLimit = 0,\n  atLowerLimit = 1,\n  atUpperLimit = 2,\n  equalLimits = 3,\n}  \n\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointOpt extends JointOpt {\n  /**\n   * The lower angle for the joint limit (radians).\n   */\n  lowerAngle?: number;\n  /**\n   * The upper angle for the joint limit (radians).\n   */\n  upperAngle?: number;\n  /**\n   * The maximum motor torque used to achieve the desired motor speed. Usually\n   * in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed. Usually in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * A flag to enable joint limits.\n   */\n  enableLimit?: boolean;\n  /**\n   * A flag to enable the joint motor.\n   */\n  enableMotor?: boolean;\n}\n\n/**\n * Revolute joint definition. This requires defining an anchor point where the\n * bodies are joined. The definition uses local anchor points so that the\n * initial configuration can violate the constraint slightly. You also need to\n * specify the initial relative angle for joint limits. This helps when saving\n * and loading a game.\n *\n * The local anchor points are measured from the body's origin rather than the\n * center of mass because: 1. you might not know where the center of mass will\n * be. 2. if you add/remove shapes from a body and recompute the mass, the\n * joints will be broken.\n */\nexport interface RevoluteJointDef extends JointDef, RevoluteJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle: number;\n}\n\n/** @internal */ const DEFAULTS = {\n  lowerAngle : 0.0,\n  upperAngle : 0.0,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  enableLimit : false,\n  enableMotor : false\n};\n\n/**\n * A revolute joint constrains two bodies to share a common point while they are\n * free to rotate about the point. The relative rotation about the shared point\n * is the joint angle. You can limit the relative rotation with a joint limit\n * that specifies a lower and upper angle. You can use a motor to drive the\n * relative rotation about the shared point. A maximum motor torque is provided\n * so that infinite forces are not generated.\n */\nexport class RevoluteJoint extends Joint {\n  static TYPE = 'revolute-joint' as const;\n\n  /** @internal */ m_type: 'revolute-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerAngle: number;\n  /** @internal */ m_upperAngle: number;\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  // effective mass for point-to-point constraint.\n  /** @internal */ m_mass: Mat33;\n  // effective mass for motor/limit angular constraint.\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_limitState: number;\n\n  constructor(def: RevoluteJointDef);\n  constructor(def: RevoluteJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2Value);\n  constructor(def: RevoluteJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof RevoluteJoint)) {\n      return new RevoluteJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = def ?? {} as RevoluteJointDef;\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_mass = new Mat33();\n    this.m_limitState = LimitState.inactiveLimit\n\n    this.m_type = RevoluteJoint.TYPE;\n\n    if (Vec2.isValid(anchor)) {\n      this.m_localAnchorA = bodyA.getLocalPoint(anchor);\n    } else if (Vec2.isValid(def.localAnchorA)) {\n      this.m_localAnchorA = Vec2.clone(def.localAnchorA);\n    } else {\n      this.m_localAnchorA = Vec2.zero();\n    }\n\n    if (Vec2.isValid(anchor)) {\n      this.m_localAnchorB = bodyB.getLocalPoint(anchor);\n    } else if (Vec2.isValid(def.localAnchorB)) {\n      this.m_localAnchorB = Vec2.clone(def.localAnchorB);\n    } else {\n      this.m_localAnchorB = Vec2.zero();\n    }\n\n    if (Number.isFinite(def.referenceAngle)) {\n      this.m_referenceAngle = def.referenceAngle;\n    } else {\n      this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();\n    }\n\n    this.m_impulse = new Vec3();\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerAngle = def.lowerAngle ?? DEFAULTS.lowerAngle;\n    this.m_upperAngle = def.upperAngle ?? DEFAULTS.upperAngle;\n    this.m_maxMotorTorque = def.maxMotorTorque ?? DEFAULTS.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed ?? DEFAULTS.motorSpeed;\n    this.m_enableLimit = def.enableLimit ?? DEFAULTS.enableLimit;\n    this.m_enableMotor = def.enableMotor ?? DEFAULTS.enableMotor;\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Motor constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerAngle: this.m_lowerAngle,\n      upperAngle: this.m_upperAngle,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any):RevoluteJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RevoluteJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2Value,\n    localAnchorA?: Vec2Value,\n    anchorB?: Vec2Value,\n    localAnchorB?: Vec2Value,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle in radians.\n   */\n  getJointAngle(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint angle speed in radians per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n    return bB.m_angularVelocity - bA.m_angularVelocity;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step. Unit is N*m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set the motor speed in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set the maximum motor torque, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    if (torque == this.m_maxMotorTorque) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit in radians.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerAngle;\n  }\n\n  /**\n   * Get the upper joint limit in radians.\n   */\n  getUpperLimit(): number {\n    return this.m_upperAngle;\n  }\n\n  /**\n   * Set the joint limits in radians.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && console.assert(lower <= upper);\n\n    if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_impulse.z = 0.0;\n      this.m_lowerAngle = lower;\n      this.m_upperAngle = upper;\n    }\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force given the inverse time step. Unit is N.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque due to the joint limit given the inverse time step.\n   * Unit is N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const fixedRotation = (iA + iB === 0.0);\n\n    this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n    this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y  * this.m_rB.x * iB;\n    this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    this.m_mass.ex.y = this.m_mass.ey.x;\n    this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n    this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    this.m_mass.ex.z = this.m_mass.ez.x;\n    this.m_mass.ey.z = this.m_mass.ez.y;\n    this.m_mass.ez.z = iA + iB;\n\n    this.m_motorMass = iA + iB;\n    if (this.m_motorMass > 0.0) {\n      this.m_motorMass = 1.0 / this.m_motorMass;\n    }\n\n    if (this.m_enableMotor == false || fixedRotation) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (this.m_enableLimit && fixedRotation == false) {\n      const jointAngle = aB - aA - this.m_referenceAngle;\n\n      if (math_abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {\n        this.m_limitState = LimitState.equalLimits;\n\n      } else if (jointAngle <= this.m_lowerAngle) {\n        if (this.m_limitState != LimitState.atLowerLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = LimitState.atLowerLimit;\n\n      } else if (jointAngle >= this.m_upperAngle) {\n        if (this.m_limitState != LimitState.atUpperLimit) {\n          this.m_impulse.z = 0.0;\n        }\n        this.m_limitState = LimitState.atUpperLimit;\n\n      } else {\n        this.m_limitState = LimitState.inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = LimitState.inactiveLimit;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const fixedRotation = (iA + iB === 0.0);\n\n    // Solve motor constraint.\n    if (this.m_enableMotor && this.m_limitState != LimitState.equalLimits && fixedRotation == false) {\n      const Cdot = wB - wA - this.m_motorSpeed;\n      let impulse = -this.m_motorMass * Cdot;\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorTorque;\n      this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve limit constraint.\n    if (this.m_enableLimit && this.m_limitState != LimitState.inactiveLimit && fixedRotation == false) {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const Cdot2 = wB - wA;\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const impulse = Vec3.neg(this.m_mass.solve33(Cdot));\n\n      if (this.m_limitState == LimitState.equalLimits) {\n        this.m_impulse.add(impulse);\n\n      } else if (this.m_limitState == LimitState.atLowerLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z;\n\n        if (newImpulse < 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));\n          const reduced = this.m_mass.solve22(rhs);\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n\n      } else if (this.m_limitState == LimitState.atUpperLimit) {\n        const newImpulse = this.m_impulse.z + impulse.z;\n\n        if (newImpulse > 0.0) {\n          const rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));\n          const reduced = this.m_mass.solve22(rhs);\n          impulse.x = reduced.x;\n          impulse.y = reduced.y;\n          impulse.z = -this.m_impulse.z;\n          this.m_impulse.x += reduced.x;\n          this.m_impulse.y += reduced.y;\n          this.m_impulse.z = 0.0;\n\n        } else {\n          this.m_impulse.add(impulse);\n        }\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n\n    } else {\n      // Solve point-to-point constraint\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const impulse = this.m_mass.solve22(Vec2.neg(Cdot));\n\n      this.m_impulse.x += impulse.x;\n      this.m_impulse.y += impulse.y;\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    let angularError = 0.0;\n    let positionError = 0.0;\n\n    const fixedRotation = (this.m_invIA + this.m_invIB == 0.0);\n\n    // Solve angular limit constraint.\n    if (this.m_enableLimit && this.m_limitState != LimitState.inactiveLimit && fixedRotation == false) {\n      const angle = aB - aA - this.m_referenceAngle;\n      let limitImpulse = 0.0;\n\n      if (this.m_limitState == LimitState.equalLimits) {\n        // Prevent large angular corrections\n        const C = clamp(angle - this.m_lowerAngle, -Settings.maxAngularCorrection, Settings.maxAngularCorrection);\n        limitImpulse = -this.m_motorMass * C;\n        angularError = math_abs(C);\n\n      } else if (this.m_limitState == LimitState.atLowerLimit) {\n        let C = angle - this.m_lowerAngle;\n        angularError = -C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection, 0.0);\n        limitImpulse = -this.m_motorMass * C;\n\n      } else if (this.m_limitState == LimitState.atUpperLimit) {\n        let C = angle - this.m_upperAngle;\n        angularError = C;\n\n        // Prevent large angular corrections and allow some slop.\n        C = clamp(C - Settings.angularSlop, 0.0, Settings.maxAngularCorrection);\n        limitImpulse = -this.m_motorMass * C;\n      }\n\n      aA -= this.m_invIA * limitImpulse;\n      aB += this.m_invIB * limitImpulse;\n    }\n\n    // Solve point-to-point constraint.\n    {\n      qA.setAngle(aA);\n      qB.setAngle(aB);\n      const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n      const C = Vec2.zero();\n      C.addCombine(1, cB, 1, rB);\n      C.subCombine(1, cA, 1, rA);\n      positionError = C.length();\n\n      const mA = this.m_invMassA;\n      const mB = this.m_invMassB;\n      const iA = this.m_invIA;\n      const iB = this.m_invIB;\n\n      const K = new Mat22();\n      K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;\n      K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;\n\n      const impulse = Vec2.neg(K.solve(C));\n\n      cA.subMul(mA, impulse);\n      aA -= iA * Vec2.crossVec2Vec2(rA, impulse);\n\n      cB.addMul(mB, impulse);\n      aB += iB * Vec2.crossVec2Vec2(rB, impulse);\n    }\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat22 } from '../../common/Mat22';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_max = Math.max;\n/** @internal */ const math_min = Math.min;\n\n\n/** @internal */ enum LimitState {\n  inactiveLimit = 0,\n  atLowerLimit = 1,\n  atUpperLimit = 2,\n  equalLimits = 3,   \n}\n\n\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit?: boolean;\n  /**\n   * The lower translation limit, usually in meters.\n   */\n  lowerTranslation?: number;\n  /**\n   * The upper translation limit, usually in meters.\n   */\n  upperTranslation?: number;\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorForce?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n}\n/**\n * Prismatic joint definition. This requires defining a line of motion using an\n * axis and an anchor point. The definition uses local anchor points and a local\n * axis so that the initial configuration can violate the constraint slightly.\n * The joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface PrismaticJointDef extends JointDef, PrismaticJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n  /**\n   * The local translation unit axis in bodyA.\n   */\n  localAxisA: Vec2Value;\n  /**\n   * referenceAngle The constrained angle between the bodies:\n   * bodyB_angle - bodyA_angle.\n   */\n  referenceAngle: number;\n}\n\n/** @internal */ const DEFAULTS = {\n  enableLimit : false,\n  lowerTranslation : 0.0,\n  upperTranslation : 0.0,\n  enableMotor : false,\n  maxMotorForce : 0.0,\n  motorSpeed : 0.0\n};\n\n/**\n * A prismatic joint. This joint provides one degree of freedom: translation\n * along an axis fixed in bodyA. Relative rotation is prevented. You can use a\n * joint limit to restrict the range of motion and a joint motor to drive the\n * motion or to model joint friction.\n */\nexport class PrismaticJoint extends Joint {\n  static TYPE = 'prismatic-joint' as const;\n\n  /** @internal */ m_type: 'prismatic-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n  /** @internal */ m_referenceAngle: number;\n  /** @internal */ m_impulse: Vec3;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_lowerTranslation: number;\n  /** @internal */ m_upperTranslation: number;\n  /** @internal */ m_maxMotorForce: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableLimit: boolean;\n  /** @internal */ m_enableMotor: boolean;\n  /** @internal */ m_limitState: number; // TODO enum\n  /** @internal */ m_axis: Vec2;\n  /** @internal */ m_perp: Vec2;\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_s1: number;\n  /** @internal */ m_s2: number;\n  /** @internal */ m_a1: number;\n  /** @internal */ m_a2: number;\n  /** @internal */ m_K: Mat33;\n\n  constructor(def: PrismaticJointDef);\n  constructor(def: PrismaticJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2Value, axis: Vec2Value);\n  constructor(def: PrismaticJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2Value, axis?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PrismaticJoint)) {\n      return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PrismaticJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));\n    this.m_localXAxisA.normalize();\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n    this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_impulse = new Vec3();\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n\n    this.m_lowerTranslation = def.lowerTranslation;\n    this.m_upperTranslation = def.upperTranslation;\n    this.m_maxMotorForce = def.maxMotorForce;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableLimit = def.enableLimit;\n    this.m_enableMotor = def.enableMotor;\n    this.m_limitState = LimitState.inactiveLimit;\n\n    this.m_axis = Vec2.zero();\n    this.m_perp = Vec2.zero();\n\n    this.m_K = new Mat33();\n\n    // Linear constraint (point-to-line)\n    // d = p2 - p1 = x2 + r2 - x1 - r1\n    // C = dot(perp, d)\n    // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -\n    // cross(w1, r1))\n    // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +\n    // dot(cross(r2, perp), v2)\n    // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]\n    //\n    // Angular constraint\n    // C = a2 - a1 + a_initial\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    //\n    // K = J * invM * JT\n    //\n    // J = [-a -s1 a s2]\n    // [0 -1 0 1]\n    // a = perp\n    // s1 = cross(d + r1, a) = cross(p2 - x1, a)\n    // s2 = cross(r2, a) = cross(p2 - x2, a)\n\n    // Motor/Limit linear constraint\n    // C = dot(ax1, d)\n    // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +\n    // dot(cross(r2, ax1), v2)\n    // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]\n\n    // Block Solver\n    // We develop a block solver that includes the joint limit. This makes the\n    // limit stiff (inelastic) even\n    // when the mass has poor distribution (leading to large torques about the\n    // joint anchor points).\n    //\n    // The Jacobian has 3 rows:\n    // J = [-uT -s1 uT s2] // linear\n    // [0 -1 0 1] // angular\n    // [-vT -a1 vT a2] // limit\n    //\n    // u = perp\n    // v = axis\n    // s1 = cross(d + r1, u), s2 = cross(r2, u)\n    // a1 = cross(d + r1, v), a2 = cross(r2, v)\n\n    // M * (v2 - v1) = JT * df\n    // J * v2 = bias\n    //\n    // v2 = v1 + invM * JT * df\n    // J * (v1 + invM * JT * df) = bias\n    // K * df = bias - J * v1 = -Cdot\n    // K = J * invM * JT\n    // Cdot = J * v1 - bias\n    //\n    // Now solve for f2.\n    // df = f2 - f1\n    // K * (f2 - f1) = -Cdot\n    // f2 = invK * (-Cdot) + f1\n    //\n    // Clamp accumulated limit impulse.\n    // lower: f2(3) = max(f2(3), 0)\n    // upper: f2(3) = min(f2(3), 0)\n    //\n    // Solve for correct f2(1:2)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1\n    // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)\n    // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +\n    // K(1:2,1:2) * f1(1:2)\n    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n    // f1(1:2)\n    //\n    // Now compute impulse to be applied:\n    // df = f2 - f1\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      lowerTranslation: this.m_lowerTranslation,\n      upperTranslation: this.m_upperTranslation,\n      maxMotorForce: this.m_maxMotorForce,\n      motorSpeed: this.m_motorSpeed,\n      enableLimit: this.m_enableLimit,\n      enableMotor: this.m_enableMotor,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PrismaticJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.localAxisA = Vec2.clone(data.localAxisA);\n    const joint = new PrismaticJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2Value,\n    localAnchorA?: Vec2Value,\n    anchorB?: Vec2Value,\n    localAnchorB?: Vec2Value,\n    localAxisA?: Vec2Value,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const d = Vec2.sub(pB, pA);\n    const axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n\n    const translation = Vec2.dot(d, axis);\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter));\n    const rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter));\n    const p1 = Vec2.add(bA.m_sweep.c, rA);\n    const p2 = Vec2.add(bB.m_sweep.c, rB);\n    const d = Vec2.sub(p2, p1);\n    const axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA);\n\n    const vA = bA.m_linearVelocity;\n    const vB = bB.m_linearVelocity;\n    const wA = bA.m_angularVelocity;\n    const wB = bB.m_angularVelocity;\n\n    const speed = Vec2.dot(d, Vec2.crossNumVec2(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB, wB, rB), Vec2.addCrossNumVec2(vA, wA, rA)));\n    return speed;\n  }\n\n  /**\n   * Is the joint limit enabled?\n   */\n  isLimitEnabled(): boolean {\n    return this.m_enableLimit;\n  }\n\n  /**\n   * Enable/disable the joint limit.\n   */\n  enableLimit(flag: boolean): void {\n    if (flag != this.m_enableLimit) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableLimit = flag;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Get the lower joint limit, usually in meters.\n   */\n  getLowerLimit(): number {\n    return this.m_lowerTranslation;\n  }\n\n  /**\n   * Get the upper joint limit, usually in meters.\n   */\n  getUpperLimit(): number {\n    return this.m_upperTranslation;\n  }\n\n  /**\n   * Set the joint limits, usually in meters.\n   */\n  setLimits(lower: number, upper: number): void {\n    _ASSERT && console.assert(lower <= upper);\n    if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_lowerTranslation = lower;\n      this.m_upperTranslation = upper;\n      this.m_impulse.z = 0.0;\n    }\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in meters per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Set the maximum motor force, usually in N.\n   */\n  setMaxMotorForce(force: number): void {\n    if (force == this.m_maxMotorForce) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorForce = force;\n  }\n\n  getMaxMotorForce(): number {\n    return this.m_maxMotorForce;\n  }\n\n  /**\n   * Get the motor speed, usually in meters per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Get the current motor force given the inverse time step, usually in N.\n   */\n  getMotorForce(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.y;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute motor Jacobian and effective mass.\n    {\n      this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_axis);\n      this.m_a2 = Vec2.crossVec2Vec2(rB, this.m_axis);\n\n      this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2\n          * this.m_a2;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    }\n\n    // Prismatic constraint.\n    {\n      this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n\n      this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_perp);\n      this.m_s2 = Vec2.crossVec2Vec2(rB, this.m_perp);\n\n      const s1test = Vec2.crossVec2Vec2(rA, this.m_perp);\n\n      const k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n      const k12 = iA * this.m_s1 + iB * this.m_s2;\n      const k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        // For bodies with fixed rotation.\n        k22 = 1.0;\n      }\n      const k23 = iA * this.m_a1 + iB * this.m_a2;\n      const k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n\n      this.m_K.ex.set(k11, k12, k13);\n      this.m_K.ey.set(k12, k22, k23);\n      this.m_K.ez.set(k13, k23, k33);\n    }\n\n    // Compute motor and limit terms.\n    if (this.m_enableLimit) {\n\n      const jointTranslation = Vec2.dot(this.m_axis, d);\n      if (math_abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {\n        this.m_limitState = LimitState.equalLimits;\n\n      } else if (jointTranslation <= this.m_lowerTranslation) {\n        if (this.m_limitState != LimitState.atLowerLimit) {\n          this.m_limitState = LimitState.atLowerLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else if (jointTranslation >= this.m_upperTranslation) {\n        if (this.m_limitState != LimitState.atUpperLimit) {\n          this.m_limitState = LimitState.atUpperLimit;\n          this.m_impulse.z = 0.0;\n        }\n\n      } else {\n        this.m_limitState = LimitState.inactiveLimit;\n        this.m_impulse.z = 0.0;\n      }\n\n    } else {\n      this.m_limitState = LimitState.inactiveLimit;\n      this.m_impulse.z = 0.0;\n    }\n\n    if (this.m_enableMotor == false) {\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse.mul(step.dtRatio);\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse\n          + this.m_impulse.z, this.m_axis);\n      const LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n      const LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y\n          + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      this.m_impulse.setZero();\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Solve linear motor constraint.\n    if (this.m_enableMotor && this.m_limitState != LimitState.equalLimits) {\n      const Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB\n          - this.m_a1 * wA;\n      let impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorForce;\n      this.m_motorImpulse = clamp(this.m_motorImpulse + impulse,\n          -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_axis);\n      const LA = impulse * this.m_a1;\n      const LB = impulse * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    const Cdot1 = Vec2.zero();\n    Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;\n    Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;\n    Cdot1.y = wB - wA;\n\n    if (this.m_enableLimit && this.m_limitState != LimitState.inactiveLimit) {\n      // Solve prismatic and limit constraint in block form.\n      let Cdot2 = 0;\n      Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;\n      Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;\n\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const f1 = Vec3.clone(this.m_impulse);\n      let df = this.m_K.solve33(Vec3.neg(Cdot));\n      this.m_impulse.add(df);\n\n      if (this.m_limitState == LimitState.atLowerLimit) {\n        this.m_impulse.z = math_max(this.m_impulse.z, 0.0);\n      } else if (this.m_limitState == LimitState.atUpperLimit) {\n        this.m_impulse.z = math_min(this.m_impulse.z, 0.0);\n      }\n\n      // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +\n      // f1(1:2)\n      const b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));\n      const f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y));\n      this.m_impulse.x = f2r.x;\n      this.m_impulse.y = f2r.y;\n\n      df = Vec3.sub(this.m_impulse, f1);\n\n      const P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis);\n      const LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;\n      const LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    } else {\n      // Limit is inactive, just solve the prismatic constraint in block form.\n      const df = this.m_K.solve22(Vec2.neg(Cdot1));\n      this.m_impulse.x += df.x;\n      this.m_impulse.y += df.y;\n\n      const P = Vec2.mulNumVec2(df.x, this.m_perp);\n      const LA = df.x * this.m_s1 + df.y;\n      const LB = df.x * this.m_s2 + df.y;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Compute fresh Jacobians\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));\n\n    const axis = Rot.mulVec2(qA, this.m_localXAxisA);\n    const a1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), axis);\n    const a2 = Vec2.crossVec2Vec2(rB, axis);\n    const perp = Rot.mulVec2(qA, this.m_localYAxisA);\n\n    const s1 = Vec2.crossVec2Vec2(Vec2.add(d, rA), perp);\n    const s2 = Vec2.crossVec2Vec2(rB, perp);\n\n    let impulse = new Vec3();\n    const C1 = Vec2.zero();\n    C1.x = Vec2.dot(perp, d);\n    C1.y = aB - aA - this.m_referenceAngle;\n\n    let linearError = math_abs(C1.x);\n    const angularError = math_abs(C1.y);\n\n    const linearSlop = Settings.linearSlop;\n    const maxLinearCorrection = Settings.maxLinearCorrection;\n\n    let active = false; // bool\n    let C2 = 0.0;\n    if (this.m_enableLimit) {\n\n      const translation = Vec2.dot(axis, d);\n      if (math_abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {\n        // Prevent large angular corrections\n        C2 = clamp(translation, -maxLinearCorrection, maxLinearCorrection);\n        linearError = math_max(linearError, math_abs(translation));\n        active = true;\n\n      } else if (translation <= this.m_lowerTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = clamp(translation - this.m_lowerTranslation + linearSlop,\n            -maxLinearCorrection, 0.0);\n        linearError = Math\n            .max(linearError, this.m_lowerTranslation - translation);\n        active = true;\n\n      } else if (translation >= this.m_upperTranslation) {\n        // Prevent large linear corrections and allow some slop.\n        C2 = clamp(translation - this.m_upperTranslation - linearSlop, 0.0,\n            maxLinearCorrection);\n        linearError = Math\n            .max(linearError, translation - this.m_upperTranslation);\n        active = true;\n      }\n    }\n\n    if (active) {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\n      const k12 = iA * s1 + iB * s2;\n      const k13 = iA * s1 * a1 + iB * s2 * a2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        // For fixed rotation\n        k22 = 1.0;\n      }\n      const k23 = iA * a1 + iB * a2;\n      const k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\n\n      const K = new Mat33();\n      K.ex.set(k11, k12, k13);\n      K.ey.set(k12, k22, k23);\n      K.ez.set(k13, k23, k33);\n\n      const C = new Vec3();\n      C.x = C1.x;\n      C.y = C1.y;\n      C.z = C2;\n\n      impulse = K.solve33(Vec3.neg(C));\n    } else {\n      const k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\n      const k12 = iA * s1 + iB * s2;\n      let k22 = iA + iB;\n      if (k22 == 0.0) {\n        k22 = 1.0;\n      }\n\n      const K = new Mat22();\n      K.ex.setNum(k11, k12);\n      K.ey.setNum(k12, k22);\n\n      const impulse1 = K.solve(Vec2.neg(C1));\n      impulse.x = impulse1.x;\n      impulse.y = impulse1.y;\n      impulse.z = 0.0;\n    }\n\n    const P = Vec2.combine(impulse.x, perp, impulse.z, axis);\n    const LA = impulse.x * s1 + impulse.y + impulse.z * a1;\n    const LB = impulse.x * s2 + impulse.y + impulse.z * a2;\n\n    cA.subMul(mA, P);\n    aA -= iA * LA;\n    cB.addMul(mB, P);\n    aB += iB * LB;\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError <= Settings.linearSlop\n        && angularError <= Settings.angularSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { } from '../../common/Math';\nimport { Vec2 } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { RevoluteJoint } from './RevoluteJoint';\nimport { PrismaticJoint } from './PrismaticJoint';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Gear joint definition.\n */\nexport interface GearJointOpt extends JointOpt {\n  /**\n   * The gear ratio. See {@link GearJoint} for explanation.\n   */\n  ratio?: number;\n}\n/**\n * Gear joint definition.\n */\nexport interface GearJointDef extends JointDef, GearJointOpt {\n  /**\n   * The first revolute/prismatic joint attached to the gear joint.\n   */\n  joint1: RevoluteJoint | PrismaticJoint;\n  /**\n   * The second prismatic/revolute joint attached to the gear joint.\n   */\n  joint2: RevoluteJoint | PrismaticJoint;\n}\n\n/** @internal */ const DEFAULTS = {\n  ratio : 1.0\n};\n\n/**\n * A gear joint is used to connect two joints together. Either joint can be a\n * revolute or prismatic joint. You specify a gear ratio to bind the motions\n * together: coordinate1 + ratio * coordinate2 = constant\n *\n * The ratio can be negative or positive. If one joint is a revolute joint and\n * the other joint is a prismatic joint, then the ratio will have units of\n * length or units of 1/length. Warning: You have to manually destroy the gear\n * joint if joint1 or joint2 is destroyed.\n *\n * This definition requires two existing revolute or prismatic joints (any\n * combination will work).\n */\nexport class GearJoint extends Joint {\n  static TYPE = 'gear-joint' as const;\n\n  /** @internal */ m_type: 'gear-joint';\n  /** @internal */ m_joint1: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_joint2: RevoluteJoint | PrismaticJoint;\n  /** @internal */ m_type1: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_type2: 'revolute-joint' | 'prismatic-joint';\n  /** @internal */ m_bodyC: Body;\n  /** @internal */ m_localAnchorC: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_referenceAngleA: number;\n  /** @internal */ m_localAxisC: Vec2;\n  /** @internal */ m_bodyD: Body;\n  /** @internal */ m_localAnchorD: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngleB: number;\n  /** @internal */ m_localAxisD: Vec2;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_lcA: Vec2;\n  /** @internal */ m_lcB: Vec2;\n  /** @internal */ m_lcC: Vec2;\n  /** @internal */ m_lcD: Vec2;\n  /** @internal */ m_mA: number;\n  /** @internal */ m_mB: number;\n  /** @internal */ m_mC: number;\n  /** @internal */ m_mD: number;\n  /** @internal */ m_iA: number;\n  /** @internal */ m_iB: number;\n  /** @internal */ m_iC: number;\n  /** @internal */ m_iD: number;\n  /** @internal */ m_JvAC: Vec2;\n  /** @internal */ m_JvBD: Vec2;\n  /** @internal */ m_JwA: number;\n  /** @internal */ m_JwB: number;\n  /** @internal */ m_JwC: number;\n  /** @internal */ m_JwD: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: GearJointDef);\n  constructor(def: GearJointOpt, bodyA: Body, bodyB: Body, joint1: RevoluteJoint | PrismaticJoint, joint2: RevoluteJoint | PrismaticJoint, ratio?: number);\n  constructor(def: GearJointDef, bodyA?: Body, bodyB?: Body, joint1?: RevoluteJoint | PrismaticJoint, joint2?: RevoluteJoint | PrismaticJoint, ratio?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof GearJoint)) {\n      return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = GearJoint.TYPE;\n\n    _ASSERT && console.assert(joint1.m_type === RevoluteJoint.TYPE || joint1.m_type === PrismaticJoint.TYPE);\n    _ASSERT && console.assert(joint2.m_type === RevoluteJoint.TYPE || joint2.m_type === PrismaticJoint.TYPE);\n\n    this.m_joint1 = joint1 ? joint1 : def.joint1;\n    this.m_joint2 = joint2 ? joint2 : def.joint2;\n    this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;\n\n    this.m_type1 = this.m_joint1.getType() as 'revolute-joint' | 'prismatic-joint';\n    this.m_type2 = this.m_joint2.getType() as 'revolute-joint' | 'prismatic-joint';\n\n    // joint1 connects body A to body C\n    // joint2 connects body B to body D\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    // TODO_ERIN there might be some problem with the joint edges in Joint.\n\n    this.m_bodyC = this.m_joint1.getBodyA();\n    this.m_bodyA = this.m_joint1.getBodyB();\n\n    // Get geometry of joint1\n    const xfA = this.m_bodyA.m_xf;\n    const aA = this.m_bodyA.m_sweep.a;\n    const xfC = this.m_bodyC.m_xf;\n    const aC = this.m_bodyC.m_sweep.a;\n\n    if (this.m_type1 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint1 as RevoluteJoint;\n      this.m_localAnchorC = revolute.m_localAnchorA;\n      this.m_localAnchorA = revolute.m_localAnchorB;\n      this.m_referenceAngleA = revolute.m_referenceAngle;\n      this.m_localAxisC = Vec2.zero();\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const prismatic = this.m_joint1 as PrismaticJoint;\n      this.m_localAnchorC = prismatic.m_localAnchorA;\n      this.m_localAnchorA = prismatic.m_localAnchorB;\n      this.m_referenceAngleA = prismatic.m_referenceAngle;\n      this.m_localAxisC = prismatic.m_localXAxisA;\n\n      const pC = this.m_localAnchorC;\n      const pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));\n      coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);\n    }\n\n    this.m_bodyD = this.m_joint2.getBodyA();\n    this.m_bodyB = this.m_joint2.getBodyB();\n\n    // Get geometry of joint2\n    const xfB = this.m_bodyB.m_xf;\n    const aB = this.m_bodyB.m_sweep.a;\n    const xfD = this.m_bodyD.m_xf;\n    const aD = this.m_bodyD.m_sweep.a;\n\n    if (this.m_type2 === RevoluteJoint.TYPE) {\n      const revolute = this.m_joint2 as RevoluteJoint;\n      this.m_localAnchorD = revolute.m_localAnchorA;\n      this.m_localAnchorB = revolute.m_localAnchorB;\n      this.m_referenceAngleB = revolute.m_referenceAngle;\n      this.m_localAxisD = Vec2.zero();\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const prismatic = this.m_joint2 as PrismaticJoint;\n      this.m_localAnchorD = prismatic.m_localAnchorA;\n      this.m_localAnchorB = prismatic.m_localAnchorB;\n      this.m_referenceAngleB = prismatic.m_referenceAngle;\n      this.m_localAxisD = prismatic.m_localXAxisA;\n\n      const pD = this.m_localAnchorD;\n      const pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));\n      coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    this.m_constant = coordinateA + this.m_ratio * coordinateB;\n\n    this.m_impulse = 0.0;\n\n    // Gear Joint:\n    // C0 = (coordinate1 + ratio * coordinate2)_initial\n    // C = (coordinate1 + ratio * coordinate2) - C0 = 0\n    // J = [J1 ratio * J2]\n    // K = J * invM * JT\n    // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T\n    //\n    // Revolute:\n    // coordinate = rotation\n    // Cdot = angularVelocity\n    // J = [0 0 1]\n    // K = J * invM * JT = invI\n    //\n    // Prismatic:\n    // coordinate = dot(p - pg, ug)\n    // Cdot = dot(v + cross(w, r), ug)\n    // J = [ug cross(r, ug)]\n    // K = J * invM * JT = invMass + invI * cross(r, ug)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      joint1: this.m_joint1,\n      joint2: this.m_joint2,\n      ratio: this.m_ratio,\n\n      // _constant: this.m_constant,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): GearJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.joint1 = restore(Joint, data.joint1, world);\n    data.joint2 = restore(Joint, data.joint2, world);\n    const joint = new GearJoint(data);\n    // if (data._constant) joint.m_constant = data._constant;\n    return joint;\n  }\n\n  /**\n   * Get the first joint.\n   */\n  getJoint1(): Joint {\n    return this.m_joint1;\n  }\n\n  /**\n   * Get the second joint.\n   */\n  getJoint2(): Joint {\n    return this.m_joint2;\n  }\n\n  /**\n   * Set the gear ratio.\n   */\n  setRatio(ratio: number): void {\n    _ASSERT && console.assert(Number.isFinite(ratio));\n    this.m_ratio = ratio;\n  }\n\n  /**\n   * Get the gear ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    const L = this.m_impulse * this.m_JwA;\n    return inv_dt * L;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n    this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n    this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n    this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n    this.m_mA = this.m_bodyA.m_invMass;\n    this.m_mB = this.m_bodyB.m_invMass;\n    this.m_mC = this.m_bodyC.m_invMass;\n    this.m_mD = this.m_bodyD.m_invMass;\n    this.m_iA = this.m_bodyA.m_invI;\n    this.m_iB = this.m_bodyB.m_invI;\n    this.m_iC = this.m_bodyC.m_invI;\n    this.m_iD = this.m_bodyD.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const aC = this.m_bodyC.c_position.a;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n\n    const aD = this.m_bodyD.c_position.a;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    this.m_mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      this.m_JvAC = Vec2.zero();\n      this.m_JwA = 1.0;\n      this.m_JwC = 1.0;\n      this.m_mass += this.m_iA + this.m_iC;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC);\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);\n      this.m_JvAC = u;\n      this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n      this.m_JwA = Vec2.crossVec2Vec2(rA, u);\n      this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      this.m_JvBD = Vec2.zero();\n      this.m_JwB = this.m_ratio;\n      this.m_JwD = this.m_ratio;\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD);\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n      this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n    }\n\n    // Compute effective mass.\n    this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;\n\n    if (step.warmStarting) {\n      vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n      wA += this.m_iA * this.m_impulse * this.m_JwA;\n\n      vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n      wB += this.m_iB * this.m_impulse * this.m_JwB;\n\n      vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n      wC -= this.m_iC * this.m_impulse * this.m_JwC;\n\n      vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n      wD -= this.m_iD * this.m_impulse * this.m_JwD;\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n    const vC = this.m_bodyC.c_velocity.v;\n    let wC = this.m_bodyC.c_velocity.w;\n    const vD = this.m_bodyD.c_velocity.v;\n    let wD = this.m_bodyD.c_velocity.w;\n\n    let Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD);\n    Cdot += (this.m_JwA * wA - this.m_JwC * wC) + (this.m_JwB * wB - this.m_JwD * wD);\n\n    const impulse = -this.m_mass * Cdot;\n    this.m_impulse += impulse;\n\n    vA.addMul(this.m_mA * impulse, this.m_JvAC);\n    wA += this.m_iA * impulse * this.m_JwA;\n    vB.addMul(this.m_mB * impulse, this.m_JvBD);\n    wB += this.m_iB * impulse * this.m_JwB;\n    vC.subMul(this.m_mC * impulse, this.m_JvAC);\n    wC -= this.m_iC * impulse * this.m_JwC;\n    vD.subMul(this.m_mD * impulse, this.m_JvBD);\n    wD -= this.m_iD * impulse * this.m_JwD;\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n    this.m_bodyC.c_velocity.v.setVec2(vC);\n    this.m_bodyC.c_velocity.w = wC;\n    this.m_bodyD.c_velocity.v.setVec2(vD);\n    this.m_bodyD.c_velocity.w = wD;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n    const cC = this.m_bodyC.c_position.c;\n    let aC = this.m_bodyC.c_position.a;\n    const cD = this.m_bodyD.c_position.c;\n    let aD = this.m_bodyD.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n    const qC = Rot.neo(aC);\n    const qD = Rot.neo(aD);\n\n    const linearError = 0.0;\n\n    let coordinateA: number;\n    let coordinateB: number;\n\n    let JvAC: Vec2;\n    let JvBD: Vec2;\n    let JwA: number;\n    let JwB: number;\n    let JwC: number;\n    let JwD: number;\n    let mass = 0.0;\n\n    if (this.m_type1 == RevoluteJoint.TYPE) {\n      JvAC = Vec2.zero();\n      JwA = 1.0;\n      JwC = 1.0;\n      mass += this.m_iA + this.m_iC;\n\n      coordinateA = aA - aC - this.m_referenceAngleA;\n    } else {\n      const u = Rot.mulVec2(qC, this.m_localAxisC);\n      const rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);\n      const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);\n      JvAC = u;\n      JwC = Vec2.crossVec2Vec2(rC, u);\n      JwA = Vec2.crossVec2Vec2(rA, u);\n      mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n\n      const pC = Vec2.sub(this.m_localAnchorC, this.m_lcC);\n      const pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC)));\n      coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);\n    }\n\n    if (this.m_type2 == RevoluteJoint.TYPE) {\n      JvBD = Vec2.zero();\n      JwB = this.m_ratio;\n      JwD = this.m_ratio;\n      mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n\n      coordinateB = aB - aD - this.m_referenceAngleB;\n    } else {\n      const u = Rot.mulVec2(qD, this.m_localAxisD);\n      const rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n      const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n      JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n      JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n      JwB = this.m_ratio * Vec2.crossVec2Vec2(rB, u);\n      mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;\n\n      const pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);\n      const pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD)));\n      coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n    }\n\n    const C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant;\n\n    let impulse = 0.0;\n    if (mass > 0.0) {\n      impulse = -C / mass;\n    }\n\n    cA.addMul(this.m_mA * impulse, JvAC);\n    aA += this.m_iA * impulse * JwA;\n    cB.addMul(this.m_mB * impulse, JvBD);\n    aB += this.m_iB * impulse * JwB;\n    cC.subMul(this.m_mC * impulse, JvAC);\n    aC -= this.m_iC * impulse * JwC;\n    cD.subMul(this.m_mD * impulse, JvBD);\n    aD -= this.m_iD * impulse * JwD;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n    this.m_bodyC.c_position.c.setVec2(cC);\n    this.m_bodyC.c_position.a = aC;\n    this.m_bodyD.c_position.c.setVec2(cD);\n    this.m_bodyD.c_position.a = aD;\n\n    // TODO_ERIN not implemented\n    return linearError < Settings.linearSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n\n\n/**\n * Motor joint definition.\n */\nexport interface MotorJointOpt extends JointOpt {\n  /**\n   * The bodyB angle minus bodyA angle in radians.\n   */\n  angularOffset?: number;\n  /**\n   * The maximum motor force in N.\n   */\n  maxForce?: number;\n  /**\n   * The maximum motor torque in N-m.\n   */\n  maxTorque?: number;\n  /**\n   * Position correction factor in the range [0,1].\n   */\n  correctionFactor?: number;\n  /**\n   * Position of bodyB minus the position of bodyA, in bodyA's frame, in meters.\n   */\n  linearOffset?: Vec2Value;\n}\n/**\n * Motor joint definition.\n */\nexport interface MotorJointDef extends JointDef, MotorJointOpt {\n}\n\n/** @internal */ const DEFAULTS = {\n  maxForce : 1.0,\n  maxTorque : 1.0,\n  correctionFactor : 0.3\n};\n\n/**\n * A motor joint is used to control the relative motion between two bodies. A\n * typical usage is to control the movement of a dynamic body with respect to\n * the ground.\n */\nexport class MotorJoint extends Joint {\n  static TYPE = 'motor-joint' as const;\n\n  /** @internal */ m_type: 'motor-joint';\n  /** @internal */ m_linearOffset: Vec2;\n  /** @internal */ m_angularOffset: number;\n  /** @internal */ m_linearImpulse: Vec2;\n  /** @internal */ m_angularImpulse: number;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_maxTorque: number;\n  /** @internal */ m_correctionFactor: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_linearError: Vec2;\n  /** @internal */ m_angularError: number;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_linearMass: Mat22;\n  /** @internal */ m_angularMass: number;\n\n  constructor(def: MotorJointDef);\n  constructor(def: MotorJointOpt, bodyA: Body, bodyB: Body);\n  constructor(def: MotorJointDef | MotorJointOpt, bodyA?: Body, bodyB?: Body) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof MotorJoint)) {\n      return new MotorJoint(def, bodyA, bodyB);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MotorJoint.TYPE;\n\n    this.m_linearOffset = Number.isFinite(def.linearOffset) ? Vec2.clone(def.linearOffset) : bodyA.getLocalPoint(bodyB.getPosition());\n    this.m_angularOffset = Number.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_linearImpulse = Vec2.zero();\n    this.m_angularImpulse = 0.0;\n\n    this.m_maxForce = def.maxForce;\n    this.m_maxTorque = def.maxTorque;\n    this.m_correctionFactor = def.correctionFactor;\n\n    // Point-to-point constraint\n    // Cdot = v2 - v1\n    // = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n    //\n    // r1 = offset - c1\n    // r2 = -c2\n\n    // Angle constraint\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      maxForce: this.m_maxForce,\n      maxTorque: this.m_maxTorque,\n      correctionFactor: this.m_correctionFactor,\n\n      linearOffset: this.m_linearOffset,\n      angularOffset: this.m_angularOffset,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MotorJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new MotorJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {}): void {\n  }\n\n  /**\n   * Set the maximum friction force in N.\n   */\n  setMaxForce(force: number): void {\n    _ASSERT && console.assert(Number.isFinite(force) && force >= 0.0);\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum friction force in N.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the maximum friction torque in N*m.\n   */\n  setMaxTorque(torque: number): void {\n    _ASSERT && console.assert(Number.isFinite(torque) && torque >= 0.0);\n    this.m_maxTorque = torque;\n  }\n\n  /**\n   * Get the maximum friction torque in N*m.\n   */\n  getMaxTorque(): number {\n    return this.m_maxTorque;\n  }\n\n  /**\n   * Set the position correction factor in the range [0,1].\n   */\n  setCorrectionFactor(factor: number): void {\n    _ASSERT && console.assert(Number.isFinite(factor) && 0.0 <= factor && factor <= 1.0);\n    this.m_correctionFactor = factor;\n  }\n\n  /**\n   * Get the position correction factor in the range [0,1].\n   */\n  getCorrectionFactor(): number {\n    return this.m_correctionFactor;\n  }\n\n  /**\n   * Set/get the target linear offset, in frame A, in meters.\n   */\n  setLinearOffset(linearOffset: Vec2Value): void {\n    if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_linearOffset.set(linearOffset);\n    }\n  }\n\n  getLinearOffset(): Vec2 {\n    return this.m_linearOffset;\n  }\n\n  /**\n   * Set/get the target angular offset, in radians.\n   */\n  setAngularOffset(angularOffset: number): void {\n    if (angularOffset != this.m_angularOffset) {\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_angularOffset = angularOffset;\n    }\n  }\n\n  getAngularOffset(): number {\n    return this.m_angularOffset;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getPosition();\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getPosition();\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_angularImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective mass matrix.\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    // Upper 2 by 2 of K for point to point\n    const K = new Mat22();\n    K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n    K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n\n    this.m_linearMass = K.getInverse();\n\n    this.m_angularMass = iA + iB;\n    if (this.m_angularMass > 0.0) {\n      this.m_angularMass = 1.0 / this.m_angularMass;\n    }\n\n    this.m_linearError = Vec2.zero();\n    this.m_linearError.addCombine(1, cB, 1, this.m_rB);\n    this.m_linearError.subCombine(1, cA, 1, this.m_rA);\n\n    this.m_angularError = aB - aA - this.m_angularOffset;\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_linearImpulse.mul(step.dtRatio);\n      this.m_angularImpulse *= step.dtRatio;\n\n      const P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_angularImpulse);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_angularImpulse);\n\n    } else {\n      this.m_linearImpulse.setZero();\n      this.m_angularImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const h = step.dt;\n    const inv_h = step.inv_dt;\n\n    // Solve angular friction\n    {\n      const Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n      let impulse = -this.m_angularMass * Cdot;\n\n      const oldImpulse = this.m_angularImpulse;\n      const maxImpulse = h * this.m_maxTorque;\n      this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n      impulse = this.m_angularImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve linear friction\n    {\n      const Cdot = Vec2.zero();\n      Cdot.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n\n      let impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n      const oldImpulse = Vec2.clone(this.m_linearImpulse);\n      this.m_linearImpulse.add(impulse);\n\n      const maxImpulse = h * this.m_maxForce;\n\n      this.m_linearImpulse.clamp(maxImpulse);\n\n      impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n\n      vA.subMul(mA, impulse);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n\n      vB.addMul(mB, impulse);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { EPSILON } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Mat22 } from '../../common/Mat22';\nimport { Rot } from '../../common/Rot';\nimport { Transform } from '../../common/Transform';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_PI = Math.PI;\n\n\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointOpt extends JointOpt {\n  /**\n   * [maxForce = 0.0] The maximum constraint force that can be exerted to move\n   * the candidate body. Usually you will express as some multiple of the\n   * weight (multiplier * mass * gravity).\n   */\n  maxForce?: number;\n  /**\n   * [frequencyHz = 5.0] The response speed.\n   */\n  frequencyHz?: number;\n  /**\n   * [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical\n   * damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Mouse joint definition. This requires a world target point, tuning\n * parameters, and the time step.\n */\nexport interface MouseJointDef extends JointDef, MouseJointOpt {\n  /**\n   * The initial world target point. This is assumed to coincide with the body\n   * anchor initially.\n   */\n  target: Vec2Value;\n}\n\n/** @internal */ const DEFAULTS = {\n  maxForce : 0.0,\n  frequencyHz : 5.0,\n  dampingRatio : 0.7\n};\n\n/**\n * A mouse joint is used to make a point on a body track a specified world\n * point. This a soft constraint with a maximum force. This allows the\n * constraint to stretch and without applying huge forces.\n *\n * You need to call setTarget(target) every time that mouse is \n * moved, to track the new location of the mouse.\n *\n * NOTE: this joint is not documented in the manual because it was developed to\n * be used in the testbed. If you want to learn how to use the mouse joint, look\n * at the testbed.\n */\nexport class MouseJoint extends Joint {\n  static TYPE = 'mouse-joint' as const;\n\n  /** @internal */ m_type: 'mouse-joint';\n  /** @internal */ m_targetA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_maxForce: number;\n  /** @internal */ m_impulse: Vec2;\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n  /** @internal */ m_beta: number;\n  /** @internal */ m_gamma: number;\n  // Solver temp\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat22;\n  /** @internal */ m_C: Vec2;\n\n  constructor(def: MouseJointDef);\n  constructor(def: MouseJointOpt, bodyA: Body, bodyB: Body, target: Vec2Value);\n  constructor(def: MouseJointDef, bodyA?: Body, bodyB?: Body, target?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof MouseJoint)) {\n      return new MouseJoint(def, bodyA, bodyB, target);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = MouseJoint.TYPE;\n\n    _ASSERT && console.assert(Number.isFinite(def.maxForce) && def.maxForce >= 0.0);\n    _ASSERT && console.assert(Number.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);\n    _ASSERT && console.assert(Number.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);\n\n    if (Vec2.isValid(target)) {\n      this.m_targetA = Vec2.clone(target);\n    } else if (Vec2.isValid(def.target)) {\n      this.m_targetA = Vec2.clone(def.target);\n    } else {\n      this.m_targetA = Vec2.zero();\n    }\n\n    this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);\n\n    this.m_maxForce = def.maxForce;\n    this.m_impulse = Vec2.zero();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_beta = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rB = Vec2.zero();\n    this.m_localCenterB = Vec2.zero();\n    this.m_invMassB = 0.0;\n    this.m_invIB = 0.0;\n    this.m_mass = new Mat22();\n    this.m_C = Vec2.zero();\n\n    // p = attached point, m = mouse point\n    // C = p - m\n    // Cdot = v\n    // = v + cross(w, r)\n    // J = [I r_skew]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      target: this.m_targetA,\n      maxForce: this.m_maxForce,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      _localAnchorB: this.m_localAnchorB,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): MouseJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    data.target = Vec2.clone(data.target);\n    const joint = new MouseJoint(data);\n    if (data._localAnchorB) {\n      joint.m_localAnchorB = data._localAnchorB;\n    }\n    return joint;\n  }\n\n  /**\n   * Use this to update the target point.\n   */\n  setTarget(target: Vec2Value): void {\n    if (Vec2.areEqual(target, this.m_targetA)) return;\n    this.m_bodyB.setAwake(true);\n    this.m_targetA.set(target);\n  }\n\n  getTarget(): Vec2 {\n    return this.m_targetA;\n  }\n\n  /**\n   * Set the maximum force in Newtons.\n   */\n  setMaxForce(force: number): void {\n    this.m_maxForce = force;\n  }\n\n  /**\n   * Get the maximum force in Newtons.\n   */\n  getMaxForce(): number {\n    return this.m_maxForce;\n  }\n\n  /**\n   * Set the frequency in Hertz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get the frequency in Hertz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set the damping ratio (dimensionless).\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get the damping ratio (dimensionless).\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return Vec2.clone(this.m_targetA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * 0.0;\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_targetA.sub(newOrigin);\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const position = this.m_bodyB.c_position;\n    const velocity = this.m_bodyB.c_velocity;\n\n    const cB = position.c;\n    const aB = position.a;\n    const vB = velocity.v;\n    let wB = velocity.w;\n\n    const qB = Rot.neo(aB);\n\n    const mass = this.m_bodyB.getMass();\n\n    // Frequency\n    const omega = 2.0 * math_PI * this.m_frequencyHz;\n\n    // Damping coefficient\n    const d = 2.0 * mass * this.m_dampingRatio * omega;\n\n    // Spring stiffness\n    const k = mass * (omega * omega);\n\n    // magic formulas\n    // gamma has units of inverse mass.\n    // beta has units of inverse time.\n    const h = step.dt;\n    _ASSERT && console.assert(d + h * k > EPSILON);\n    this.m_gamma = h * (d + h * k);\n    if (this.m_gamma != 0.0) {\n      this.m_gamma = 1.0 / this.m_gamma;\n    }\n    this.m_beta = h * k * this.m_gamma;\n\n    // Compute the effective mass matrix.\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *\n    // invI2 * skew(r2)]\n    // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y\n    // -r1.x*r1.y]\n    // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]\n    const K = new Mat22();\n    K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y\n        + this.m_gamma;\n    K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n    K.ey.x = K.ex.y;\n    K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x\n        + this.m_gamma;\n\n    this.m_mass = K.getInverse();\n\n    this.m_C.setVec2(cB);\n    this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n    this.m_C.mul(this.m_beta);\n\n    // Cheat with some damping\n    wB *= 0.98;\n\n    if (step.warmStarting) {\n      this.m_impulse.mul(step.dtRatio);\n      vB.addMul(this.m_invMassB, this.m_impulse);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const velocity = this.m_bodyB.c_velocity;\n    const vB = Vec2.clone(velocity.v);\n    let wB = velocity.w;\n\n    // Cdot = v + cross(w, r)\n\n    const Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n    Cdot.add(vB);\n\n    Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n    Cdot.neg();\n\n    let impulse = Mat22.mulVec2(this.m_mass, Cdot);\n\n    const oldImpulse = Vec2.clone(this.m_impulse);\n    this.m_impulse.add(impulse);\n    const maxImpulse = step.dt * this.m_maxForce;\n    this.m_impulse.clamp(maxImpulse);\n    impulse = Vec2.sub(this.m_impulse, oldImpulse);\n\n    vB.addMul(this.m_invMassB, impulse);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n\n    velocity.v.setVec2(vB);\n    velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    return true;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { EPSILON } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n\n\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\n// tslint:disable-next-line:no-empty-interface\nexport interface PulleyJointOpt extends JointOpt {\n}\n/**\n * Pulley joint definition. This requires two ground anchors, two dynamic body\n * anchor points, and a pulley ratio.\n */\nexport interface PulleyJointDef extends JointDef, PulleyJointOpt {\n  /**\n   * The first ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorA: Vec2Value;\n  /**\n   * The second ground anchor in world coordinates. This point never moves.\n   */\n  groundAnchorB: Vec2Value;\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n  /**\n   * The reference length for the segment attached to bodyA.\n   */\n  lengthA: number;\n  /**\n   * The reference length for the segment attached to bodyB.\n   */\n  lengthB: number;\n  /**\n   * The pulley ratio, used to simulate a block-and-tackle.\n   */\n  ratio: number;\n}\n\n/** @internal */ const DEFAULTS = {\n  collideConnected : true\n};\n\n/**\n * The pulley joint is connected to two bodies and two fixed ground points. The\n * pulley supports a ratio such that: length1 + ratio * length2 <= constant\n *\n * Yes, the force transmitted is scaled by the ratio.\n *\n * Warning: the pulley joint can get a bit squirrelly by itself. They often work\n * better when combined with prismatic joints. You should also cover the the\n * anchor points with static shapes to prevent one side from going to zero\n * length.\n */\nexport class PulleyJoint extends Joint {\n  static TYPE = 'pulley-joint' as const;\n  // static MIN_PULLEY_LENGTH: number = 2.0; // TODO where this is used?\n\n  /** @internal */ m_type: 'pulley-joint';\n  /** @internal */ m_groundAnchorA: Vec2;\n  /** @internal */ m_groundAnchorB: Vec2;\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_lengthA: number;\n  /** @internal */ m_lengthB: number;\n  /** @internal */ m_ratio: number;\n  /** @internal */ m_constant: number;\n  /** @internal */ m_impulse: number;\n\n  // Solver temp\n  /** @internal */ m_uA: Vec2;\n  /** @internal */ m_uB: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: number;\n\n  constructor(def: PulleyJointDef);\n  constructor(def: PulleyJointOpt, bodyA: Body, bodyB: Body, groundA: Vec2Value, groundB: Vec2Value, anchorA: Vec2Value, anchorB: Vec2Value, ratio: number);\n  constructor(def: PulleyJointDef, bodyA?: Body, bodyB?: Body, groundA?: Vec2Value, groundB?: Vec2Value, anchorA?: Vec2Value, anchorB?: Vec2Value, ratio?: number) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof PulleyJoint)) {\n      return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = PulleyJoint.TYPE;\n    this.m_groundAnchorA = Vec2.clone(groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0));\n    this.m_groundAnchorB = Vec2.clone(groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0));\n    this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0));\n    this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0));\n    this.m_lengthA = Number.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n    this.m_lengthB = Number.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n    this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;\n\n    _ASSERT && console.assert(ratio > EPSILON);\n\n    this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;\n\n    this.m_impulse = 0.0;\n\n    // Pulley:\n    // length1 = norm(p1 - s1)\n    // length2 = norm(p2 - s2)\n    // C0 = (length1 + ratio * length2)_initial\n    // C = C0 - (length1 + ratio * length2)\n    // u1 = (p1 - s1) / norm(p1 - s1)\n    // u2 = (p2 - s2) / norm(p2 - s2)\n    // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))\n    // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]\n    // K = J * invM * JT\n    // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *\n    // cross(r2, u2)^2)\n  }\n\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      groundAnchorA: this.m_groundAnchorA,\n      groundAnchorB: this.m_groundAnchorB,\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      lengthA: this.m_lengthA,\n      lengthB: this.m_lengthB,\n      ratio: this.m_ratio,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): PulleyJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new PulleyJoint(data);\n    return joint;\n  }\n\n  /**\n   * Get the first ground anchor.\n   */\n  getGroundAnchorA(): Vec2 {\n    return this.m_groundAnchorA;\n  }\n\n  /**\n   * Get the second ground anchor.\n   */\n  getGroundAnchorB(): Vec2 {\n    return this.m_groundAnchorB;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getLengthA(): number {\n    return this.m_lengthA;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getLengthB(): number {\n    return this.m_lengthB;\n  }\n\n  /**\n   * Get the pulley ratio.\n   */\n  getRatio(): number {\n    return this.m_ratio;\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyA.\n   */\n  getCurrentLengthA(): number {\n    const p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    const s = this.m_groundAnchorA;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Get the current length of the segment attached to bodyB.\n   */\n  getCurrentLengthB(): number {\n    const p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    const s = this.m_groundAnchorB;\n    return Vec2.distance(p, s);\n  }\n\n  /**\n   * Shift the origin for any points stored in world coordinates.\n   *\n   * @param newOrigin\n   */\n  shiftOrigin(newOrigin: Vec2Value): void {\n    this.m_groundAnchorA.sub(newOrigin);\n    this.m_groundAnchorB.sub(newOrigin);\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = this.m_uA.length();\n    const lengthB = this.m_uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      this.m_uA.mul(1.0 / lengthA);\n    } else {\n      this.m_uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      this.m_uB.mul(1.0 / lengthB);\n    } else {\n      this.m_uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA);\n    const ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB);\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA;\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB;\n\n    this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n\n    if (this.m_mass > 0.0) {\n      this.m_mass = 1.0 / this.m_mass;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support variable time steps.\n      this.m_impulse *= step.dtRatio;\n\n      // Warm starting.\n      const PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n      const PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n\n      vA.addMul(this.m_invMassA, PA);\n      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n\n      vB.addMul(this.m_invMassB, PB);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const vpA = Vec2.add(vA, Vec2.crossNumVec2(wA, this.m_rA));\n    const vpB = Vec2.add(vB, Vec2.crossNumVec2(wB, this.m_rB));\n\n    const Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);\n    const impulse = -this.m_mass * Cdot;\n    this.m_impulse += impulse;\n\n    const PA = Vec2.mulNumVec2(-impulse, this.m_uA);\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB);\n    vA.addMul(this.m_invMassA, PA);\n    wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n    vB.addMul(this.m_invMassB, PB);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // Get the pulley axes.\n    const uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);\n    const uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);\n\n    const lengthA = uA.length();\n    const lengthB = uB.length();\n\n    if (lengthA > 10.0 * Settings.linearSlop) {\n      uA.mul(1.0 / lengthA);\n    } else {\n      uA.setZero();\n    }\n\n    if (lengthB > 10.0 * Settings.linearSlop) {\n      uB.mul(1.0 / lengthB);\n    } else {\n      uB.setZero();\n    }\n\n    // Compute effective mass.\n    const ruA = Vec2.crossVec2Vec2(rA, uA);\n    const ruB = Vec2.crossVec2Vec2(rB, uB);\n\n    const mA = this.m_invMassA + this.m_invIA * ruA * ruA;\n    const mB = this.m_invMassB + this.m_invIB * ruB * ruB;\n\n    let mass = mA + this.m_ratio * this.m_ratio * mB;\n\n    if (mass > 0.0) {\n      mass = 1.0 / mass;\n    }\n\n    const C = this.m_constant - lengthA - this.m_ratio * lengthB;\n    const linearError = math_abs(C);\n\n    const impulse = -mass * C;\n\n    const PA = Vec2.mulNumVec2(-impulse, uA);\n    const PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB);\n\n    cA.addMul(this.m_invMassA, PA);\n    aA += this.m_invIA * Vec2.crossVec2Vec2(rA, PA);\n    cB.addMul(this.m_invMassB, PB);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, PB);\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return linearError < Settings.linearSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_min = Math.min;\n\n/** @internal */ enum LimitState {\n  inactiveLimit = 0,\n  atLowerLimit = 1,\n  atUpperLimit = 2,\n  equalLimits = 3,\n}\n\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointOpt extends JointOpt {\n  /**\n   * The maximum length of the rope.\n   * Warning: this must be larger than linearSlop or the joint will have no effect.\n   */\n  maxLength?: number;\n}\n/**\n * Rope joint definition. This requires two body anchor points and a maximum\n * lengths. Note: by default the connected objects will not collide. see\n * collideConnected in JointDef.\n */\nexport interface RopeJointDef extends JointDef, RopeJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n}\n\n/** @internal */ const DEFAULTS = {\n  maxLength : 0.0,\n};\n\n/**\n * A rope joint enforces a maximum distance between two points on two bodies. It\n * has no other effect.\n *\n * Warning: if you attempt to change the maximum length during the simulation\n * you will get some non-physical behavior.\n *\n * A model that would allow you to dynamically modify the length would have some\n * sponginess, so I chose not to implement it that way. See {@link DistanceJoint} if you\n * want to dynamically control length.\n */\nexport class RopeJoint extends Joint {\n  static TYPE = 'rope-joint' as const;\n\n  /** @internal */ m_type: 'rope-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n\n  /** @internal */ m_maxLength: number;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_length: number;\n  /** @internal */ m_state: number; // TODO enum\n\n  // Solver temp\n  /** @internal */ m_u: Vec2;\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  constructor(def: RopeJointDef);\n  constructor(def: RopeJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2Value);\n  constructor(def: RopeJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof RopeJoint)) {\n      return new RopeJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = RopeJoint.TYPE;\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0));\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0));\n\n    this.m_maxLength = def.maxLength;\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_length = 0.0;\n    this.m_state = LimitState.inactiveLimit;\n\n    // Limit:\n    // C = norm(pB - pA) - L\n    // u = (pB - pA) / norm(pB - pA)\n    // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))\n    // J = [-u -cross(rA, u) u cross(rB, u)]\n    // K = J * invM * JT\n    // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      maxLength: this.m_maxLength,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): RopeJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new RopeJoint(data);\n    return joint;\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Set the maximum length of the rope.\n   */\n  setMaxLength(length: number): void {\n    this.m_maxLength = length;\n  }\n\n  /**\n   * Get the maximum length of the rope.\n   */\n  getMaxLength(): number {\n    return this.m_maxLength;\n  }\n\n  getLimitState(): number {\n    // TODO LimitState\n    return this.m_state;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return 0.0;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    this.m_u = Vec2.zero();\n    this.m_u.addCombine(1, cB, 1, this.m_rB);\n    this.m_u.subCombine(1, cA, 1, this.m_rA);\n\n    this.m_length = this.m_u.length();\n\n    const C = this.m_length - this.m_maxLength;\n    if (C > 0.0) {\n      this.m_state = LimitState.atUpperLimit;\n    } else {\n      this.m_state = LimitState.inactiveLimit;\n    }\n\n    if (this.m_length > Settings.linearSlop) {\n      this.m_u.mul(1.0 / this.m_length);\n    } else {\n      this.m_u.setZero();\n      this.m_mass = 0.0;\n      this.m_impulse = 0.0;\n      return;\n    }\n\n    // Compute effective mass.\n    const crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n    const crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n    const invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;\n\n    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;\n\n    if (step.warmStarting) {\n      // Scale the impulse to support a variable time step.\n      this.m_impulse *= step.dtRatio;\n\n      const P = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    } else {\n      this.m_impulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Cdot = dot(u, v + cross(w, r))\n    const vpA = Vec2.addCrossNumVec2(vA, wA, this.m_rA);\n    const vpB = Vec2.addCrossNumVec2(vB, wB, this.m_rB);\n    const C = this.m_length - this.m_maxLength;\n    let Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));\n\n    // Predictive constraint.\n    if (C < 0.0) {\n      Cdot += step.inv_dt * C;\n    }\n\n    let impulse = -this.m_mass * Cdot;\n    const oldImpulse = this.m_impulse;\n    this.m_impulse = math_min(0.0, this.m_impulse + impulse);\n    impulse = this.m_impulse - oldImpulse;\n\n    const P = Vec2.mulNumVec2(impulse, this.m_u);\n    vA.subMul(this.m_invMassA, P);\n    wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P);\n    vB.addMul(this.m_invMassB, P);\n    wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P);\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n    const rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n    const u = Vec2.zero();\n    u.addCombine(1, cB, 1, rB);\n    u.subCombine(1, cA, 1, rA);\n\n    const length = u.normalize();\n    let C = length - this.m_maxLength;\n\n    C = clamp(C, 0.0, Settings.maxLinearCorrection);\n\n    const impulse = -this.m_mass * C;\n    const P = Vec2.mulNumVec2(impulse, u);\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * Vec2.crossVec2Vec2(rA, P);\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * Vec2.crossVec2Vec2(rB, P);\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return length - this.m_maxLength < Settings.linearSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Vec3 } from '../../common/Vec3';\nimport { Mat33 } from '../../common/Mat33';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_PI = Math.PI;\n\n\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n *\n * @prop {float} frequencyHz\n * @prop {float} dampingRatio\n *\n * @prop {Vec2} localAnchorA\n * @prop {Vec2} localAnchorB\n * @prop {float} referenceAngle\n */\nexport interface WeldJointOpt extends JointOpt {\n  /**\n   * The mass-spring-damper frequency in Hertz. Rotation only. Disable softness\n   * with a value of 0.\n   */\n  frequencyHz?: number;\n  /**\n   * The damping ratio. 0 = no damping, 1 = critical damping.\n   */\n  dampingRatio?: number;\n  /**\n   * The bodyB angle minus bodyA angle in the reference state (radians).\n   */\n  referenceAngle?: number;\n}\n/**\n * Weld joint definition. You need to specify local anchor points where they are\n * attached and the relative body angle. The position of the anchor points is\n * important for computing the reaction torque.\n */\nexport interface WeldJointDef extends JointDef, WeldJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n}\n\n/** @internal */ const DEFAULTS = {\n  frequencyHz : 0.0,\n  dampingRatio : 0.0,\n};\n\n/**\n * A weld joint essentially glues two bodies together. A weld joint may distort\n * somewhat because the island constraint solver is approximate.\n */\nexport class WeldJoint extends Joint {\n  static TYPE = 'weld-joint' as const\n\n  /** @internal */ m_type: 'weld-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_referenceAngle: number;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_impulse: Vec3;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_rA: Vec2;\n  /** @internal */ m_rB: Vec2;\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n  /** @internal */ m_mass: Mat33;\n\n  constructor(def: WeldJointDef);\n  constructor(def: WeldJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2Value);\n  constructor(def: WeldJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof WeldJoint)) {\n      return new WeldJoint(def, bodyA, bodyB, anchor);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_type = WeldJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n    this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_impulse = new Vec3();\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Solver temp\n    this.m_rA;\n    this.m_rB;\n    this.m_localCenterA;\n    this.m_localCenterB;\n    this.m_invMassA;\n    this.m_invMassB;\n    this.m_invIA;\n    this.m_invIB;\n    this.m_mass = new Mat33();\n\n    // Point-to-point constraint\n    // C = p2 - p1\n    // Cdot = v2 - v1\n    // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)\n    // J = [-I -r1_skew I r2_skew ]\n    // Identity used:\n    // w k % (rx i + ry j) = w * (-ry i + rx j)\n\n    // Angle constraint\n    // C = angle2 - angle1 - referenceAngle\n    // Cdot = w2 - w1\n    // J = [0 0 -1 0 0 1]\n    // K = invI1 + invI2\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      referenceAngle: this.m_referenceAngle,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WeldJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WeldJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2Value,\n    localAnchorA?: Vec2Value,\n    anchorB?: Vec2Value,\n    localAnchorB?: Vec2Value,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * Get the reference angle.\n   */\n  getReferenceAngle(): number {\n    return this.m_referenceAngle;\n  }\n\n  /**\n   * Set frequency in Hz.\n   */\n  setFrequency(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  /**\n   * Get frequency in Hz.\n   */\n  getFrequency(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set damping ratio.\n   */\n  setDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  /**\n   * Get damping ratio.\n   */\n  getDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_impulse.z;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    // J = [-I -r1_skew I r2_skew]\n    // [ 0 -1 0 1]\n    // r_skew = [-ry; rx]\n\n    // Matlab\n    // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]\n    // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]\n    // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y\n        * iB;\n    K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n    K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x\n        * iB;\n    K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      K.getInverse22(this.m_mass);\n\n      let invM = iA + iB;\n      const m = invM > 0.0 ? 1.0 / invM : 0.0;\n\n      const C = aB - aA - this.m_referenceAngle;\n\n      // Frequency\n      const omega = 2.0 * math_PI * this.m_frequencyHz;\n\n      // Damping coefficient\n      const d = 2.0 * m * this.m_dampingRatio * omega;\n\n      // Spring stiffness\n      const k = m * omega * omega;\n\n      // magic formulas\n      const h = step.dt;\n      this.m_gamma = h * (d + h * k);\n      this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;\n      this.m_bias = C * h * k * this.m_gamma;\n\n      invM += this.m_gamma;\n      this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;\n    } else if (K.ez.z == 0.0) {\n      K.getInverse22(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    } else {\n      K.getSymInverse33(this.m_mass);\n      this.m_gamma = 0.0;\n      this.m_bias = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Scale impulses to support a variable time step.\n      this.m_impulse.mul(step.dtRatio);\n\n      const P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + this.m_impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + this.m_impulse.z);\n\n    } else {\n      this.m_impulse.setZero();\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    if (this.m_frequencyHz > 0.0) {\n      const Cdot2 = wB - wA;\n\n      const impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);\n      this.m_impulse.z += impulse2;\n\n      wA -= iA * impulse2;\n      wB += iB * impulse2;\n\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n\n      const impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1));\n      this.m_impulse.x += impulse1.x;\n      this.m_impulse.y += impulse1.y;\n\n      const P = Vec2.clone(impulse1);\n\n      vA.subMul(mA, P);\n      wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P);\n\n      vB.addMul(mB, P);\n      wB += iB * Vec2.crossVec2Vec2(this.m_rB, P);\n    } else {\n      const Cdot1 = Vec2.zero();\n      Cdot1.addCombine(1, vB, 1, Vec2.crossNumVec2(wB, this.m_rB));\n      Cdot1.subCombine(1, vA, 1, Vec2.crossNumVec2(wA, this.m_rA));\n      const Cdot2 = wB - wA;\n      const Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n\n      const impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot));\n      this.m_impulse.add(impulse);\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      vA.subMul(mA, P);\n      wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P) + impulse.z);\n\n      vB.addMul(mB, P);\n      wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_velocity.v = vA;\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v = vB;\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n\n    let positionError: number;\n    let angularError: number;\n\n    const K = new Mat33();\n    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;\n    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;\n    K.ez.x = -rA.y * iA - rB.y * iB;\n    K.ex.y = K.ey.x;\n    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;\n    K.ez.y = rA.x * iA + rB.x * iB;\n    K.ex.z = K.ez.x;\n    K.ey.z = K.ez.y;\n    K.ez.z = iA + iB;\n\n    if (this.m_frequencyHz > 0.0) {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA);\n\n      positionError = C1.length();\n      angularError = 0.0;\n\n      const P = Vec2.neg(K.solve22(C1));\n\n      cA.subMul(mA, P);\n      aA -= iA * Vec2.crossVec2Vec2(rA, P);\n\n      cB.addMul(mB, P);\n      aB += iB * Vec2.crossVec2Vec2(rB, P);\n    } else {\n      const C1 = Vec2.zero();\n      C1.addCombine(1, cB, 1, rB);\n      C1.subCombine(1, cA, 1, rA);\n\n      const C2 = aB - aA - this.m_referenceAngle;\n\n      positionError = C1.length();\n      angularError = math_abs(C2);\n\n      const C = new Vec3(C1.x, C1.y, C2);\n\n      let impulse = new Vec3();\n      if (K.ez.z > 0.0) {\n        impulse = Vec3.neg(K.solve33(C));\n      } else {\n        const impulse2 = Vec2.neg(K.solve22(C1));\n        impulse.set(impulse2.x, impulse2.y, 0.0);\n      }\n\n      const P = Vec2.neo(impulse.x, impulse.y);\n\n      cA.subMul(mA, P);\n      aA -= iA * (Vec2.crossVec2Vec2(rA, P) + impulse.z);\n\n      cB.addMul(mB, P);\n      aB += iB * (Vec2.crossVec2Vec2(rB, P) + impulse.z);\n    }\n\n    this.m_bodyA.c_position.c = cA;\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c = cB;\n    this.m_bodyB.c_position.a = aB;\n\n    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;\n  }\n\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { options } from '../../util/options';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { clamp } from '../../common/Math';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { Rot } from '../../common/Rot';\nimport { Joint, JointOpt, JointDef } from '../Joint';\nimport { Body } from '../Body';\nimport { TimeStep } from \"../Solver\";\n\n\n/** @internal */ const _CONSTRUCTOR_FACTORY = typeof CONSTRUCTOR_FACTORY === 'undefined' ? false : CONSTRUCTOR_FACTORY;\n/** @internal */ const math_abs = Math.abs;\n/** @internal */ const math_PI = Math.PI;\n\n\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointOpt extends JointOpt {\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor?: boolean;\n  /**\n   * The maximum motor torque, usually in N-m.\n   */\n  maxMotorTorque?: number;\n  /**\n   * The desired motor speed in radians per second.\n   */\n  motorSpeed?: number;\n  /**\n   * Suspension frequency, zero indicates no suspension.\n   */\n  frequencyHz?: number;\n  /**\n   * Suspension damping ratio, one indicates critical damping.\n   */\n  dampingRatio?: number;\n}\n/**\n * Wheel joint definition. This requires defining a line of motion using an axis\n * and an anchor point. The definition uses local anchor points and a local axis\n * so that the initial configuration can violate the constraint slightly. The\n * joint translation is zero when the local anchor points coincide in world\n * space. Using local anchors and a local axis helps when saving and loading a\n * game.\n */\nexport interface WheelJointDef extends JointDef, WheelJointOpt {\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  localAnchorA: Vec2Value;\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  localAnchorB: Vec2Value;\n  /**\n   * The local translation axis in bodyA.\n   */\n  localAxisA: Vec2Value;\n\n  /** @internal renamed to localAxisA */\n  localAxis?: Vec2Value;\n}\n\n/** @internal */ const DEFAULTS = {\n  enableMotor : false,\n  maxMotorTorque : 0.0,\n  motorSpeed : 0.0,\n  frequencyHz : 2.0,\n  dampingRatio : 0.7,\n};\n\n/**\n * A wheel joint. This joint provides two degrees of freedom: translation along\n * an axis fixed in bodyA and rotation in the plane. In other words, it is a\n * point to line constraint with a rotational motor and a linear spring/damper.\n * This joint is designed for vehicle suspensions.\n */\nexport class WheelJoint extends Joint {\n  static TYPE = 'wheel-joint' as const;\n\n  /** @internal */ m_type: 'wheel-joint';\n  /** @internal */ m_localAnchorA: Vec2;\n  /** @internal */ m_localAnchorB: Vec2;\n  /** @internal */ m_localXAxisA: Vec2;\n  /** @internal */ m_localYAxisA: Vec2;\n\n  /** @internal */ m_mass: number;\n  /** @internal */ m_impulse: number;\n  /** @internal */ m_motorMass: number;\n  /** @internal */ m_motorImpulse: number;\n  /** @internal */ m_springMass: number;\n  /** @internal */ m_springImpulse: number;\n\n  /** @internal */ m_maxMotorTorque: number;\n  /** @internal */ m_motorSpeed: number;\n  /** @internal */ m_enableMotor: boolean;\n\n  /** @internal */ m_frequencyHz: number;\n  /** @internal */ m_dampingRatio: number;\n\n  /** @internal */ m_bias: number;\n  /** @internal */ m_gamma: number;\n\n  // Solver temp\n  /** @internal */ m_localCenterA: Vec2;\n  /** @internal */ m_localCenterB: Vec2;\n  /** @internal */ m_invMassA: number;\n  /** @internal */ m_invMassB: number;\n  /** @internal */ m_invIA: number;\n  /** @internal */ m_invIB: number;\n\n  /** @internal */ m_ax: Vec2;\n  /** @internal */ m_ay: Vec2;\n  /** @internal */ m_sAx: number;\n  /** @internal */ m_sBx: number;\n  /** @internal */ m_sAy: number;\n  /** @internal */ m_sBy: number;\n\n  constructor(def: WheelJointDef);\n  constructor(def: WheelJointOpt, bodyA: Body, bodyB: Body, anchor: Vec2Value, axis: Vec2Value);\n  constructor(def: WheelJointDef, bodyA?: Body, bodyB?: Body, anchor?: Vec2Value, axis?: Vec2Value) {\n    // @ts-ignore\n    if (_CONSTRUCTOR_FACTORY && !(this instanceof WheelJoint)) {\n      return new WheelJoint(def, bodyA, bodyB, anchor, axis);\n    }\n\n    def = options(def, DEFAULTS);\n    super(def, bodyA, bodyB);\n    bodyA = this.m_bodyA;\n    bodyB = this.m_bodyB;\n\n    this.m_ax = Vec2.zero();\n    this.m_ay = Vec2.zero();\n\n    this.m_type = WheelJoint.TYPE;\n\n    this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n    this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n\n    if (Vec2.isValid(axis)) {\n      this.m_localXAxisA = bodyA.getLocalVector(axis);\n    } else if (Vec2.isValid(def.localAxisA)) {\n      this.m_localXAxisA = Vec2.clone(def.localAxisA);\n    } else if (Vec2.isValid(def.localAxis)) {\n      // localAxis is renamed to localAxisA, this is for backward compatibility\n      this.m_localXAxisA = Vec2.clone(def.localAxis);\n    } else {\n      this.m_localXAxisA = Vec2.neo(1.0, 0.0);\n    }\n\n    this.m_localYAxisA = Vec2.crossNumVec2(1.0, this.m_localXAxisA);\n\n    this.m_mass = 0.0;\n    this.m_impulse = 0.0;\n    this.m_motorMass = 0.0;\n    this.m_motorImpulse = 0.0;\n    this.m_springMass = 0.0;\n    this.m_springImpulse = 0.0;\n\n    this.m_maxMotorTorque = def.maxMotorTorque;\n    this.m_motorSpeed = def.motorSpeed;\n    this.m_enableMotor = def.enableMotor;\n\n    this.m_frequencyHz = def.frequencyHz;\n    this.m_dampingRatio = def.dampingRatio;\n\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n\n    // Linear constraint (point-to-line)\n    // d = pB - pA = xB + rB - xA - rA\n    // C = dot(ay, d)\n    // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,\n    // rA))\n    // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,\n    // ay), vB)\n    // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]\n\n    // Spring linear constraint\n    // C = dot(ax, d)\n    // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +\n    // dot(cross(rB, ax), vB)\n    // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]\n\n    // Motor rotational constraint\n    // Cdot = wB - wA\n    // J = [0 0 -1 0 0 1]\n  }\n\n  /** @internal */\n  _serialize(): object {\n    return {\n      type: this.m_type,\n      bodyA: this.m_bodyA,\n      bodyB: this.m_bodyB,\n      collideConnected: this.m_collideConnected,\n\n      enableMotor: this.m_enableMotor,\n      maxMotorTorque: this.m_maxMotorTorque,\n      motorSpeed: this.m_motorSpeed,\n      frequencyHz: this.m_frequencyHz,\n      dampingRatio: this.m_dampingRatio,\n\n      localAnchorA: this.m_localAnchorA,\n      localAnchorB: this.m_localAnchorB,\n      localAxisA: this.m_localXAxisA,\n    };\n  }\n\n  /** @internal */\n  static _deserialize(data: any, world: any, restore: any): WheelJoint {\n    data = {...data};\n    data.bodyA = restore(Body, data.bodyA, world);\n    data.bodyB = restore(Body, data.bodyB, world);\n    const joint = new WheelJoint(data);\n    return joint;\n  }\n\n  /** @internal */\n  _setAnchors(def: {\n    anchorA?: Vec2Value,\n    localAnchorA?: Vec2Value,\n    anchorB?: Vec2Value,\n    localAnchorB?: Vec2Value,\n    localAxisA?: Vec2Value,\n  }): void {\n    if (def.anchorA) {\n      this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n    } else if (def.localAnchorA) {\n      this.m_localAnchorA.setVec2(def.localAnchorA);\n    }\n\n    if (def.anchorB) {\n      this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n    } else if (def.localAnchorB) {\n      this.m_localAnchorB.setVec2(def.localAnchorB);\n    }\n\n    if (def.localAxisA) {\n      this.m_localXAxisA.setVec2(def.localAxisA);\n      this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1.0, def.localAxisA));\n    }\n  }\n\n  /**\n   * The local anchor point relative to bodyA's origin.\n   */\n  getLocalAnchorA(): Vec2 {\n    return this.m_localAnchorA;\n  }\n\n  /**\n   * The local anchor point relative to bodyB's origin.\n   */\n  getLocalAnchorB(): Vec2 {\n    return this.m_localAnchorB;\n  }\n\n  /**\n   * The local joint axis relative to bodyA.\n   */\n  getLocalAxisA(): Vec2 {\n    return this.m_localXAxisA;\n  }\n\n  /**\n   * Get the current joint translation, usually in meters.\n   */\n  getJointTranslation(): number {\n    const bA = this.m_bodyA;\n    const bB = this.m_bodyB;\n\n    const pA = bA.getWorldPoint(this.m_localAnchorA);\n    const pB = bB.getWorldPoint(this.m_localAnchorB);\n    const d = Vec2.sub(pB, pA);\n    const axis = bA.getWorldVector(this.m_localXAxisA);\n\n    const translation = Vec2.dot(d, axis);\n    return translation;\n  }\n\n  /**\n   * Get the current joint translation speed, usually in meters per second.\n   */\n  getJointSpeed(): number {\n    const wA = this.m_bodyA.m_angularVelocity;\n    const wB = this.m_bodyB.m_angularVelocity;\n    return wB - wA;\n  }\n\n  /**\n   * Is the joint motor enabled?\n   */\n  isMotorEnabled(): boolean {\n    return this.m_enableMotor;\n  }\n\n  /**\n   * Enable/disable the joint motor.\n   */\n  enableMotor(flag: boolean): void {\n    if (flag == this.m_enableMotor) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_enableMotor = flag;\n  }\n\n  /**\n   * Set the motor speed, usually in radians per second.\n   */\n  setMotorSpeed(speed: number): void {\n    if (speed == this.m_motorSpeed) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_motorSpeed = speed;\n  }\n\n  /**\n   * Get the motor speed, usually in radians per second.\n   */\n  getMotorSpeed(): number {\n    return this.m_motorSpeed;\n  }\n\n  /**\n   * Set/Get the maximum motor force, usually in N-m.\n   */\n  setMaxMotorTorque(torque: number): void {\n    if (torque == this.m_maxMotorTorque) return;\n    this.m_bodyA.setAwake(true);\n    this.m_bodyB.setAwake(true);\n    this.m_maxMotorTorque = torque;\n  }\n\n  getMaxMotorTorque(): number {\n    return this.m_maxMotorTorque;\n  }\n\n  /**\n   * Get the current motor torque given the inverse time step, usually in N-m.\n   */\n  getMotorTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  /**\n   * Set/Get the spring frequency in hertz. Setting the frequency to zero disables\n   * the spring.\n   */\n  setSpringFrequencyHz(hz: number): void {\n    this.m_frequencyHz = hz;\n  }\n\n  getSpringFrequencyHz(): number {\n    return this.m_frequencyHz;\n  }\n\n  /**\n   * Set/Get the spring damping ratio\n   */\n  setSpringDampingRatio(ratio: number): void {\n    this.m_dampingRatio = ratio;\n  }\n\n  getSpringDampingRatio(): number {\n    return this.m_dampingRatio;\n  }\n\n  /**\n   * Get the anchor point on bodyA in world coordinates.\n   */\n  getAnchorA(): Vec2 {\n    return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n  }\n\n  /**\n   * Get the anchor point on bodyB in world coordinates.\n   */\n  getAnchorB(): Vec2 {\n    return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n  }\n\n  /**\n   * Get the reaction force on bodyB at the joint anchor in Newtons.\n   */\n  getReactionForce(inv_dt: number): Vec2 {\n    return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n  }\n\n  /**\n   * Get the reaction torque on bodyB in N*m.\n   */\n  getReactionTorque(inv_dt: number): number {\n    return inv_dt * this.m_motorImpulse;\n  }\n\n  initVelocityConstraints(step: TimeStep): void {\n    this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n    this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n    this.m_invMassA = this.m_bodyA.m_invMass;\n    this.m_invMassB = this.m_bodyB.m_invMass;\n    this.m_invIA = this.m_bodyA.m_invI;\n    this.m_invIB = this.m_bodyB.m_invI;\n\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const cA = this.m_bodyA.c_position.c;\n    const aA = this.m_bodyA.c_position.a;\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n\n    const cB = this.m_bodyB.c_position.c;\n    const aB = this.m_bodyB.c_position.a;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    // Compute the effective masses.\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    // Point to line constraint\n    {\n      this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n      this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ay);\n      this.m_sBy = Vec2.crossVec2Vec2(rB, this.m_ay);\n\n      this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy\n          * this.m_sBy;\n\n      if (this.m_mass > 0.0) {\n        this.m_mass = 1.0 / this.m_mass;\n      }\n    }\n\n    // Spring constraint\n    this.m_springMass = 0.0;\n    this.m_bias = 0.0;\n    this.m_gamma = 0.0;\n    if (this.m_frequencyHz > 0.0) {\n      this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n      this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d, rA), this.m_ax);\n      this.m_sBx = Vec2.crossVec2Vec2(rB, this.m_ax);\n\n      const invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx\n          * this.m_sBx;\n\n      if (invMass > 0.0) {\n        this.m_springMass = 1.0 / invMass;\n\n        const C = Vec2.dot(d, this.m_ax);\n\n        // Frequency\n        const omega = 2.0 * math_PI * this.m_frequencyHz;\n\n        // Damping coefficient\n        const damp = 2.0 * this.m_springMass * this.m_dampingRatio * omega;\n\n        // Spring stiffness\n        const k = this.m_springMass * omega * omega;\n\n        // magic formulas\n        const h = step.dt;\n        this.m_gamma = h * (damp + h * k);\n        if (this.m_gamma > 0.0) {\n          this.m_gamma = 1.0 / this.m_gamma;\n        }\n\n        this.m_bias = C * h * k * this.m_gamma;\n\n        this.m_springMass = invMass + this.m_gamma;\n        if (this.m_springMass > 0.0) {\n          this.m_springMass = 1.0 / this.m_springMass;\n        }\n      }\n    } else {\n      this.m_springImpulse = 0.0;\n    }\n\n    // Rotational motor\n    if (this.m_enableMotor) {\n      this.m_motorMass = iA + iB;\n      if (this.m_motorMass > 0.0) {\n        this.m_motorMass = 1.0 / this.m_motorMass;\n      }\n    } else {\n      this.m_motorMass = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    if (step.warmStarting) {\n      // Account for variable time step.\n      this.m_impulse *= step.dtRatio;\n      this.m_springImpulse *= step.dtRatio;\n      this.m_motorImpulse *= step.dtRatio;\n\n      const P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n      const LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n      const LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n\n      vA.subMul(this.m_invMassA, P);\n      wA -= this.m_invIA * LA;\n\n      vB.addMul(this.m_invMassB, P);\n      wB += this.m_invIB * LB;\n\n    } else {\n      this.m_impulse = 0.0;\n      this.m_springImpulse = 0.0;\n      this.m_motorImpulse = 0.0;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  solveVelocityConstraints(step: TimeStep): void {\n    const mA = this.m_invMassA;\n    const mB = this.m_invMassB;\n    const iA = this.m_invIA;\n    const iB = this.m_invIB;\n\n    const vA = this.m_bodyA.c_velocity.v;\n    let wA = this.m_bodyA.c_velocity.w;\n    const vB = this.m_bodyB.c_velocity.v;\n    let wB = this.m_bodyB.c_velocity.w;\n\n    // Solve spring constraint\n    {\n      const Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx * wB - this.m_sAx * wA;\n      const impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);\n      this.m_springImpulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ax);\n      const LA = impulse * this.m_sAx;\n      const LB = impulse * this.m_sBx;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    // Solve rotational motor constraint\n    {\n      const Cdot = wB - wA - this.m_motorSpeed;\n      let impulse = -this.m_motorMass * Cdot;\n\n      const oldImpulse = this.m_motorImpulse;\n      const maxImpulse = step.dt * this.m_maxMotorTorque;\n      this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n      impulse = this.m_motorImpulse - oldImpulse;\n\n      wA -= iA * impulse;\n      wB += iB * impulse;\n    }\n\n    // Solve point to line constraint\n    {\n      const Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy * wB - this.m_sAy * wA;\n      const impulse = -this.m_mass * Cdot;\n      this.m_impulse += impulse;\n\n      const P = Vec2.mulNumVec2(impulse, this.m_ay);\n      const LA = impulse * this.m_sAy;\n      const LB = impulse * this.m_sBy;\n\n      vA.subMul(mA, P);\n      wA -= iA * LA;\n\n      vB.addMul(mB, P);\n      wB += iB * LB;\n    }\n\n    this.m_bodyA.c_velocity.v.setVec2(vA);\n    this.m_bodyA.c_velocity.w = wA;\n    this.m_bodyB.c_velocity.v.setVec2(vB);\n    this.m_bodyB.c_velocity.w = wB;\n  }\n\n  /**\n   * This returns true if the position errors are within tolerance.\n   */\n  solvePositionConstraints(step: TimeStep): boolean {\n    const cA = this.m_bodyA.c_position.c;\n    let aA = this.m_bodyA.c_position.a;\n    const cB = this.m_bodyB.c_position.c;\n    let aB = this.m_bodyB.c_position.a;\n\n    const qA = Rot.neo(aA);\n    const qB = Rot.neo(aB);\n\n    const rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n    const rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n    const d = Vec2.zero();\n    d.addCombine(1, cB, 1, rB);\n    d.subCombine(1, cA, 1, rA);\n\n    const ay = Rot.mulVec2(qA, this.m_localYAxisA);\n\n    const sAy = Vec2.crossVec2Vec2(Vec2.add(d, rA), ay);\n    const sBy = Vec2.crossVec2Vec2(rB, ay);\n\n    const C = Vec2.dot(d, ay);\n\n    const k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;\n\n    const impulse = k != 0.0 ? -C / k : 0.0;\n\n    const P = Vec2.mulNumVec2(impulse, ay);\n    const LA = impulse * sAy;\n    const LB = impulse * sBy;\n\n    cA.subMul(this.m_invMassA, P);\n    aA -= this.m_invIA * LA;\n    cB.addMul(this.m_invMassB, P);\n    aB += this.m_invIB * LB;\n\n    this.m_bodyA.c_position.c.setVec2(cA);\n    this.m_bodyA.c_position.a = aA;\n    this.m_bodyB.c_position.c.setVec2(cB);\n    this.m_bodyB.c_position.a = aB;\n\n    return math_abs(C) <= Settings.linearSlop;\n  }\n\n}\n", "// tslint:disable:typedef\nimport { World } from '../dynamics/World';\nimport { Body } from '../dynamics/Body';\nimport { Joint } from '../dynamics/Joint';\nimport { Fixture } from '../dynamics/Fixture';\nimport { Shape } from '../collision/Shape';\nimport { Vec2 } from '../common/Vec2';\nimport { Vec3 } from '../common/Vec3';\nimport { ChainShape } from \"../collision/shape/ChainShape\";\nimport { BoxShape } from \"../collision/shape/BoxShape\";\nimport { EdgeShape } from \"../collision/shape/EdgeShape\";\nimport { PolygonShape } from \"../collision/shape/PolygonShape\";\nimport { CircleShape } from \"../collision/shape/CircleShape\";\nimport { DistanceJoint } from \"../dynamics/joint/DistanceJoint\";\nimport { FrictionJoint } from \"../dynamics/joint/FrictionJoint\";\nimport { GearJoint } from \"../dynamics/joint/GearJoint\";\nimport { MotorJoint } from \"../dynamics/joint/MotorJoint\";\nimport { MouseJoint } from \"../dynamics/joint/MouseJoint\";\nimport { PrismaticJoint } from \"../dynamics/joint/PrismaticJoint\";\nimport { PulleyJoint } from \"../dynamics/joint/PulleyJoint\";\nimport { RevoluteJoint } from \"../dynamics/joint/RevoluteJoint\";\nimport { RopeJoint } from \"../dynamics/joint/RopeJoint\";\nimport { WeldJoint } from \"../dynamics/joint/WeldJoint\";\nimport { WheelJoint } from \"../dynamics/joint/WheelJoint\";\n\nlet SID = 0;\n\nexport function Serializer(opts?) {\n  opts = opts || {};\n\n  const rootClass = opts.rootClass || World;\n\n  const preSerialize = opts.preSerialize || function(obj) { return obj; };\n  const postSerialize = opts.postSerialize || function(data, obj) { return data; };\n\n  const preDeserialize = opts.preDeserialize || function(data) { return data; };\n  const postDeserialize = opts.postDeserialize || function(obj, data) { return obj; };\n\n  // This is used to create ref objects during serialize\n  const refTypes = {\n    World,\n    Body,\n    Joint,\n    Fixture,\n    Shape,\n  };\n\n  // This is used by restore to deserialize objects and refs\n  const restoreTypes = {\n    Vec2,\n    Vec3,\n    ...refTypes\n  };\n\n  const CLASS_BY_TYPE_PROP = {\n    [Body.STATIC]: Body,\n    [Body.DYNAMIC]: Body,\n    [Body.KINEMATIC]: Body,\n    [ChainShape.TYPE]: ChainShape,\n    [BoxShape.TYPE]: BoxShape,\n    [EdgeShape.TYPE]: EdgeShape,\n    [PolygonShape.TYPE]: PolygonShape,\n    [CircleShape.TYPE]: CircleShape,\n    [DistanceJoint.TYPE]: DistanceJoint,\n    [FrictionJoint.TYPE]: FrictionJoint,\n    [GearJoint.TYPE]: GearJoint,\n    [MotorJoint.TYPE]: MotorJoint,\n    [MouseJoint.TYPE]: MouseJoint,\n    [PrismaticJoint.TYPE]: PrismaticJoint,\n    [PulleyJoint.TYPE]: PulleyJoint,\n    [RevoluteJoint.TYPE]: RevoluteJoint,\n    [RopeJoint.TYPE]: RopeJoint,\n    [WeldJoint.TYPE]: WeldJoint,\n    [WheelJoint.TYPE]: WheelJoint,\n  }\n\n  this.toJson = function(root) {\n    const json = [];\n\n    const queue = [root];\n    const refMap = {};\n\n    function storeRef(value, typeName) {\n      value.__sid = value.__sid || ++SID;\n      if (!refMap[value.__sid]) {\n        queue.push(value);\n        const index = json.length + queue.length;\n        const ref = {\n          refIndex: index,\n          refType: typeName\n        };\n        refMap[value.__sid] = ref;\n      }\n      return refMap[value.__sid];\n    }\n\n    function serialize(obj) {\n      obj = preSerialize(obj);\n      let data = obj._serialize();\n      data = postSerialize(data, obj);\n      return data;\n    }\n\n    function toJson(value, top?) {\n      if (typeof value !== 'object' || value === null) {\n        return value;\n      }\n      if (typeof value._serialize === 'function') {\n        if (value !== top) {\n          // tslint:disable-next-line:no-for-in\n          for (const typeName in refTypes) {\n            if (value instanceof refTypes[typeName]) {\n              return storeRef(value, typeName);\n            }\n          }\n        }\n        value = serialize(value);\n      }\n      if (Array.isArray(value)) {\n        const newValue = [];\n        for (let key = 0; key < value.length; key++) {\n          newValue[key] = toJson(value[key]);\n        }\n        value = newValue;\n\n      } else {\n        const newValue = {};\n        // tslint:disable-next-line:no-for-in\n        for (const key in value) {\n          if (value.hasOwnProperty(key)) {\n            newValue[key] = toJson(value[key]);\n          }\n        }\n        value = newValue;\n      }\n      return value;\n    }\n\n    while (queue.length) {\n      const obj = queue.shift();\n      const str = toJson(obj, obj);\n      json.push(str);\n    }\n\n    return json;\n  };\n\n  this.fromJson = function(json: object) {\n    const refMap = {};\n\n    function findDeserilizer(data, cls) {\n      if (!cls || !cls._deserialize) {\n        cls = CLASS_BY_TYPE_PROP[data.type]\n      }\n      return cls && cls._deserialize;\n    }\n\n    /**\n     * Deserialize a data object.\n     */\n    function deserialize(cls, data, ctx) {\n      const deserializer = findDeserilizer(data, cls);\n      if (!deserializer) {\n        return;\n      }\n      data = preDeserialize(data);\n      let obj = deserializer(data, ctx, restoreRef);\n      obj = postDeserialize(obj, data);\n      return obj;\n    }\n\n    /**\n     * Restore a ref object or deserialize a data object.\n     *\n     * This is passed as callback to class deserializers.\n     */\n    function restoreRef(cls, ref, ctx) {\n      if (!ref.refIndex) {\n        return cls && cls._deserialize && deserialize(cls, ref, ctx);\n      }\n      cls = restoreTypes[ref.refType] || cls;\n      const index = ref.refIndex;\n      if (!refMap[index]) {\n        const data = json[index];\n        const obj = deserialize(cls, data, ctx);\n        refMap[index] = obj;\n      }\n      return refMap[index];\n    }\n\n    const root = rootClass._deserialize(json[0], null, restoreRef);\n\n    return root;\n  };\n}\n\nconst serializer = new Serializer();\n\nSerializer.toJson = serializer.toJson;\nSerializer.fromJson = serializer.fromJson;\n", "import type { AABBValue } from \"../collision/AABB\";\nimport type { World } from \"../dynamics/World\";\nimport type { Joint } from \"../dynamics/Joint\";\nimport type { Fixture } from \"../dynamics/Fixture\";\nimport type { Body } from \"../dynamics/Body\";\n\nexport interface Style {\n  stroke?: string;\n  fill?: string;\n}\n\ntype KEY = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' |\n  '8' | '9' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' |\n  'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' |\n  'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' |\n  'Z' | 'right' | 'left' | 'up' | 'down' | 'fire';\n\nexport type ActiveKeys = { [key in KEY]?: boolean };\n\ntype TestbedMountOptions = {};\n\nexport abstract class Testbed {\n  static mount(options?: TestbedMountOptions): Testbed {\n    throw new Error('Not implemented');\n  }\n\n  /** World viewbox width. */\n  width: number = 80;\n\n  /** World viewbox height. */\n  height: number = 60;\n\n  /** World viewbox center vertical offset. */\n  x: number = 0;\n\n  /** World viewbox center horizontal offset. */\n  y: number = -10;\n\n  scaleY: number = -1;\n\n  /** World simulation step frequency */\n  hz: number = 60;\n\n  /** World simulation speed, default is 1 */\n  speed: number = 1;\n\n  ratio: number = 16;\n  background: string = '#222222';\n\n  mouseForce?: number;\n  activeKeys: ActiveKeys = {};\n\n  /** callback, to be implemented by user */\n  step = (dt: number, t: number): void => {\n    return;\n  };\n\n  /** callback, to be implemented by user */\n  keydown = (keyCode: number, label: string): void => {\n    return;\n  };\n\n  /** callback, to be implemented by user */\n  keyup = (keyCode: number, label: string): void => {\n    return;\n  };\n\n  private statusText = '';\n  private statusMap: Record<string, any> = {};\n\n  status(name: string, value: any): void;\n  status(value: object | string): void;\n  status(a: any, b?: any) {\n    if (typeof b !== 'undefined') {\n      const key = a;\n      const value = b;\n      if (typeof value !== 'function' && typeof value !== 'object') {\n        this.statusMap[key] = value;\n      }\n    } else if (a && typeof a === 'object') {\n      // tslint:disable-next-line:no-for-in\n      for (const key in a) {\n        const value = a[key];\n        if (typeof value !== 'function' && typeof value !== 'object') {\n          this.statusMap[key] = value;\n        }\n      }\n    } else if (typeof a === 'string') {\n      this.statusText = a;\n    }\n\n    var newline = '\\n';\n    var text = this.statusText || '';\n    for (var key in this.statusMap) {\n      var value = this.statusMap[key];\n      if (typeof value === 'function') continue;\n      text += (text && newline) + key + ': ' + value;\n    }\n\n    this._status(text);\n  }\n\n  info(text: string): void {\n    this._info(text);\n  }\n\n  color(r: number, g: number, b: number): string {\n    r = r * 256 | 0;\n    g = g * 256 | 0;\n    b = b * 256 | 0;\n    return 'rgb(' + r + ', ' + g + ', ' + b + ')';\n  }\n\n  abstract drawPoint(p: {x: number, y: number}, r: any, color: string): void;\n  abstract drawCircle(p: {x: number, y: number}, r: number, color: string): void;\n  abstract drawEdge(a: {x: number, y: number}, b: {x: number, y: number}, color: string): void;\n  abstract drawSegment(a: {x: number, y: number}, b: {x: number, y: number}, color: string): void;\n  abstract drawPolygon(points: Array<{x: number, y: number}>, color: string): void;\n  abstract drawAABB(aabb: AABBValue, color: string): void;\n\n  abstract start(world: World): void;\n\n  /** @internal */\n  abstract _pause(): void;\n\n  /** @internal */\n  abstract _resume(): void;\n\n  /** @internal */\n  abstract _status(string: string): void;\n\n  /** @internal */  \n  abstract _info(text: string): void;\n\n  abstract findOne(query: string): (Body | Joint | Fixture | null);\n  abstract findAll(query: string): (Body | Joint | Fixture)[];\n}\n\ntype TestbedFactoryOptions = string | {};\n\n/** @deprecated */\ntype TestbedCallback = (testbed: Testbed) => (World | undefined);\n\n/** @deprecated */\nexport function testbed(callback: TestbedCallback): void;\n/** @deprecated */\nexport function testbed(options: TestbedFactoryOptions, callback: TestbedCallback): void;\n/** @internal */\nexport function testbed(a?: any, b?: any) {\n  let callback: TestbedCallback | undefined;\n  let options;\n  if (typeof a === 'function') {\n    callback = a;\n    options = b;\n  } else if (typeof b === 'function') {\n    callback = b;\n    options = a;\n  } else {\n    options = a ?? b;\n  }\n  const testbed = Testbed.mount(options);\n  if (callback) {\n    // this is for backwards compatibility\n    const world = callback(testbed) || (testbed as any).world;\n    testbed.start(world);\n  } else {\n    return testbed;\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\nimport * as matrix from '../../common/Matrix';\nimport { Transform } from '../../common/Transform';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\n\n/** @internal */ function CircleCircleContact(manifold: Manifold, xfA: Transform, fixtureA: Fixture, indexA: number, xfB: Transform, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == CircleShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollideCircles(manifold, fixtureA.getShape() as CircleShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\n/** @internal */ const pA = matrix.vec2(0, 0);\n/** @internal */ const pB = matrix.vec2(0, 0);\n\nexport const CollideCircles = function (manifold: Manifold, circleA: CircleShape, xfA: Transform, circleB: CircleShape, xfB: Transform): void {\n  manifold.pointCount = 0;\n\n  matrix.transformVec2(pA, xfA, circleA.m_p);\n  matrix.transformVec2(pB, xfB, circleB.m_p);\n\n  const distSqr = matrix.distSqrVec2(pB, pA);\n  const rA = circleA.m_radius;\n  const rB = circleB.m_radius;\n  const radius = rA + rB;\n  if (distSqr > radius * radius) {\n    return;\n  }\n\n  manifold.type = ManifoldType.e_circles;\n  matrix.copyVec2(manifold.localPoint, circleA.m_p);\n  matrix.zeroVec2(manifold.localNormal)\n  manifold.pointCount = 1;\n  matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex)\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TransformValue } from '../../common/Transform';\nimport * as matrix from '../../common/Matrix';\nimport { Contact } from '../../dynamics/Contact';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { CircleShape } from './CircleShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\nContact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\n\n/** @internal */ function EdgeCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == EdgeShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const shapeA = fixtureA.getShape() as EdgeShape;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\nfunction ChainCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == ChainShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n\n  const chain = fixtureA.getShape() as ChainShape;\n  const edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n\n  const shapeA = edge;\n  const shapeB = fixtureB.getShape() as CircleShape;\n\n  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);\n}\n\n/** @internal */ const e = matrix.vec2(0, 0);\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const e1 = matrix.vec2(0, 0);\n/** @internal */ const e2 = matrix.vec2(0, 0);\n/** @internal */ const Q = matrix.vec2(0, 0);\n/** @internal */ const P = matrix.vec2(0, 0);\n/** @internal */ const n = matrix.vec2(0, 0);\n\n// Compute contact points for edge versus circle.\n// This accounts for edge connectivity.\nexport const CollideEdgeCircle = function (manifold: Manifold, edgeA: EdgeShape, xfA: TransformValue, circleB: CircleShape, xfB: TransformValue): void {\n  manifold.pointCount = 0;\n\n  // Compute circle in frame of edge\n  matrix.retransformVec2(Q, xfB, xfA, circleB.m_p);\n\n  const A = edgeA.m_vertex1;\n  const B = edgeA.m_vertex2;\n  matrix.diffVec2(e, B, A);\n\n  // Barycentric coordinates\n  const u = matrix.dotVec2(e, B) - matrix.dotVec2(e, Q);\n  const v = matrix.dotVec2(e, Q) - matrix.dotVec2(e, A);\n\n  const radius = edgeA.m_radius + circleB.m_radius;\n\n  // Region A\n  if (v <= 0.0) {\n    matrix.copyVec2(P, A);\n    const dd = matrix.distSqrVec2(Q, A);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to A?\n    if (edgeA.m_hasVertex0) {\n      const A1 = edgeA.m_vertex0;\n      const B1 = A;\n      matrix.diffVec2(e1, B1, A1);\n      const u1 = matrix.dotVec2(e1, B1) - matrix.dotVec2(e1, Q);\n\n      // Is the circle in Region AB of the previous edge?\n      if (u1 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    matrix.zeroVec2(manifold.localNormal)\n    matrix.copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n\n  // Region B\n  if (u <= 0.0) {\n    matrix.copyVec2(P, B);\n    const dd = matrix.distSqrVec2(Q, P);\n    if (dd > radius * radius) {\n      return;\n    }\n\n    // Is there an edge connected to B?\n    if (edgeA.m_hasVertex3) {\n      const B2 = edgeA.m_vertex3;\n      const A2 = B;\n      matrix.diffVec2(e2, B2, A2);\n      const v2 = matrix.dotVec2(e2, Q) - matrix.dotVec2(e2, A2);\n\n      // Is the circle in Region AB of the next edge?\n      if (v2 > 0.0) {\n        return;\n      }\n    }\n\n    manifold.type = ManifoldType.e_circles;\n    matrix.zeroVec2(manifold.localNormal)\n    matrix.copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(1, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n\n    return;\n  }\n\n  // Region AB\n  const den = matrix.lengthSqrVec2(e);\n  _ASSERT && console.assert(den > 0.0);\n  matrix.combineVec2(P, u / den, A, v / den, B);\n  const dd = matrix.distSqrVec2(Q, P);\n  if (dd > radius * radius) {\n    return;\n  }\n\n  matrix.crossNumVec2(n, 1, e);\n  if (matrix.dotVec2(n, Q) - matrix.dotVec2(n, A) < 0.0) {\n    matrix.negVec2(n);\n  }\n  matrix.normalizeVec2(n);\n\n  manifold.type = ManifoldType.e_faceA;\n  matrix.copyVec2(manifold.localNormal, n);\n  matrix.copyVec2(manifold.localPoint, A);\n  manifold.pointCount = 1;\n  matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n  // manifold.points[0].id.key = 0;\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_face, 0, ContactFeatureType.e_vertex);\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport { TransformValue } from '../../common/Transform';\nimport * as matrix from '../../common/Matrix';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { Contact } from '../../dynamics/Contact';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n/** @internal */ const incidentEdge = [ new ClipVertex(), new ClipVertex() ];\n/** @internal */ const clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\n/** @internal */ const clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\n/** @internal */ const clipSegmentToLineNormal = matrix.vec2(0, 0);\n/** @internal */ const v1 = matrix.vec2(0, 0);\n/** @internal */ const n = matrix.vec2(0, 0);\n/** @internal */ const xf = matrix.transform(0, 0, 0);\n/** @internal */ const temp = matrix.vec2(0, 0);\n/** @internal */ const v11 = matrix.vec2(0, 0);\n/** @internal */ const v12 = matrix.vec2(0, 0);\n/** @internal */ const localTangent = matrix.vec2(0, 0);\n/** @internal */ const localNormal = matrix.vec2(0, 0);\n/** @internal */ const planePoint = matrix.vec2(0, 0);\n/** @internal */ const tangent = matrix.vec2(0, 0);\n/** @internal */ const normal = matrix.vec2(0, 0);\n/** @internal */ const normal1 = matrix.vec2(0, 0);\n\n\nContact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\n\n/** @internal */ function PolygonContact(\n  manifold: Manifold,\n  xfA: TransformValue,\n  fixtureA: Fixture,\n  indexA: number,\n  xfB: TransformValue,\n  fixtureB: Fixture,\n  indexB: number,\n): void {\n  _ASSERT && console.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == PolygonShape.TYPE);\n  CollidePolygons(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as PolygonShape, xfB);\n}\n\n/** @internal */ interface MaxSeparation {\n  maxSeparation: number;\n  bestIndex: number;\n}\n\n/**\n * Find the max separation between poly1 and poly2 using edge normals from\n * poly1.\n */\n/** @internal */ function findMaxSeparation(\n  poly1: PolygonShape,\n  xf1: TransformValue,\n  poly2: PolygonShape,\n  xf2: TransformValue,\n  output: MaxSeparation,\n): void {\n  const count1 = poly1.m_count;\n  const count2 = poly2.m_count;\n  const n1s = poly1.m_normals;\n  const v1s = poly1.m_vertices;\n  const v2s = poly2.m_vertices;\n\n  matrix.invTransformTransform(xf, xf2, xf1);\n\n  let bestIndex = 0;\n  let maxSeparation = -Infinity;\n  for (let i = 0; i < count1; ++i) {\n    // Get poly1 normal in frame2.\n    matrix.rotVec2(n, xf.q, n1s[i]);\n    matrix.transformVec2(v1, xf, v1s[i]);\n\n    // Find deepest point for normal i.\n    let si = Infinity;\n    for (let j = 0; j < count2; ++j) {\n      const sij = matrix.dotVec2(n, v2s[j]) - matrix.dotVec2(n, v1);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n\n    if (si > maxSeparation) {\n      maxSeparation = si;\n      bestIndex = i;\n    }\n  }\n\n  // used to keep last FindMaxSeparation call values\n  output.maxSeparation = maxSeparation;\n  output.bestIndex = bestIndex;\n}\n\n/** @internal */ function findIncidentEdge(\n  clipVertex: ClipVertex[],\n  poly1: PolygonShape,\n  xf1: TransformValue,\n  edge1: number,\n  poly2: PolygonShape,\n  xf2: TransformValue,\n): void {\n  const normals1 = poly1.m_normals;\n\n  const count2 = poly2.m_count;\n  const vertices2 = poly2.m_vertices;\n  const normals2 = poly2.m_normals;\n\n  _ASSERT && console.assert(0 <= edge1 && edge1 < poly1.m_count);\n\n  // Get the normal of the reference edge in poly2's frame.\n  matrix.rerotVec2(normal1, xf2.q, xf1.q, normals1[edge1]);\n\n  // Find the incident edge on poly2.\n  let index = 0;\n  let minDot = Infinity;\n  for (let i = 0; i < count2; ++i) {\n    const dot = matrix.dotVec2(normal1, normals2[i]);\n    if (dot < minDot) {\n      minDot = dot;\n      index = i;\n    }\n  }\n\n  // Build the clip vertices for the incident edge.\n  const i1 = index;\n  const i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n\n  matrix.transformVec2(clipVertex[0].v, xf2, vertices2[i1]);\n  clipVertex[0].id.setFeatures(edge1, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n\n  matrix.transformVec2(clipVertex[1].v, xf2, vertices2[i2]);\n  clipVertex[1].id.setFeatures(edge1, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n}\n\n/** @internal */ const maxSeparation = {\n  maxSeparation: 0,\n  bestIndex: 0,\n};\n\n/**\n *\n * Find edge normal of max separation on A - return if separating axis is found<br>\n * Find edge normal of max separation on B - return if separation axis is found<br>\n * Choose reference edge as min(minA, minB)<br>\n * Find incident edge<br>\n * Clip\n *\n * The normal points from 1 to 2\n */\nexport const CollidePolygons = function (\n  manifold: Manifold,\n  polyA: PolygonShape,\n  xfA: TransformValue,\n  polyB: PolygonShape,\n  xfB: TransformValue,\n): void {\n  manifold.pointCount = 0;\n  const totalRadius = polyA.m_radius + polyB.m_radius;\n\n  findMaxSeparation(polyA, xfA, polyB, xfB, maxSeparation);\n  const edgeA = maxSeparation.bestIndex;\n  const separationA = maxSeparation.maxSeparation;\n  if (separationA > totalRadius)\n    return;\n\n  findMaxSeparation(polyB, xfB, polyA, xfA, maxSeparation);\n  const edgeB = maxSeparation.bestIndex;\n  const separationB = maxSeparation.maxSeparation;\n  if (separationB > totalRadius)\n    return;\n\n  let poly1: PolygonShape; // reference polygon\n  let poly2: PolygonShape; // incident polygon\n  let xf1: TransformValue;\n  let xf2: TransformValue;\n  let edge1: number; // reference edge\n  let flip: boolean;\n  const k_tol = 0.1 * Settings.linearSlop;\n\n  if (separationB > separationA + k_tol) {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB;\n    xf2 = xfA;\n    edge1 = edgeB;\n    manifold.type = ManifoldType.e_faceB;\n    flip = true;\n  } else {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA;\n    xf2 = xfB;\n    edge1 = edgeA;\n    manifold.type = ManifoldType.e_faceA;\n    flip = false;\n  }\n\n  incidentEdge[0].recycle(), incidentEdge[1].recycle();\n  findIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);\n\n  const count1 = poly1.m_count;\n  const vertices1 = poly1.m_vertices;\n\n  const iv1 = edge1;\n  const iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;\n\n  matrix.copyVec2(v11, vertices1[iv1]);\n  matrix.copyVec2(v12, vertices1[iv2]);\n\n  matrix.diffVec2(localTangent, v12, v11);\n  matrix.normalizeVec2(localTangent);\n\n  matrix.crossVec2Num(localNormal, localTangent, 1.0);\n  matrix.combineVec2(planePoint, 0.5, v11, 0.5, v12);\n\n  matrix.rotVec2(tangent, xf1.q, localTangent);\n  matrix.crossVec2Num(normal, tangent, 1.0);\n\n  matrix.transformVec2(v11, xf1, v11);\n  matrix.transformVec2(v12, xf1, v12);\n\n  // Face offset.\n  const frontOffset = matrix.dotVec2(normal, v11);\n\n  // Side offsets, extended by polytope skin thickness.\n  const sideOffset1 = -matrix.dotVec2(tangent, v11) + totalRadius;\n  const sideOffset2 = matrix.dotVec2(tangent, v12) + totalRadius;\n\n  // Clip incident edge against extruded edge1 side edges.\n  clipPoints1[0].recycle(), clipPoints1[1].recycle();\n  clipPoints2[0].recycle(), clipPoints2[1].recycle();\n\n  // Clip to box side 1\n  matrix.setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);\n  const np1 = clipSegmentToLine(clipPoints1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);\n\n  if (np1 < 2) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  matrix.setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);\n  const np2 = clipSegmentToLine(clipPoints2, clipPoints1, clipSegmentToLineNormal, sideOffset2, iv2);\n\n  if (np2 < 2) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  matrix.copyVec2(manifold.localNormal, localNormal);\n  matrix.copyVec2(manifold.localPoint, planePoint);\n\n  let pointCount = 0;\n  for (let i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {\n    const separation = matrix.dotVec2(normal, clipPoints2[i].v) - frontOffset;\n\n    if (separation <= totalRadius) {\n      const cp = manifold.points[pointCount];\n      matrix.invTransformVec2(cp.localPoint, xf2, clipPoints2[i].v);\n      cp.id.set(clipPoints2[i].id);\n      if (flip) {\n        // Swap features\n        cp.id.swapFeatures();\n      }\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { EPSILON } from '../../common/Math';\nimport { TransformValue } from '../../common/Transform';\nimport { Contact } from '../../dynamics/Contact';\nimport { CircleShape } from './CircleShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Manifold, ContactFeatureType, ManifoldType } from \"../Manifold\";\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n\n\nContact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\n\n/** @internal */ function PolygonCircleContact(manifold: Manifold, xfA: TransformValue, fixtureA: Fixture, indexA: number, xfB: TransformValue, fixtureB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fixtureA.getType() == PolygonShape.TYPE);\n  _ASSERT && console.assert(fixtureB.getType() == CircleShape.TYPE);\n  CollidePolygonCircle(manifold, fixtureA.getShape() as PolygonShape, xfA, fixtureB.getShape() as CircleShape, xfB);\n}\n\n/** @internal */ const cLocal = matrix.vec2(0, 0);\n/** @internal */ const faceCenter = matrix.vec2(0, 0);\n\nexport const CollidePolygonCircle = function (manifold: Manifold, polygonA: PolygonShape, xfA: TransformValue, circleB: CircleShape, xfB: TransformValue): void {\n  manifold.pointCount = 0;\n\n  // Compute circle position in the frame of the polygon.\n  matrix.retransformVec2(cLocal, xfB, xfA, circleB.m_p);\n\n  // Find the min separating edge.\n  let normalIndex = 0;\n  let separation = -Infinity;\n  const radius = polygonA.m_radius + circleB.m_radius;\n  const vertexCount = polygonA.m_count;\n  const vertices = polygonA.m_vertices;\n  const normals = polygonA.m_normals;\n\n  for (let i = 0; i < vertexCount; ++i) {\n    const s = matrix.dotVec2(normals[i], cLocal) - matrix.dotVec2(normals[i], vertices[i]);\n\n    if (s > radius) {\n      // Early out.\n      return;\n    }\n\n    if (s > separation) {\n      separation = s;\n      normalIndex = i;\n    }\n  }\n\n  // Vertices that subtend the incident face.\n  const vertIndex1 = normalIndex;\n  const vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  const v1 = vertices[vertIndex1];\n  const v2 = vertices[vertIndex2];\n\n  // If the center is inside the polygon ...\n  if (separation < EPSILON) {\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.copyVec2(manifold.localNormal, normals[normalIndex]);\n    matrix.combineVec2(manifold.localPoint, 0.5, v1, 0.5, v2);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n\n  // Compute barycentric coordinates\n  // u1 = (cLocal - v1) dot (v2 - v1))\n  const u1 = matrix.dotVec2(cLocal, v2) - matrix.dotVec2(cLocal, v1) - matrix.dotVec2(v1, v2) + matrix.dotVec2(v1, v1);\n  // u2 = (cLocal - v2) dot (v1 - v2)\n  const u2 = matrix.dotVec2(cLocal, v1) - matrix.dotVec2(cLocal, v2) - matrix.dotVec2(v2, v1) + matrix.dotVec2(v2, v2);\n  if (u1 <= 0.0) {\n    if (matrix.distSqrVec2(cLocal, v1) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.diffVec2(manifold.localNormal, cLocal, v1);\n    matrix.normalizeVec2(manifold.localNormal);\n    matrix.copyVec2(manifold.localPoint, v1);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else if (u2 <= 0.0) {\n    if (matrix.distSqrVec2(cLocal, v2) > radius * radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.diffVec2(manifold.localNormal, cLocal, v2);\n    matrix.normalizeVec2(manifold.localNormal);\n    matrix.copyVec2(manifold.localPoint, v2);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else {\n    matrix.combineVec2(faceCenter, 0.5, v1, 0.5, v2);\n    const separation = matrix.dotVec2(cLocal, normals[vertIndex1]) - matrix.dotVec2(faceCenter, normals[vertIndex1]);\n    if (separation > radius) {\n      return;\n    }\n\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    matrix.copyVec2(manifold.localNormal, normals[vertIndex1]);\n    matrix.copyVec2(manifold.localPoint, faceCenter);\n    matrix.copyVec2(manifold.points[0].localPoint, circleB.m_p);\n\n    // manifold.points[0].id.key = 0;\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  }\n}\n", "/*\n * Planck.js\n * The MIT License\n * Copyright (c) 2021 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport * as matrix from '../../common/Matrix';\nimport { TransformValue } from '../../common/Transform';\nimport { Vec2, Vec2Value } from '../../common/Vec2';\nimport { SettingsInternal as Settings } from '../../Settings';\nimport { Contact } from '../../dynamics/Contact';\nimport { Manifold, clipSegmentToLine, ClipVertex, ContactFeatureType, ManifoldType } from '../Manifold';\nimport { EdgeShape } from './EdgeShape';\nimport { ChainShape } from './ChainShape';\nimport { PolygonShape } from './PolygonShape';\nimport { Fixture } from \"../../dynamics/Fixture\";\n\n\n/** @internal */ const _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;\n/** @internal */ const math_min = Math.min;\n\nContact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\nContact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\n\n/** @internal */ function EdgePolygonContact(manifold: Manifold, xfA: TransformValue, fA: Fixture, indexA: number, xfB: TransformValue, fB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fA.getType() == EdgeShape.TYPE);\n  _ASSERT && console.assert(fB.getType() == PolygonShape.TYPE);\n\n  CollideEdgePolygon(manifold, fA.getShape() as EdgeShape, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\n// reused\n/** @internal */ const edge_reuse = new EdgeShape();\n\n/** @internal */ function ChainPolygonContact(manifold: Manifold, xfA: TransformValue, fA: Fixture, indexA: number, xfB: TransformValue, fB: Fixture, indexB: number): void {\n  _ASSERT && console.assert(fA.getType() == ChainShape.TYPE);\n  _ASSERT && console.assert(fB.getType() == PolygonShape.TYPE);\n\n  const chain = fA.getShape() as ChainShape;\n  chain.getChildEdge(edge_reuse, indexA);\n\n  CollideEdgePolygon(manifold, edge_reuse, xfA, fB.getShape() as PolygonShape, xfB);\n}\n\n/** @internal */ enum EPAxisType {\n  e_unknown = -1,\n  e_edgeA = 1,\n  e_edgeB = 2,\n}\n\n// unused?\n/** @internal */ enum VertexType {\n e_isolated = 0,\n e_concave = 1,\n e_convex = 2,\n}\n\n/**\n * This structure is used to keep track of the best separating axis.\n */\n/** @internal */ class EPAxis {\n  type: EPAxisType;\n  index: number;\n  separation: number;\n}\n\n/**\n * This holds polygon B expressed in frame A.\n */\n/** @internal */ class TempPolygon {\n  vertices: Vec2Value[] = []; // [Settings.maxPolygonVertices]\n  normals: Vec2Value[] = []; // [Settings.maxPolygonVertices];\n  count: number = 0;\n  constructor() {\n    for (let i = 0; i < Settings.maxPolygonVertices; i++) {\n      this.vertices.push(matrix.vec2(0, 0));\n      this.normals.push(matrix.vec2(0, 0));\n    }\n  }\n}\n\n/**\n * Reference face used for clipping\n */\n/** @internal */ class ReferenceFace {\n  i1: number;\n  i2: number;\n  readonly v1 = matrix.vec2(0 ,0);\n  readonly v2 = matrix.vec2(0 ,0);\n  readonly normal = matrix.vec2(0 ,0);\n  readonly sideNormal1 = matrix.vec2(0 ,0);\n  sideOffset1: number;\n  readonly sideNormal2 = matrix.vec2(0 ,0);\n  sideOffset2: number;\n  recycle() {\n    matrix.zeroVec2(this.v1)\n    matrix.zeroVec2(this.v2)\n    matrix.zeroVec2(this.normal)\n    matrix.zeroVec2(this.sideNormal1)\n    matrix.zeroVec2(this.sideNormal2)\n  }\n}\n\n// reused\n/** @internal */ const clipPoints1 = [ new ClipVertex(), new ClipVertex() ];\n/** @internal */ const clipPoints2 = [ new ClipVertex(), new ClipVertex() ];\n/** @internal */ const ie = [ new ClipVertex(), new ClipVertex() ];\n/** @internal */ const edgeAxis = new EPAxis();\n/** @internal */ const polygonAxis = new EPAxis();\n/** @internal */ const polygonBA = new TempPolygon();\n/** @internal */ const rf = new ReferenceFace();\n/** @internal */ const centroidB = matrix.vec2(0, 0);\n/** @internal */ const edge0 = matrix.vec2(0, 0);\n/** @internal */ const edge1 = matrix.vec2(0, 0);\n/** @internal */ const edge2 = matrix.vec2(0, 0);\n/** @internal */ const xf = matrix.transform(0, 0, 0);\n/** @internal */ const normal = matrix.vec2(0, 0);\n/** @internal */ const normal0 = matrix.vec2(0, 0);\n/** @internal */ const normal1 = matrix.vec2(0, 0);\n/** @internal */ const normal2 = matrix.vec2(0, 0);\n/** @internal */ const lowerLimit = matrix.vec2(0, 0);\n/** @internal */ const upperLimit = matrix.vec2(0, 0);\n/** @internal */ const perp = matrix.vec2(0, 0);\n/** @internal */ const n = matrix.vec2(0, 0);\n\n/**\n * This function collides and edge and a polygon, taking into account edge\n * adjacency.\n */\nexport const CollideEdgePolygon = function (manifold: Manifold, edgeA: EdgeShape, xfA: TransformValue, polygonB: PolygonShape, xfB: TransformValue): void {\n  // Algorithm:\n  // 1. Classify v1 and v2\n  // 2. Classify polygon centroid as front or back\n  // 3. Flip normal if necessary\n  // 4. Initialize normal range to [-pi, pi] about face normal\n  // 5. Adjust normal range according to adjacent edges\n  // 6. Visit each separating axes, only accept axes within the range\n  // 7. Return if _any_ axis indicates separation\n  // 8. Clip\n\n  // let m_type1: VertexType;\n  // let m_type2: VertexType;\n\n  matrix.invTransformTransform(xf, xfA, xfB);\n  matrix.transformVec2(centroidB, xf, polygonB.m_centroid);\n\n  const v0 = edgeA.m_vertex0;\n  const v1 = edgeA.m_vertex1;\n  const v2 = edgeA.m_vertex2;\n  const v3 = edgeA.m_vertex3;\n\n  const hasVertex0 = edgeA.m_hasVertex0;\n  const hasVertex3 = edgeA.m_hasVertex3;\n\n  matrix.diffVec2(edge1, v2, v1);\n  matrix.normalizeVec2(edge1);\n  matrix.setVec2(normal1, edge1.y, -edge1.x)\n  const offset1 = matrix.dotVec2(normal1, centroidB) - matrix.dotVec2(normal1, v1);\n  let offset0 = 0.0;\n  let offset2 = 0.0;\n  let convex1 = false;\n  let convex2 = false;\n\n  matrix.zeroVec2(normal0);\n  matrix.zeroVec2(normal2);\n\n  // Is there a preceding edge?\n  if (hasVertex0) {\n    matrix.diffVec2(edge0, v1, v0);\n    matrix.normalizeVec2(edge0);\n    matrix.setVec2(normal0, edge0.y, -edge0.x);\n    convex1 = matrix.crossVec2Vec2(edge0, edge1) >= 0.0;\n    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n  }\n\n  // Is there a following edge?\n  if (hasVertex3) {\n    matrix.diffVec2(edge2, v3, v2);\n    matrix.normalizeVec2(edge2);\n    matrix.setVec2(normal2, edge2.y, -edge2.x);\n    convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0.0;\n    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);\n  }\n\n  let front: boolean;\n  matrix.zeroVec2(normal);\n  matrix.zeroVec2(lowerLimit);\n  matrix.zeroVec2(upperLimit);\n\n  // Determine front or back collision. Determine collision normal limits.\n  if (hasVertex0 && hasVertex3) {\n    if (convex1 && convex2) {\n      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex1) {\n      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex2) {\n      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex0) {\n    if (convex1) {\n      front = offset0 >= 0.0 || offset1 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal0);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      }\n    } else {\n      front = offset0 >= 0.0 && offset1 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.copyVec2(lowerLimit, normal1);\n        matrix.setMulVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex3) {\n    if (convex2) {\n      front = offset1 >= 0.0 || offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal2);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      }\n    } else {\n      front = offset1 >= 0.0 && offset2 >= 0.0;\n      if (front) {\n        matrix.copyVec2(normal, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal1);\n        matrix.copyVec2(upperLimit, normal1);\n      } else {\n        matrix.setMulVec2(normal, -1, normal1);\n        matrix.setMulVec2(lowerLimit, -1, normal2);\n        matrix.copyVec2(upperLimit, normal1);\n      }\n    }\n  } else {\n    front = offset1 >= 0.0;\n    if (front) {\n      matrix.copyVec2(normal, normal1);\n      matrix.setMulVec2(lowerLimit, -1, normal1);\n      matrix.setMulVec2(upperLimit, -1, normal1);\n    } else {\n      matrix.setMulVec2(normal, -1, normal1);\n      matrix.copyVec2(lowerLimit, normal1);\n      matrix.copyVec2(upperLimit, normal1);\n    }\n  }\n\n  // Get polygonB in frameA\n  polygonBA.count = polygonB.m_count;\n  for (let i = 0; i < polygonB.m_count; ++i) {\n    matrix.transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);\n    matrix.rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);\n  }\n\n  const radius = polygonB.m_radius + edgeA.m_radius;\n\n  manifold.pointCount = 0;\n\n  { // ComputeEdgeSeparation\n    edgeAxis.type = EPAxisType.e_edgeA;\n    edgeAxis.index = front ? 0 : 1;\n    edgeAxis.separation = Infinity;\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      const v = polygonBA.vertices[i];\n      const s = matrix.dotVec2(normal, v) - matrix.dotVec2(normal, v1);\n      if (s < edgeAxis.separation) {\n        edgeAxis.separation = s;\n      }\n    }\n  }\n\n  // If no valid normal can be found than this edge should not collide.\n  // @ts-ignore todo: why we need this if here?\n  if (edgeAxis.type == EPAxisType.e_unknown) {\n    return;\n  }\n\n  if (edgeAxis.separation > radius) {\n    return;\n  }\n\n  { // ComputePolygonSeparation\n    polygonAxis.type = EPAxisType.e_unknown;\n    polygonAxis.index = -1;\n    polygonAxis.separation = -Infinity;\n\n    matrix.setVec2(perp, -normal.y, normal.x);\n\n    for (let i = 0; i < polygonBA.count; ++i) {\n      matrix.setMulVec2(n, -1, polygonBA.normals[i]);\n\n      const s1 = matrix.dotVec2(n, polygonBA.vertices[i]) - matrix.dotVec2(n, v1);\n      const s2 = matrix.dotVec2(n, polygonBA.vertices[i]) - matrix.dotVec2(n, v2);\n      const s = math_min(s1, s2);\n\n      if (s > radius) {\n        // No collision\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n        break;\n      }\n\n      // Adjacency\n      if (matrix.dotVec2(n, perp) >= 0.0) {\n        if (matrix.dotVec2(n, normal) - matrix.dotVec2(upperLimit, normal) < -Settings.angularSlop) {\n          continue;\n        }\n      } else {\n        if (matrix.dotVec2(n, normal) - matrix.dotVec2(lowerLimit, normal) < -Settings.angularSlop) {\n          continue;\n        }\n      }\n\n      if (s > polygonAxis.separation) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s;\n      }\n    }\n  }\n\n  if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n    return;\n  }\n\n  // Use hysteresis for jitter reduction.\n  const k_relativeTol = 0.98;\n  const k_absoluteTol = 0.001;\n\n  let primaryAxis: EPAxis;\n  if (polygonAxis.type == EPAxisType.e_unknown) {\n    primaryAxis = edgeAxis;\n  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n    primaryAxis = polygonAxis;\n  } else {\n    primaryAxis = edgeAxis;\n  }\n\n  ie[0].recycle(), ie[1].recycle();\n\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.type = ManifoldType.e_faceA;\n\n    // Search for the polygon normal that is most anti-parallel to the edge\n    // normal.\n    let bestIndex = 0;\n    let bestValue = matrix.dotVec2(normal, polygonBA.normals[0]);\n    for (let i = 1; i < polygonBA.count; ++i) {\n      const value = matrix.dotVec2(normal, polygonBA.normals[i]);\n      if (value < bestValue) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n\n    const i1 = bestIndex;\n    const i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n\n    matrix.copyVec2(ie[0].v, polygonBA.vertices[i1]);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n\n    matrix.copyVec2(ie[1].v, polygonBA.vertices[i2]);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n\n    if (front) {\n      rf.i1 = 0;\n      rf.i2 = 1;\n      matrix.copyVec2(rf.v1, v1);\n      matrix.copyVec2(rf.v2, v2);\n      matrix.copyVec2(rf.normal, normal1);\n    } else {\n      rf.i1 = 1;\n      rf.i2 = 0;\n      matrix.copyVec2(rf.v1, v2);\n      matrix.copyVec2(rf.v2, v1);\n      matrix.setMulVec2(rf.normal, -1, normal1);\n    }\n  } else {\n    manifold.type = ManifoldType.e_faceB;\n\n    matrix.copyVec2(ie[0].v, v1);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n\n    matrix.copyVec2(ie[1].v, v2);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n\n    rf.i1 = primaryAxis.index;\n    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n    matrix.copyVec2(rf.v1, polygonBA.vertices[rf.i1]);\n    matrix.copyVec2(rf.v2, polygonBA.vertices[rf.i2]);\n    matrix.copyVec2(rf.normal, polygonBA.normals[rf.i1]);\n  }\n\n  matrix.setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);\n  matrix.setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);\n  rf.sideOffset1 = matrix.dotVec2(rf.sideNormal1, rf.v1);\n  rf.sideOffset2 = matrix.dotVec2(rf.sideNormal2, rf.v2);\n\n  // Clip incident edge against extruded edge1 side edges.\n  clipPoints1[0].recycle(), clipPoints1[1].recycle();\n  clipPoints2[0].recycle(), clipPoints2[1].recycle();\n\n  // Clip to box side 1\n  const np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n\n  if (np1 < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Clip to negative box side 1\n  const np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n\n  if (np2 < Settings.maxManifoldPoints) {\n    return;\n  }\n\n  // Now clipPoints2 contains the clipped points.\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    matrix.copyVec2(manifold.localNormal, rf.normal);\n    matrix.copyVec2(manifold.localPoint, rf.v1);\n  } else {\n    matrix.copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);\n    matrix.copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);\n  }\n\n  let pointCount = 0;\n  for (let i = 0; i < Settings.maxManifoldPoints; ++i) {\n    const separation = matrix.dotVec2(rf.normal, clipPoints2[i].v) - matrix.dotVec2(rf.normal, rf.v1);\n\n    if (separation <= radius) {\n      const cp = manifold.points[pointCount]; // ManifoldPoint\n\n      if (primaryAxis.type == EPAxisType.e_edgeA) {\n        matrix.invTransformVec2(cp.localPoint, xf, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n      } else {\n        matrix.copyVec2(cp.localPoint, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n        cp.id.swapFeatures();\n      }\n\n      ++pointCount;\n    }\n  }\n\n  manifold.pointCount = pointCount;\n}\n", "import { CollidePolygons } from './collision/shape/CollidePolygon';\nimport { SettingsInternal as Settings } from './Settings';\nimport { Sweep } from './common/Sweep';\nimport { DynamicTree } from './collision/DynamicTree';\nimport { Manifold } from './collision/Manifold';\nimport { Distance } from './collision/Distance';\nimport { TimeOfImpact } from './collision/TimeOfImpact';\nimport { stats } from './util/stats';\n\n/** @deprecated Merged with main namespace */\nexport const internal = {\n  CollidePolygons,\n  Settings,\n  Sweep,\n  Manifold,\n  Distance,\n  TimeOfImpact,\n  DynamicTree,\n  stats\n};\n", "import { Vec2 as V2 } from \"kaboom\"\nimport { Box, CircleShape, BoxShape, PolygonShape, ChainShape, Vec2 } from 'planck'\n\nexport type ColliderOpt = {\n    friction?: number\n    bounciness?: number\n    isTrigger?: boolean\n}\n\nexport function collider(opt: ColliderOpt) {\n    let fixture\n    return {\n        id: \"collider\",\n        require: [\"rigidBody\"],\n        add() {\n            // TODO: anchor\n            if (this.is(\"sprite\") || this.is(\"rect\")) {\n                const w = (this.width || 61) / 20\n                const h = (this.height || 53) / 20\n                fixture = this.body.createFixture({\n                    shape: new Box(w, h, Vec2(0, 0)),\n                    density: 1,\n                    friction: opt.friction || 0,\n                    restitution: opt.bounciness || 0,\n                    isSensor: opt.isTrigger,\n                    \n                })\n            }\n            else {\n                fixture = this.body.createFixture({\n                    shape: new Box(50 / 2, 4 / 2, Vec2(0, 0)),\n                    density: 1,\n                    friction: opt.friction || 0,\n                    restitution: opt.bounciness || 0,\n                    isSensor: opt.isTrigger\n                })\n            }\n        },\n        destroy() {\n            this.body.destroyFixture(fixture);\n        },\n        /*draw() {\n            let shape = fixture.getShape()\n            switch (shape.m_type) {\n                case \"edge\":\n                    drawLine({\n                        pos: p2k(this.body.m_xf.p),\n                        p1: p2k(shape.m_vertex1),\n                        p2: p2k(shape.m_vertex2),\n                        width: 1,\n                        color: rgb(0, 0, 255)\n                    })\n                    break\n                case \"chain\":\n                    drawLines({\n                        pos: p2k(this.body.m_xf.p),\n                        pts: shape.m_vertices.map(p => p2k(p)),\n                        width: 1,\n                        color: rgb(0, 0, 255)\n                    })\n                    break\n                case \"polygon\":\n                    drawLines({\n                        pos: p2k(this.body.m_xf.p),\n                        pts: shape.m_vertices.map(p => p2k(p)),\n                        color: rgb(0, 0, 255)\n                    })\n                    break\n                case \"circle\":\n                    drawCircle({\n                        pos: p2k(this.body.m_xf.p),\n                        radius: shape.m_radius,\n                        color: rgb(0, 0, 255)\n                    })\n                    break\n                default:\n                    console.log(`Unknown shape ${shape.m_type}`)\n                    break\n            }\n        }*/\n    }\n}\n\nexport type CircleColliderOpt = ColliderOpt & {\n    offset?: V2\n    radius: number\n}\n\nexport function circleCollider(opt: CircleColliderOpt) {\n    let fixture\n    return {\n        id: \"circleCollider\",\n        require: [\"rigidBody\"],\n        add() {\n            fixture = this.body.createFixture({\n                shape: new CircleShape(opt.offset ? k2p(opt.offset) : Vec2(0, 0), opt.radius / 10),\n                density: 1,\n                friction: opt.friction || 0,\n                restitution: opt.bounciness || 0,\n                isSensor: opt.isTrigger\n            })\n        },\n        destroy() {\n            this.body.destroyFixture(fixture);\n        }\n    }\n}\n\nexport type BoxColliderOpt = ColliderOpt & {\n    offset?: V2\n    size: V2\n}\n\nexport function boxCollider(opt: BoxColliderOpt) {\n    let fixture\n    return {\n        id: \"boxCollider\",\n        require: [\"rigidBody\"],\n        add() {\n            fixture = this.body.createFixture({\n                shape: new BoxShape(opt.size.x / 20, opt.size.y / 20, opt.offset ? k2p(opt.offset) : Vec2(0, 0), 0),\n                density: 1,\n                friction: opt.friction || 0,\n                restitution: opt.bounciness || 0,\n                isSensor: opt.isTrigger\n            })\n        },\n        destroy() {\n            this.body.destroyFixture(fixture);\n        }\n    }\n}\n\nexport type PolygonColliderOpt = ColliderOpt & {\n    offset?: V2\n    points: V2[]\n}\n\nexport function polygonCollider(opt: PolygonColliderOpt) {\n    let fixture\n    return {\n        id: \"polygonCollider\",\n        require: [\"rigidBody\"],\n        add() {\n            fixture = this.body.createFixture({\n                shape: new PolygonShape(opt.points.map(p => k2p(p))),\n                density: 1,\n                friction: opt.friction || 0,\n                restitution: opt.bounciness || 0,\n                isSensor: opt.isTrigger\n            })\n        },\n        destroy() {\n            this.body.destroyFixture(fixture);\n        }\n    }\n}\n\nexport type EdgeColliderOpt = ColliderOpt & {\n    offset?: V2\n    points: V2[]\n}\n\nexport function edgeCollider(opt: EdgeColliderOpt) {\n    let fixture\n    return {\n        id: \"edgeCollider\",\n        require: [\"rigidBody\"],\n        add() {\n            fixture = this.body.createFixture({\n                shape: new ChainShape(opt.points.map(p => k2p(p))),\n                density: 1,\n                friction: opt.friction || 0,\n                restitution: opt.bounciness || 0,\n                isSensor: opt.isTrigger\n            })\n        },\n        destroy() {\n            this.body.destroyFixture(fixture);\n        }\n    }\n}", "import { Vec2 as V2 } from \"kaboom\"\nimport { World, Vec2 } from 'planck'\n\nexport function p2k(v: Vec2) {\n    return vec2(v.x * 10, v.y * 10)\n}\n\nexport function k2p(v: V2) {\n    return Vec2(v.x / 10, v.y / 10)\n}\n\nexport let world = new World({\n    gravity: Vec2(0.0, 2400 / 100),\n});\n\nworld.on('begin-contact', function(contact) {\n    const bodyA = contact.getFixtureA().getBody().getUserData()\n    const bodyB = contact.getFixtureB().getBody().getUserData()\n    bodyA.trigger(\"collision_enter\", bodyB)\n    bodyB.trigger(\"collision_enter\", bodyA)\n})\n\nworld.on('end-contact', function(contact) {\n  const bodyA = contact.getFixtureA().getBody().getUserData()\n    const bodyB = contact.getFixtureB().getBody().getUserData()\n    bodyA.trigger(\"collision_exit\", bodyB)\n    bodyB.trigger(\"collision_exit\", bodyA)\n})\n\nworld.on('pre-solve', function(contact, oldManifold) {\n  /* handle pre-solve event */\n})\n\nworld.on('post-solve', function(contact, contactImpulse) {\n  /* handle post-solve event */\n})\n", "import { Comp, Vec2 as V2, GameObj, EventController } from \"kaboom\"\nimport { Vec2, DistanceJoint, RevoluteJoint, MouseJoint } from 'planck'\nimport { k2p, p2k, world } from \"./world\"\nimport { RigidBodyComp } from \"./rigid_body\"\n\nexport type DistanceJointOpt = {\n    connectedObject: GameObj<RigidBodyComp>\n    anchor: V2\n    connectedObjectAnchor: V2\n    enableCollision?: boolean\n    distance?: number\n}\n\nexport interface DistanceJointComp extends Comp {\n    distance: number\n}\n\nexport function distanceJoint(opt: DistanceJointOpt): DistanceJointComp {\n    let joint: DistanceJoint | null\n    return {\n        id: \"distanceJoint\",\n        require: [\"rigidBody\"],\n        add() {\n            joint = world.createJoint(new DistanceJoint({\n                collideConnected: opt.enableCollision ?? true,\n                bodyA: this.body,\n                bodyB: opt.connectedObject.body,\n                localAnchorA: k2p(opt.anchor),\n                localAnchorB: k2p(opt.connectedObjectAnchor)\n            }))\n            if (joint && opt.distance) {\n                joint.setLength(opt.distance / 10)\n            }\n        },\n        destroy() {\n            if (joint) {\n                world.destroyJoint(joint)\n            }\n        },\n        get distance() {\n            return joint ? joint.getLength() * 10 : 0\n        },\n        set distance(d: number) {\n            if (joint) { joint.setLength(d / 10) }\n        },\n    }\n}\n\nexport type HingeJointOpt = {\n    connectedObject: GameObj<RigidBodyComp>\n    anchor: V2\n    connectedObjectAnchor: V2\n    enableCollision?: boolean\n    limits?: { min: number, max: number }\n    //limitState\tGets the state of the joint limit.\n    motor?: { maxMotorTorque: number, motorSpeed: number }\n    referenceAngle: number\n    useLimits?: boolean\n    useMotor?: boolean\n    breakForce?: number\n}\n\nexport interface HingeJointComp extends Comp {\n    jointAngle: number\n    jointSpeed: number\n    GetReactionForce(): V2\n    GetReactionTorque(): number\n    onJointBreak(callback: (j: RevoluteJoint) => void): EventController\n}\n\nexport function hingeJoint(opt: HingeJointOpt): HingeJointComp {\n    let joint: RevoluteJoint | null\n    return {\n        id: \"distanceJoint\",\n        require: [\"rigidBody\"],\n        add() {\n            joint = world.createJoint(new RevoluteJoint({\n                collideConnected: opt.enableCollision ?? true,\n                bodyA: this.body,\n                bodyB: opt.connectedObject.body,\n                localAnchorA: k2p(opt.anchor),\n                localAnchorB: k2p(opt.connectedObjectAnchor),\n                lowerAngle: opt.limits?.min,\n                upperAngle: opt.limits?.max,\n                enableLimit: opt.useLimits,\n                maxMotorTorque: opt.motor?.maxMotorTorque,\n                motorSpeed: opt.motor?.motorSpeed,\n                enableMotor: opt.useMotor,\n                referenceAngle: opt.referenceAngle\n            }))\n        },\n        destroy() {\n            if (joint) {\n                world.destroyJoint(joint)\n            }\n        },\n        update() {\n            if (opt.breakForce && this.GetReactionForce() > opt.breakForce) {\n                this.trigger(\"jointbreak\", this)\n            }\n        },\n        onJointBreak(callback: (j: RevoluteJoint) => void) {\n            return this.on(\"jointbreak\", callback)\n        },\n        GetReactionForce() {\n            return joint ? p2k(joint.getReactionForce(1 / dt())) : vec2()\n        },\n        GetReactionTorque() {\n            return joint ? joint.getReactionTorque(1 / dt()) : 0\n        },\n        get jointAngle() {\n            return joint ? joint.getJointAngle() : 0\n        },\n        get jointSpeed() {\n            return joint ? joint.getJointSpeed() : 0\n        }\n    }\n}\n\nexport type SpringJointOpt = {\n    connectedObject: GameObj<RigidBodyComp>\n    anchor: V2\n    connectedObjectAnchor: V2\n    enableCollision?: boolean\n    distance?: number\n    dampingRatio: number\n    frequency: number\n}\n\nexport interface SpringJointComp extends Comp {\n    dampingRatio: number\n    distance?: number\n    frequency: number\n}\n\nexport function springJoint(opt: SpringJointOpt): SpringJointComp {\n    let joint: DistanceJoint | null\n    return {\n        id: \"distanceJoint\",\n        require: [\"rigidBody\"],\n        add() {\n            joint = world.createJoint(new DistanceJoint({\n                collideConnected: opt.enableCollision ?? true,\n                bodyA: this.body,\n                bodyB: opt.connectedObject.body,\n                localAnchorA: k2p(opt.anchor),\n                localAnchorB: k2p(opt.connectedObjectAnchor),\n                dampingRatio: opt.dampingRatio,\n                frequencyHz: opt.frequency\n            }))\n            if (joint && opt.distance) {\n                joint.setLength(opt.distance / 10)\n            }\n        },\n        destroy() {\n            if (joint) {\n                world.destroyJoint(joint)\n            }\n        },\n        get dampingRatio() {\n            return joint ? joint.getDampingRatio() : 0\n        },\n        set dampingRatio(d: number) {\n            if (joint) { joint.setDampingRatio(d) }\n        },\n        get distance() {\n            return joint ? joint.getLength() * 10 : 0\n        },\n        set distance(d: number) {\n            if (joint) { joint.setLength(d / 10) }\n        },\n        get frequency() {\n            return joint ? joint.getFrequency() : 0\n        },\n        set frequency(f: number) {\n            if (joint) { joint.setFrequency(f) }\n        },\n    }\n}\n\nexport type TargetJointOpt = {\n    anchor?: V2\n    enableCollision?: boolean\n    dampingRatio: number\n    frequency: number,\n    maxForce?: number\n}\n\nexport interface TargetJointComp extends Comp {\n    dampingRatio: number\n    frequency: number\n    target: V2\n}\n\nexport function targetJoint(opt: TargetJointOpt): TargetJointComp {\n    let joint: MouseJoint | null\n    let ground\n    return {\n        id: \"targetJoint\",\n        require: [\"rigidBody\"],\n        add() {\n            ground = world.createBody();\n            joint = world.createJoint(new MouseJoint({\n                collideConnected: opt.enableCollision ?? true,\n                bodyA: ground,\n                bodyB: this.body,\n                target: opt.anchor ? Vec2(opt.anchor.x, opt.anchor.y) : this.body.getWorldCenter(),\n                dampingRatio: opt.dampingRatio,\n                frequencyHz: opt.frequency,\n                maxForce: opt.maxForce || 0\n            }))\n        },\n        destroy() {\n            if (ground) {\n                world.destroyBody(ground);\n            }\n            if (joint) {\n                world.destroyJoint(joint)\n            }\n        },\n        get dampingRatio() {\n            return joint ? joint.getDampingRatio() : 0\n        },\n        set dampingRatio(d: number) {\n            if (joint) { joint.setDampingRatio(d) }\n        },\n        get frequency() {\n            return joint ? joint.getFrequency() : 0\n        },\n        set frequency(f: number) {\n            if (joint) { joint.setFrequency(f) }\n        },\n        get target() {\n            return joint ? p2k(joint.getTarget()) : vec2()\n        },\n        set target(t: V2) {\n            if (joint) { joint.setTarget(k2p(t)) }\n        },\n    }\n}", "import { Comp, Vec2 as V2 } from \"kaboom\"\n\nexport type ConstantForceOpt = {\n    force: V2\n    relativeForce: V2\n    torque: number\n}\n\nexport interface ConstantForceComp extends Comp {\n    force: V2\n    relativeForce: V2\n    torque: number\n}\n\nexport function constantForce(opt: ConstantForceOpt): ConstantForceComp {\n    let _force = opt.force\n    let _relativeForce = opt.relativeForce\n    let _torque = opt.torque\n    return {\n        id: \"constantForce\",\n        require: [\"rigidBody\"],\n        update() {\n            if (_force) {\n                this.applyForce(_force)\n            }\n        },\n        get force() {\n            return _force\n        },\n        set force(value: V2) {\n            _force = value\n        },\n        get relativeForce() {\n            return _relativeForce\n        },\n        set relativeForce(value: V2) {\n            _relativeForce = value\n        },\n        get torque() {\n            return _torque\n        },\n        set torque(value: number) {\n            _torque = value\n        }\n    }\n}\n\nexport type ForceMode = \"constant\" | \"inverseLinear\" | \"inverseSquared\"\n\nexport type PointEffectorOpt = {\n    forceMagnitude: number\n    forceVariation?: number\n    distanceScale?: number\n    drag?: number\n    angularDrag?: number\n    forceMode: ForceMode\n}\n\nexport interface PointEffectorComp extends Comp {\n    forceMagnitude: number\n    forceVariation: number\n    distanceScale: number\n    drag: number\n    angularDrag: number\n    forceMode: ForceMode\n}\n\nexport function pointEffector(opt: PointEffectorOpt): PointEffectorComp {\n    let forceMagnitude = opt.forceMagnitude ?? 0\n    let forceVariation = opt.forceVariation ?? 0\n    let distanceScale = opt.distanceScale || 1\n    let drag = opt.drag ?? 0\n    let angularDrag = opt.angularDrag ?? 0\n    let forceMode = opt.forceMode ?? \"constant\"\n    return {\n        id: \"pointEffector\",\n        require: [\"rigidBody\"],\n        update() {\n            get(\"rigidBody\").forEach((rb) => {\n                if (rb !== this) {\n                    const v = rb.pos.sub(this.pos)\n                    const l = v.len()\n                    const d = l * distanceScale / 10\n                    const s = forceMode === \"constant\" ? 1 : forceMode === \"inverseLinear\" ? 1 / d : 1 / d ** 2\n                    rb.applyForce(v.scale(forceMagnitude * s / l))\n                }\n            })\n        },\n        get forceMagnitude() {\n            return forceMagnitude\n        },\n        set forceMagnitude(value: number) {\n            forceMagnitude = value\n        },\n        get forceVariation() {\n            return forceVariation\n        },\n        set forceVariation(value: number) {\n            forceVariation = value\n        },\n        get distanceScale() {\n            return distanceScale\n        },\n        set distanceScale(value: number) {\n            distanceScale = value\n        },\n        get drag() {\n            return drag\n        },\n        set drag(value: number) {\n            drag = value\n        },\n        get angularDrag() {\n            return angularDrag\n        },\n        set angularDrag(value) {\n            angularDrag = value\n        },\n        get forceMode() {\n            return forceMode\n        },\n        set forceMode(value: ForceMode) {\n            forceMode = value\n        }\n    }\n}\n", "import { Comp, Vec2 as V2 } from \"kaboom\"\nimport { BodyType, Vec2, Body } from 'planck'\nimport { k2p, p2k, world } from \"./world\"\n\nexport type CollisiondetectionMode = \"discrete\" | \"continuous\"\n\nexport type RigidBodyOpt = {\n    type: BodyType\n    mass?: number\n    drag?: number\n    angularDrag?: number\n    gravityScale?: number\n    freezeRotation?: boolean\n    collisionDetectionMode?: CollisiondetectionMode\n}\n\ntype CollissionCallback = (body: GameObj) => void\n\nexport interface RigidBodyComp extends Comp {\n    body: Body\n    applyForce(force: V2): void\n    applyForce(force: V2, point: V2): void\n    applyTorque(torque: number): void\n    applyLinearImpulse(impulse: V2,): void\n    applyLinearImpulse(impulse: V2, point: V2): void\n    applyAngularImpulse(impulse: number): void\n    jump(force: number): void\n    onCollisionEnter(callback: CollissionCallback): void\n    onCollisionStay(callback: CollissionCallback): void\n    onCollisionExit(callback: CollissionCallback): void\n}\n\nexport function rigidBody(opt: RigidBodyOpt): RigidBodyComp {\n    let _body: Body\n    return {\n        id: \"rigidBody\",\n        require: [\"pos\", \"rotate\"],\n        get body() { return _body },\n        add() {\n            _body = world.createBody({\n                type: opt.type || \"dynamic\",\n                position: k2p(this.pos),\n                angle: deg2rad(this.angle || 0),\n                linearDamping: opt.drag || 0,\n                angularDamping: opt.angularDrag || 0,\n                gravityScale: opt.gravityScale || 1,\n                fixedRotation: opt.freezeRotation || false,\n                bullet: opt.collisionDetectionMode === \"continuous\",\n                userData: this\n            })\n        },\n        destroy() {\n            world.destroyBody(_body);\n        },\n        update() {\n            this.pos = p2k(_body.getPosition())\n            this.angle = rad2deg(_body.getAngle())\n        },\n        /*draw() {\n            drawRect({\n                pos: p2k(_body.getPosition()).sub(2,2).sub(this.pos),\n                width: 4,\n                height: 4,\n                angle: this.angle,\n                color: RED,\n            })\n        },*/\n        applyForce(force: V2, point: V2 | null = null) {\n            const p = point ? Vec2(point.x, point.y) : this.body.getPosition()\n            _body.applyForce(Vec2(force.x, force.y), p)\n        },\n        applyTorque(torque: number) {\n            _body.applyTorque(torque)\n        },\n        applyLinearImpulse(impulse: V2, point: V2 | null = null) {\n            const p = point ? Vec2(point.x, point.y) : this.body.getPosition()\n            _body.applyLinearImpulse(Vec2(impulse.x, impulse.y), p)\n        },\n        applyAngularImpulse(impulse: number) {\n            _body.applyAngularImpulse(impulse)\n        },\n        jump(force: number) {\n            this.applyLinearImpulse(vec2(0, -force))\n        },\n        onCollisionEnter(callback: CollissionCallback) {\n            this.on(\"collide_enter\", callback)\n        },\n    onCollisionStay(callback: CollissionCallback) {\n        this.on(\"collide_stay\", callback)\n    },\n    onCollisionExit(callback: CollissionCallback) {\n        this.on(\"collide_exit\", callback)\n    }\n        \n    }\n}", "import kaboom from \"kaboom\"\nimport \"kaboom/global\"\nimport { collider, circleCollider } from \"./collider\"\nimport { springJoint, targetJoint } from \"./joint\"\nimport { pointEffector } from \"./effectors\"\nimport { rigidBody } from \"./rigid_body\"\nimport { world } from \"./world\"\n\n// initialize context\nkaboom()\n\nonUpdate(() => {\n    const timeStep = 1 / 60\n    const velocityIterations = 10\n    const positionIterations = 8\n    world.step(timeStep, velocityIterations, positionIterations)\n})\n\n// load assets\nloadSprite(\"bean\", \"sprites/bean.png\")\n\n// add a character to screen\nconst bean = add([\n    sprite(\"bean\"),\n    anchor(\"center\"),\n    pos(200, 40),\n    rotate(0),\n    rigidBody({ type: \"dynamic\", freezeRotation: true }),\n    circleCollider({ radius: 25, friction: 0.5 }),\n    pointEffector({ forceMagnitude: -1000, forceMode: \"inverseLinear\", distanceScale: 0.1 }),\n])\n\nadd([\n    rect(300, 40),\n    anchor(\"center\"),\n    pos(200, 300),\n    rotate(0),\n    rigidBody({ type: \"static\" }),\n    collider({ friction: 0.5 })\n])\n\nadd([\n    rect(4, 4),\n    anchor(\"center\"),\n    pos(200, 10),\n    rotate(0),\n    rigidBody({ type: \"static\" }),\n    collider({ friction: 0.5 }),\n    springJoint({\n        anchor: vec2(0, 0),\n        connectedObject: bean,\n        connectedObjectAnchor: vec2(0, -25),\n        distance: 100,\n        dampingRatio: 0.5,\n        frequency: 4\n    }),\n    {\n        draw() {\n            drawLine({\n                p1: vec2(),\n                p2: bean.pos.sub(this.pos),\n                width: 4,\n                color: rgb(0, 0, 255)\n            })\n        }\n    }\n])\n\nloop(1, () => {\n    add([\n        sprite(\"bean\"),\n        anchor(\"center\"),\n        pos(rand(0, 400), 40),\n        rotate(0),\n        rigidBody({ type: \"dynamic\", freezeRotation: false }),\n        circleCollider({ radius: 25, friction: 0.5 }),\n        offscreen({ destroy: true })\n    ])\n})\n\nonKeyPress(\"space\", () => {\n    bean.jump(500)\n})\n\nonKeyDown(\"right\", () => {\n    bean.applyForce(vec2(500, 0))\n})\n\nonKeyDown(\"left\", () => {\n    bean.applyForce(vec2(-500, 0))\n})\n\nonMousePress(() => {\n    bean.use(targetJoint({ dampingRatio: 0.5, frequency: 5, maxForce: 10000 }))\n    bean.target = mousePos()\n})\n\nonMouseMove(() => {\n    if (bean.is(\"targetJoint\")) {\n        bean.target = mousePos()\n    }\n})\n\nonMouseRelease(() => {\n    bean.unuse(\"targetJoint\")\n})\n\nloop(1, () => {\n    console.log(center().angle(mousePos()))\n})"],
  "mappings": "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",
  "names": ["deg2rad", "deg", "__name", "rad2deg", "rad", "clamp", "val", "min", "max", "lerp", "a", "b", "t", "Vec2", "Color", "map", "v", "l1", "h1", "l2", "h2", "mapc", "x", "y", "angle", "_Vec2", "args", "p2", "vec2", "s", "len", "normal", "on", "dest", "cos", "sin", "n", "m", "other", "Rect", "_a", "r", "g", "arr", "_Color", "hex", "result", "h", "l", "hue2rgb", "p", "q", "d", "rgb", "hsl2rgb", "Quad", "w", "_Quad", "quad", "Mat4", "_Mat4", "c", "m0", "m1", "m4", "m5", "out", "i", "j", "det", "f00", "f01", "f02", "f03", "f04", "f05", "f06", "f07", "f08", "f09", "f10", "f11", "f12", "f13", "f14", "f15", "f16", "f17", "f18", "wave", "lo", "hi", "f", "A", "C", "M", "RNG", "seed", "defRNG", "randSeed", "rand", "randi", "chance", "choose", "list", "testRectRect", "r1", "r2", "testLineLineT", "denom", "ua", "ub", "testLineLine", "testRectLine", "testRectPoint", "pts", "Line", "pt", "testLinePoint", "v1", "v2", "testLineCircle", "circle", "centerToOrigin", "dis", "t1", "t2", "testCirclePoint", "testCirclePolygon", "prev", "cur", "testPolygonPoint", "poly", "p1", "_Line", "pos", "width", "height", "_Rect", "Polygon", "dx", "dy", "Circle", "center", "radius", "tr", "Ellipse", "_Circle", "rx", "ry", "_Ellipse", "_Polygon", "total", "sat", "overlap", "displacement", "axisProj", "min1", "max1", "min2", "max2", "o", "o1", "o2", "IDList", "id", "EventController", "cancel", "events", "ev", "_EventController", "e", "Event", "action", "res", "EventHandler", "name", "deepEq", "k1", "k2", "k", "base64ToArrayBuffer", "base64", "binstr", "bytes", "dataURLToArrayBuffer", "url", "download", "filename", "downloadText", "text", "downloadJSON", "data", "downloadBlob", "blob", "isDataURL", "str", "getExt", "uid", "BinaryHeap", "compareFn", "item", "lastItem", "parent", "child", "index1", "index2", "gamepad_default", "ButtonState", "btn", "GamepadState", "FPSCounter", "dt", "app_default", "opt", "state", "canvas", "time", "fps", "numFrames", "screenshot", "setCursor", "getCursor", "setCursorLocked", "isCursorLocked", "enterFullscreen", "el", "exitFullscreen", "getFullscreenElement", "setFullscreen", "isFullscreen", "quit", "canvasEvents", "docEvents", "winEvents", "resizeObserver", "run", "accumulatedDt", "frame", "loopTime", "realDt", "desiredDt", "processInput", "resetInput", "isTouchscreen", "mousePos", "mouseDeltaPos", "isMousePressed", "isMouseDown", "isMouseReleased", "isMouseMoved", "isKeyPressed", "isKeyPressedRepeat", "isKeyDown", "isKeyReleased", "isGamepadButtonPressed", "isGamepadButtonDown", "isGamepadButtonReleased", "onResize", "onKeyDown", "key", "onKeyPress", "onKeyPressRepeat", "onKeyRelease", "onMouseDown", "mouse", "onMousePress", "onMouseRelease", "onMouseMove", "onCharInput", "onTouchStart", "onTouchMove", "onTouchEnd", "onScroll", "onHide", "onShow", "onGamepadButtonDown", "onGamepadButtonPress", "onGamepadButtonRelease", "onGamepadStick", "stick", "onGamepadConnect", "onGamepadDisconnect", "getGamepadStick", "charInputted", "getGamepads", "processGamepad", "registerGamepad", "browserGamepad", "gamepad", "removeGamepad", "gamepadState", "stickName", "value", "pd", "cw", "ch", "ww", "wh", "rw", "rc", "ratio", "offset", "MOUSE_BUTTONS", "PREVENT_DEFAULT_KEYS", "KEY_ALIAS", "touches", "box", "kbGamepad", "entries", "entry", "c2", "c3", "c4", "c5", "easings", "easings_default", "Timer", "VERSION", "ASCII_CHARS", "DEF_ANCHOR", "BG_GRID_SIZE", "DEF_FONT", "DBG_FONT", "DEF_TEXT_SIZE", "DEF_TEXT_CACHE_SIZE", "MAX_TEXT_CACHE_SIZE", "FONT_ATLAS_WIDTH", "FONT_ATLAS_HEIGHT", "SPRITE_ATLAS_WIDTH", "SPRITE_ATLAS_HEIGHT", "UV_PAD", "DEF_HASH_GRID_SIZE", "DEF_FONT_FILTER", "LOG_MAX", "LOG_TIME", "VERTEX_FORMAT", "STRIDE", "sum", "MAX_BATCHED_QUAD", "MAX_BATCHED_VERTS", "MAX_BATCHED_INDICES", "VERT_TEMPLATE", "FRAG_TEMPLATE", "DEF_VERT", "DEF_FRAG", "COMP_DESC", "COMP_EVENTS", "anchorPt", "orig", "alignPt", "align", "createEmptyAudioBuffer", "ctx", "kaboom_default", "gopt", "root", "gscale", "fixedSize", "styles", "pixelDensity", "fontCacheCanvas", "fontCacheCtx", "app", "gc", "gl", "genBindFunc", "func", "bindings", "ty", "stack", "glTextureBinder", "glFramebufferBinder", "glRenderbufferBinder", "Texture", "filter", "wrap", "img", "tex", "KaboomError", "msg", "TexPacker", "FrameBuffer", "bytesPerRow", "temp", "topOffset", "bottomOffset", "gfx", "defShader", "makeShader", "emptyTex", "frameBuffer", "bgColor", "bgAlpha", "vbuf", "ibuf", "bgTex", "SpriteData", "frames", "anims", "slice9", "src", "assets", "slice", "loadImg", "SoundData", "buf", "resolve", "reject", "audio", "fetchArrayBuffer", "masterNode", "burpSnd", "burp_default", "err", "Asset", "loader", "asset", "AssetBucket", "handle", "loaded", "game", "make", "load", "prom", "loadProgress", "buckets", "bucket", "loadRoot", "path", "fetchURL", "fetchJSON", "fetchText", "loadJSON", "FontData", "face", "loadFont", "font", "loadBitmapFont", "gw", "gh", "makeFont", "qw", "qh", "loadSpriteAtlas", "rej", "json", "atlas", "info", "spr", "createSpriteSheet", "images", "merged", "loadSprite", "loadPedit", "loadAseprite", "imgSrc", "jsonSrc", "resolveJSON", "size", "anim", "loadShader", "vert", "frag", "loadShaderURL", "resolveUrl", "vcode", "fcode", "loadSound", "loadBean", "bean_default", "getSprite", "getSound", "getFont", "getBitmapFont", "getShader", "getAsset", "resolveSprite", "resolveSound", "snd", "resolveShader", "shader", "resolveFont", "bfont", "volume", "play", "paused", "srcNode", "onEndEvents", "gainNode", "startTime", "stopTime", "started", "getTime", "start", "cloneNode", "oldNode", "newNode", "burp", "vertSrc", "fragSrc", "vertShader", "fragShader", "prog", "formatShaderError", "FMT", "match", "vertError", "fragError", "uniform", "loc", "chars", "cols", "charMap", "drawRaw", "verts", "indices", "fixed", "shaderSrc", "flush", "transform", "screen2ndc", "frameStart", "drawUnscaled", "drawUVQuad", "usePostEffect", "frameEnd", "ow", "oh", "drawTexture", "pushMatrix", "pushTranslate", "pushScale", "pushRotate", "pushTransform", "popTransform", "color", "opacity", "uvPadX", "uvPadY", "qx", "qy", "scale", "repX", "repY", "drawSprite", "getArcPts", "radiusX", "radiusY", "end", "nverts", "step", "drawRect", "drawPolygon", "drawLine", "drawLines", "minSLen", "drawCircle", "drawTriangle", "drawEllipse", "polyOpt", "npts", "drawStenciled", "content", "mask", "test", "drawMasked", "drawSubtracted", "getViewportScale", "applyCharTransform", "fchar", "TEXT_STYLE_RE", "compileStyledText", "charStyleMap", "renderText", "idxOffset", "origIdx", "fontAtlases", "formatText", "fontName", "opts", "c2d", "lineSpacing", "letterSpacing", "curX", "tw", "th", "lines", "curLine", "cursor", "lastSpace", "lastSpaceWidth", "fchars", "line", "ox", "idx", "style", "drawText", "drawFormattedText", "ftext", "windowToContent", "contentToView", "handleErr", "debugPaused", "debug", "updateFrame", "get", "camPos", "camScale", "camRot", "shake", "intensity", "toScreen", "toWorld", "calcTransform", "obj", "comps", "compStates", "cleanups", "inputEvents", "onCurCompCleanup", "trigger", "tag", "children", "maskFunc", "comp", "prop", "checkDeps", "dep", "recurse", "isChild", "onAdd", "onDestroy", "ctrl", "cb", "evs", "event", "onUpdate", "add", "onDraw", "onCollide", "col", "onCollideUpdate", "onCollideEnd", "forAllCurrentAndFuture", "onClick", "onHover", "onHoverUpdate", "onHoverEnd", "wait", "actions", "loop", "curTimer", "newAction", "enterDebugMode", "toFixed", "enterBurpMode", "setGravity", "getGravity", "setBackground", "getBackground", "speed", "diff", "isFixed", "rotate", "easeFunc", "tween", "anchor", "z", "follow", "move", "dir", "DEF_OFFSCREEN_DIS", "offscreen", "distance", "isOut", "screenRect", "area", "colliding", "collidingThisFrame", "mpos", "hovering", "localArea", "getRenderProps", "sprite", "spriteData", "curAnim", "curAnimDir", "spriteLoadedEvent", "calcTexScale", "_b", "left", "right", "top", "bottom", "iw", "ih", "w1", "w3", "w2", "h3", "quads", "uv", "_c", "setSpriteData", "onLoad", "prevAnim", "update", "nt", "rect", "uvquad", "outline", "timer", "from", "to", "duration", "setValue", "curTime", "DEF_JUMP_FORCE", "MAX_VEL", "body", "vel", "curPlatform", "lastPlatformPos", "wantFall", "tmass", "col2", "prevVelY", "force", "doubleJump", "numJumps", "jumpsLeft", "stay", "scenesToStay", "health", "hp", "maxHP", "lifespan", "fade", "initState", "stateList", "transitions", "initStateEvents", "didFirstEnter", "oldState", "available", "fadeIn", "done", "scene", "def", "go", "initEvents", "onSceneLeave", "getData", "setData", "plug", "plugin", "funcs", "funcsObj", "EdgeMask", "tile", "tilePos", "isObstacle", "cost", "edges", "getEdgeMask", "loopup", "edgeMask", "level", "is", "addLevel", "numRows", "numColumns", "spatialMap", "costMap", "edgeMap", "connectivityMap", "tile2Hash", "hash2Tile", "hash", "createSpatialMap", "insertIntoSpatialMap", "removeFromSpatialMap", "index", "updateSpatialMap", "spatialMapChanged", "createCostMap", "objects", "createEdgeMap", "createConnectivityMap", "traverse", "frontier", "getNeighbours", "getCost", "node", "neighbour", "getHeuristic", "goal", "diagonals", "levelComp", "hasPos", "hasTile", "cameFrom", "costSoFar", "current", "neighbours", "next", "newCost", "row", "keys", "agent", "target", "navMapChangedEvent", "record", "frameRate", "stream", "audioDest", "recorder", "chunks", "isFocused", "destroy", "readd", "destroyAll", "boom", "kaSprite", "ka_default", "boomSprite", "boom_default", "addKaboom", "kaboom", "ka", "Collision", "source", "resolved", "checkFrame", "grid", "cellSize", "checkObj", "aobj", "bbox", "xmin", "ymin", "xmax", "ymax", "checked", "cell", "check", "col1", "drawFrame", "cam", "drawLoadScreen", "progress", "drawInspectText", "txt", "pad", "ftxt", "bw", "bh", "drawDebug", "inspecting", "flipped", "logs", "log", "onLoading", "onError", "textStyle", "title", "onCleanup", "numTextureUnits", "unit", "isFirstFrame", "updateViewport", "rg", "sw", "sh", "d", "b", "__assign", "s", "n", "input", "output", "x", "math_abs", "math_sqrt", "math_max", "math_min", "Vec2", "v", "o", "a", "AABB", "normal", "temp", "math_PI", "Settings", "SettingsInternal", "Pool", "TreeNode", "DynamicTree", "it", "c", "Iterator", "BroadPhase", "displacement", "math_sin", "math_cos", "vec2", "transform", "xf", "math_atan2", "Rot", "matrix.vec2", "Sweep", "matrix.zeroVec2", "matrix.transformVec2", "matrix.copyVec2", "localCenter", "matrix.setRotAngle", "matrix.combineVec2", "matrix.subVec2", "matrix.rotVec2", "Transform", "rotation", "Velocity", "Position", "Shape", "FixtureProxy", "Fixture", "matrix.diffVec2", "world", "matrix.transform", "Body", "ce", "matrix.addMulVec2", "matrix.setMulVec2", "matrix.dotVec2", "matrix.crossNumVec2", "matrix.addVec2", "point", "jn", "JointEdge", "Joint", "DistanceInput", "DistanceOutput", "SimplexCache", "cache", "xfA", "xfB", "matrix.lengthSqrVec2", "matrix.invRotVec2", "matrix.distVec2", "rA", "rB", "matrix.normalizeVec2", "matrix.subMulVec2", "DistanceProxy", "SimplexVertex", "Simplex", "v1", "v2", "matrix.setVec2", "matrix.crossVec2Vec2", "pA", "pB", "matrix.copyTransform", "ShapeCastInput", "ShapeCastOutput", "math_abs", "math_max", "TOIInput", "TOIOutputState", "TOIOutput", "xfA", "matrix.transform", "xfB", "temp", "matrix.vec2", "pointA", "pointB", "normal", "output", "input", "Settings", "matrix.copyTransform", "s", "SeparationFunctionType", "SeparationFunction", "matrix.zeroVec2", "cache", "matrix.transformVec2", "matrix.diffVec2", "matrix.normalizeVec2Length", "matrix.crossVec2Num", "matrix.normalizeVec2", "matrix.rotVec2", "matrix.combineVec2", "matrix.dotVec2", "matrix.negVec2", "matrix.invRotVec2", "matrix.setMulVec2", "matrix.copyVec2", "math_sqrt", "math_min", "TimeStep", "dt", "ContactImpulse", "Solver", "world", "b", "ce", "a", "matrix.addMulVec2", "matrix.lengthSqrVec2", "matrix.scaleVec2", "rotation", "Mat22", "c", "d", "o", "v", "x", "cA", "cB", "planePoint", "clipPoint", "ManifoldType", "ContactFeatureType", "PointState", "ClipVertex", "Manifold", "matrix.setVec2", "ManifoldPoint", "ContactID", "WorldManifold", "ContactEdge", "VelocityConstraintPoint", "tangent", "P", "Contact", "_a", "worldManifold", "matrix.crossVec2Vec2", "matrix.subMulVec2", "matrix.crossNumVec2", "matrix.addVec2", "matrix.subVec2", "vt", "World", "point", "oldManifold", "Vec3", "z", "v1", "v2", "EdgeShape", "xf", "e", "v1", "matrix.vec2", "ChainShape", "loop", "Settings", "xf", "output", "input", "matrix.transformVec2", "matrix.zeroVec2", "math_max", "math_min", "temp", "matrix.vec2", "e", "e1", "e2", "center", "PolygonShape", "Settings", "n", "ps", "v", "x", "ie", "c", "matrix.copyVec2", "xf", "matrix.invTransformVec2", "matrix.dotVec2", "output", "input", "d", "matrix.transformVec2", "matrix.setVec2", "matrix.zeroVec2", "matrix.addVec2", "matrix.setMulVec2", "matrix.diffVec2", "matrix.crossVec2Vec2", "matrix.combineVec2", "matrix.sumVec2", "vs", "BoxShape", "center", "math_PI", "matrix.vec2", "CircleShape", "a", "b", "xf", "matrix.transformVec2", "matrix.distSqrVec2", "output", "input", "s", "c", "matrix.setVec2", "matrix.copyVec2", "matrix.lengthSqrVec2", "math_abs", "math_PI", "DEFAULTS", "DistanceJoint", "temp", "world", "cA", "vA", "cB", "vB", "Settings", "d", "P", "rA", "rB", "FrictionJoint", "anchor", "Mat33", "a", "b", "c", "o", "v", "x", "z", "LimitState", "RevoluteJoint", "_a", "math_min", "PrismaticJoint", "pA", "pB", "translation", "perp", "GearJoint", "xfA", "xfB", "MotorJoint", "MouseJoint", "PulleyJoint", "s", "RopeJoint", "WeldJoint", "WheelJoint", "obj", "Testbed", "dt", "options", "xfA", "xfB", "matrix.vec2", "matrix.transformVec2", "matrix.distSqrVec2", "rA", "rB", "matrix.copyVec2", "matrix.zeroVec2", "n", "matrix.retransformVec2", "matrix.diffVec2", "matrix.dotVec2", "v", "v2", "matrix.lengthSqrVec2", "matrix.combineVec2", "matrix.crossNumVec2", "matrix.negVec2", "matrix.normalizeVec2", "clipPoints1", "clipPoints2", "xf", "matrix.transform", "normal", "normal1", "output", "matrix.invTransformTransform", "maxSeparation", "matrix.rotVec2", "edge1", "matrix.rerotVec2", "Settings", "matrix.crossVec2Num", "matrix.setVec2", "matrix.invTransformVec2", "s", "v1", "EPAxisType", "VertexType", "EPAxis", "TempPolygon", "ReferenceFace", "ie", "matrix.crossVec2Vec2", "matrix.setMulVec2", "s2", "v", "k2p", "oldManifold", "_a", "k2p", "d", "_a", "v", "d", "s", "k2p", "point"]
}
